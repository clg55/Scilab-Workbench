<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?> 
<!DOCTYPE MAN SYSTEM "../../man.dtd">
<MAN>
  <LANGUAGE>eng</LANGUAGE>
  <TITLE>bvode  </TITLE>
  <TYPE>Scilab Function  </TYPE>
  <DATE>June 1993  </DATE>
  <SHORT_DESCRIPTION name="bvode"> boundary value problems for ODE  </SHORT_DESCRIPTION>
  <CALLING_SEQUENCE>
  <CALLING_SEQUENCE_ITEM>   [z]=bvode(points,ncomp,m,aleft,aright,zeta,ipar,ltol,tol,fixpnt,...  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM> fsub1,dfsub1,gsub1,dgsub1,guess1)  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>
  <PARAM>
 <PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>z  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    The solution of the ode evaluated on the mesh given by points
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>points  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    an array which gives the points for which we want the solution 
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>ncomp  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    number of differential equations   (ncomp &lt;= 20)
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>m  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    a vector of size <VERB>ncomp</VERB>. <VERB>m(j)</VERB> gives the  order of the j-th differential equation
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>aleft  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    left end of interval
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>aright  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    right end of interval
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>zeta  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    <VERB>zeta(j)</VERB> gives j-th side condition point (boundary point). must have  
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <P>
    <VERB>zeta(j) &lt;= zeta(j+1)</VERB>
  </P>
  <P>
    all side condition points must be mesh points in all meshes used, see description of <VERB>ipar(11)</VERB> and <VERB>fixpnt</VERB> below.
  </P>
  <PARAM_ITEM>
  <PARAM_NAME>ipar  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    an integer array dimensioned at least 11. a list of the parameters in <VERB>ipar</VERB> and their meaning follows some parameters are renamed in bvode; these new names are given in parentheses.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 <PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>ipar(1)  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    ( = nonlin )
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 <PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>= 0  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    if the problem is linear
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>= 1 if the problem is nonlinear  </PARAM_NAME>
  <PARAM_DESCRIPTION>
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 </PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>ipar(2)  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    = number of collocation points per subinterval  (= k ) where 
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <P>
    <VERB>max m(i) &lt;=  k &lt;= 7 .</VERB>
  </P>
  <P>
    if <VERB>ipar(2)=0</VERB> then bvode sets  
  </P>
  <P>
    <VERB>k = max ( max m(i)+1, 5-max m(i) )</VERB>
  </P>
  <PARAM_ITEM>
  <PARAM_NAME>ipar(3)  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    = number of subintervals in the initial mesh  ( = n ). if <VERB>ipar(3) = 0</VERB> then bvode arbitrarily sets <VERB>n = 5</VERB>.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>ipar(4)  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    = number of solution and derivative tolerances.  ( = ntol ) we require  
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <P>
    <VERB>0 &lt; ntol &lt;= mstar.</VERB>
  </P>
  <PARAM_ITEM>
  <PARAM_NAME>ipar(5)  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    = dimension of <VERB>fspace</VERB> ( = ndimf ) a real work array. its size provides a constraint on nmax. choose ipar(5) according to the formula
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>ipar(6)  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    = dimension of ispace ( = ndimi )an integer work array. its size provides a constraint on nmax, the maximum number of subintervals. choose <VERB>ipar(6)</VERB> according to the formula
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>ipar(7)  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    output control ( = iprint )
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 <PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>= -1  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    for full diagnostic printout
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>= 0  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    for selected printout
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>= 1  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    for no printout
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 </PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>ipar(8)  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    ( = iread )
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 <PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>= 0  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    causes bvode to generate a uniform initial mesh.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>= xx  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    Other values are not implemented yet in Scilab 
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 <PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>= 1  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    if the initial mesh is provided by the user.  it is defined in fspace as follows:  the mesh
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <P>
    will occupy  <VERB>fspace(1), ..., fspace(n+1)</VERB>. the user needs to supply only the interior mesh points  <VERB>fspace(j) = x(j), j = 2, ..., n.</VERB>
  </P>
  <PARAM_ITEM>
  <PARAM_NAME>= 2 if the initial mesh is supplied by the user  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    as with <VERB>ipar(8)=1</VERB>, and in addition no adaptive mesh selection is to be done.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 </PARAM_INDENT>
 </PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>ipar(9)  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    ( = iguess )
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 <PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>= 0  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    if no initial guess for the solution is provided.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>= 1  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    if an initial guess is provided by the user in subroutine  <VERB>guess</VERB>.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>= 2  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    if an initial mesh and approximate solution coefficients are provided by the user in fspace. (the former and new mesh are the same).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>= 3  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    if a former mesh and approximate solution coefficients are provided by the user in fspace, and the new mesh is to be taken twice as coarse; i.e.,every second point from the former mesh.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>= 4  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    if in addition to a former initial mesh and approximate solution coefficients, a new mesh is provided in fspace as well. (see description of output for further details on iguess = 2, 3, and 4.)
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 </PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>ipar(10)  </PARAM_NAME>
  <PARAM_DESCRIPTION>
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 <PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>= 0  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    if the problem is regular
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>= 1  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    if the first relax factor is =rstart, and the nonlinear iteration does not rely on past covergence (use for an extra sensitive nonlinear problem only).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>= 2  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    if we are to return immediately upon  (a) two successive nonconvergences, or  (b) after obtaining error estimate for the first time.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 </PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>ipar(11)  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    = number of fixed points in the mesh other than <VERB>aleft</VERB> and <VERB>aright</VERB>. ( = nfxpnt , the dimension of <VERB>fixpnt</VERB>) the code requires that all side condition points other than <VERB>aleft</VERB> and <VERB>aright</VERB> (see description of zeta ) be included as fixed points in <VERB>fixpnt</VERB>.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 </PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>ltol  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    an array of dimension <VERB>ipar(4)</VERB>. <VERB>ltol(j) = l</VERB>  specifies that the j-th tolerance in  tol  controls the error in the l-th component of <VERB>z(u)</VERB>.   also require that
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>tol  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    an array of dimension <VERB>ipar(4)</VERB>. <VERB>tol(j)</VERB> is the error tolerance on the <VERB>ltol(j)</VERB> -th component of <VERB>z(u)</VERB>. thus, the code attempts to satisfy for j=1,...,ntol  on each subinterval
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <P>
    if <VERB>v(x)</VERB> is the approximate solution vector.
  </P>
  <PARAM_ITEM>
  <PARAM_NAME>fixpnt  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    an array of dimension <VERB>ipar(11)</VERB>. it contains the points, other than <VERB>aleft</VERB> and <VERB>aright</VERB>, which are to be included in every mesh.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>externals  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    The function <VERB>fsub,dfsub,gsub,dgsub,guess</VERB> are Scilab externals i.e. functions (see syntax below) or the name of a Fortran subroutine (character string) with specified calling sequence or a list. An external as a  character string refers to the name of a Fortran subroutine. The Fortran coded function interface to bvode are specified in the file <VERB>fcol.f</VERB>.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 <PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>fsub  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    name of subroutine for evaluating 
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <P>
    at a point x in <VERB>(aleft,aright)</VERB>. it should have the heading  <VERB>[f]=fsub(x,z)</VERB>  where <VERB>f</VERB> is the vector containing the value of <VERB>fi(x,z(u))</VERB> in the i-th component and 
  </P>
  <P>
    is defined as above under  purpose .
  </P>
  <PARAM_ITEM>
  <PARAM_NAME>dfsub  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    name of subroutine for evaluating the Jacobian of <VERB>f(x,z(u))</VERB> at a point x.  it should have the heading <VERB>[df]=dfsub (x , z )</VERB> where <VERB>z(u(x))</VERB> is defined as for <VERB>fsub</VERB> and the (<VERB>ncomp</VERB>) by (<VERB>mstar</VERB>) array df should be filled by the partial derivatives of  f, viz, for a particular call one calculates
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>gsub  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    name of subroutine for evaluating the i-th component of
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <P>
    at a point <VERB>x = zeta(i)</VERB>  where 
  </P>
  <P>
    <VERB>1&lt;=i&lt;=mstar.</VERB>
  </P>
  <P>
    it should have the heading<VERB>[g]=gsub (i , z)</VERB> where <VERB>z(u)</VERB> is as for fsub, and i and g=gi  are as above. note that in contrast to f in  fsub , here only one value per call is returned in g.
  </P>
  <PARAM_ITEM>
  <PARAM_NAME>dgsub  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    name of subroutine for evaluating the i-th row of the Jacobian of <VERB>g(x,u(x))</VERB>.  it should have the heading <VERB>[dg]=dgsub (i , z )</VERB> where <VERB>z(u)</VERB> is as for fsub, i as for gsub and the mstar-vector  <VERB>dg</VERB> should be filled with the partial derivatives of g, viz, for a particular call one calculates
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>guess  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    name of subroutine to evaluate the initial approximation for  <VERB>z(u(x))</VERB> and for <VERB>dmval(u(x))</VERB>= vector of the mj-th derivatives of <VERB>u(x)</VERB>. it should have the heading <VERB>[z,dmval]= guess (x )</VERB> note that this subroutine is used only if  <VERB>ipar(9) = 1</VERB>, and then all  <VERB>mstar</VERB>  components of z and  ncomp  components of  dmval  should be specified for any x,  
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <P>
    <VERB>aleft &lt;= x &lt;= aright .</VERB>
  </P>
 </PARAM_INDENT>
 </PARAM_INDENT>
  </PARAM>
  <DESCRIPTION>
  <P>
    this package solves a multi-point boundary value
    problem for a mixed order system of ode-s given by
  </P>
  <P>
  </P>
  <P>
  </P>
  <P>
  </P>
  <P>
  </P>
  <P>
  </P>
  <P>
  </P>
  <P>
  </P>
  <P>
  </P>
  <P>
    the boundary points satisfy
  </P>
  <P>
    the orders mi of the differential equations satisfy 
  </P>
  <P>
    <VERB>1&lt;=m(i)&lt;=4</VERB>.
  </P>
  </DESCRIPTION>
  <EXAMPLE><![CDATA[
deff('df=dfsub(x,z)','df=[0,0,-6/x**2,-6/x]')
deff('f=fsub(x,z)','f=(1 -6*x**2*z(4)-6*x*z(3))/x**3')
deff('g=gsub(i,z)','g=[z(1),z(3),z(1),z(3)];g=g(i)')
deff('dg=dgsub(i,z)',['dg=[1,0,0,0;0,0,1,0;1,0,0,0;0,0,1,0]';
                      'dg=dg(i,:)'])
deff('[z,mpar]=guess(x)','z=0;mpar=0')// unused here

deff('u=trusol(x)',[   //for testing purposes
   'u=0*ones(4,1)';
   'u(1) =  0.25*(10*log(2)-3)*(1-x) + 0.5 *( 1/x   + (3+x)*log(x) - x)'
   'u(2) = -0.25*(10*log(2)-3)       + 0.5 *(-1/x^2 + (3+x)/x      + log(x) - 1)'
   'u(3) = 0.5*( 2/x^3 + 1/x   - 3/x^2)'
   'u(4) = 0.5*(-6/x^4 - 1/x/x + 6/x^3)'])

fixpnt=0;m=4;
ncomp=1;aleft=1;aright=2;
zeta=[1,1,2,2];
ipar=zeros(1,11);
ipar(3)=1;ipar(4)=2;ipar(5)=2000;ipar(6)=200;ipar(7)=1;
ltol=[1,3];tol=[1.e-11,1.e-11];
res=aleft:0.1:aright;
z=bvode(res,ncomp,m,aleft,aright,zeta,ipar,ltol,tol,fixpnt,...
 fsub,dfsub,gsub,dgsub,guess)
z1=[];for x=res,z1=[z1,trusol(x)]; end;  
z-z1
 ]]></EXAMPLE>
  <SEE_ALSO>
    <SEE_ALSO_ITEM> <LINK>fort</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>link</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>external</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>ode</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>dassl</LINK> </SEE_ALSO_ITEM>
  </SEE_ALSO>
  <AUTHOR>u. ascher, department of computer science, university of british; columbia, vancouver, b. c., canada   v6t 1w5; g. bader, institut f. angewandte mathematik university of heidelberg; im neuenheimer feld 294d-6900 heidelberg 1 ; ; Fortran subroutine colnew.f  </AUTHOR>
</MAN>
