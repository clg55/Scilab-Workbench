<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?> 
<!DOCTYPE MAN SYSTEM "../../man.dtd">
<MAN>
  <LANGUAGE>fr</LANGUAGE>
  <TITLE>insertion  </TITLE>
  <TYPE>Scilab Function  </TYPE>
  <DATE>September 1996  </DATE>
  <SHORT_DESCRIPTION name="insertion"> insertion/modification dans une matrice ou une liste  </SHORT_DESCRIPTION>
  <CALLING_SEQUENCE>
  <CALLING_SEQUENCE_ITEM>x(i,j)=a  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>x(i)=a  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>l(i)=a  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>l(k1)...(kn)(i)=a ou l(list(k1,...,kn,i))=a  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>l(k1)...(kn)(i,j)=a ou l(list(k1,...,kn,list(i,j))=a  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>
  <PARAM>
 <PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>x  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : matrice de tout type
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>l  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : liste
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>i,j  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : indices
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>k1,...kn  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : indices à valeurs entières
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>a  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : nouvelles valeurs des termes
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 </PARAM_INDENT>
  </PARAM>
  <DESCRIPTION>
 

  <DESCRIPTION_ITEM  label='CAS DES MATRICES'> 
      <VERB>i</VERB> et <VERB>j</VERB> peuvent être :
  </DESCRIPTION_ITEM>
 

  <DESCRIPTION_ITEM  label='-'> 
    des scalaires, vecteurs ou matrices à éléments positifs. 
  </DESCRIPTION_ITEM>
 

  <DESCRIPTION_ITEM  label='*'> 
    Si <VERB>a</VERB> est une matrice de dimensions <VERB>(size(i,&apos;*&apos;),size(j,&apos;*&apos;))</VERB> <VERB>x(i,j)=a</VERB> renvoie une nouvelle matrice <VERB>x</VERB> telle que <VERB>x(int(i(l)),int(j(k)))=a(l,k) </VERB> pour <VERB>l</VERB> variant de 1 à <VERB>size(i,&apos;*&apos;)</VERB> et <VERB>k</VERB> variant de 1 à <VERB>size(j,&apos;*&apos;)</VERB>, les autres composantes initiales de <VERB>x</VERB> sont inchangées. 
  </DESCRIPTION_ITEM>
  <P>
    Si <VERB>a</VERB> est un scalaire <VERB>x(i,j)=a</VERB> renvoie une nouvelle matrice <VERB>x</VERB> telle que
    <VERB>x(int(i(l)),int(j(k)))=a </VERB> pour  <VERB>l</VERB> variant de 1 à <VERB>size(i,&apos;*&apos;)</VERB> et <VERB>k</VERB> variant de 1 à <VERB>size(j,&apos;*&apos;)</VERB>, les autres composantes initiales de <VERB>x</VERB> sont inchangées. 
  </P>
  <P>
    Si la valeur maximum de <VERB>i</VERB> ou <VERB>j</VERB> dépasse la dimension correspondante de <VERB>x</VERB>, alors <VERB>x</VERB> est au préalable agrandie aux dimensions adéquates en stockant des zéros pour les matrices standard, des chaînes vides pour les matrices de chaînes de caractères ou la valeur %F pour les matrices booléennes.
  </P>
  <P>
  </P>

  <DESCRIPTION_ITEM  label='*'> 
    <VERB>x(i,j)=[]</VERB> détruit les lignes spécifiées par <VERB>i</VERB> si <VERB>j</VERB> désigne toutes les colonnes de <VERB>x</VERB> ou détruit les colonnes spécifiées par <VERB>j</VERB> si <VERB>i</VERB> désigne toutes les lignes de <VERB>x</VERB>. Dans tous les autres cas <VERB>x(i,j)=[]</VERB> produit une erreur.
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='*'> 
    <VERB>x(i)=a</VERB> où <VERB>a</VERB> est un vecteur renvoie une nouvelle matrice <VERB>x</VERB> telle que <VERB>x(int(i(l)))=a(l)</VERB> pour  <VERB>l</VERB> variant de 1 à <VERB>size(i,&apos;*&apos;)</VERB> , les autres composantes initiales de <VERB>x</VERB> sont inchangées. 
  </DESCRIPTION_ITEM>
  <P>
    <VERB>x(i)=a</VERB>  où <VERB>a</VERB> est un scalaire, renvoie une nouvelle matrice <VERB>x</VERB>  telle que
    <VERB>x(int(i(l)))=a</VERB> pour <VERB>l</VERB> variant de 1 à <VERB>size(i,&apos;*&apos;)</VERB> ,
    les autres composantes initiales de <VERB>x</VERB> sont inchangées. 
  </P>
  <P>
    Si la valeur maximum de <VERB>i</VERB> dépasse <VERB>size(x,1)</VERB>, <VERB>x</VERB> est au préalable agrandie aux dimensions adéquates en stockant des zéros pour les matrices standard, des chaînes vides pour les matrices de chaînes de caractères ou la valeur %F pour les matrices booléennes.
  </P>
 

  <DESCRIPTION_ITEM  label='Si'> 
    <VERB>x</VERB> est une matrice 1 x 1 <VERB>a</VERB> peut être un vecteur ligne (resp. colonne) de dimension <VERB>size(i,&apos;*&apos;)</VERB>. La matrice <VERB>x</VERB> obtenue est un vecteur ligne (resp. colonne)
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='Si'> 
    <VERB>x</VERB> est un vecteur ligne (resp. colonne) <VERB>a</VERB> doit être un vecteur ligne (resp. colonne) de dimension <VERB>size(i,&apos;*&apos;)</VERB>
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='Si'> 
    <VERB>x</VERB> est une matrice en général <VERB>a</VERB> doit être un vecteur ligne ou colonne de dimension <VERB>size(i,&apos;*&apos;)</VERB> et la valeur maximum de<VERB>i</VERB> ne peut dépasser <VERB>size(x,&apos;*&apos;)</VERB>,
  </DESCRIPTION_ITEM>
 

  <DESCRIPTION_ITEM  label='*'> 
    <VERB>x(i)=[]</VERB> supprime les termes spécifiés par <VERB>i</VERB>.
  </DESCRIPTION_ITEM>
 
  <P>
    -
    Le symbole <VERB> : </VERB> signifiant &quot;tous les éléments&quot;. 
  </P>
 

  <DESCRIPTION_ITEM  label='*'> 
    <VERB>x(i,:)=a</VERB> est interprété comme <VERB>x(i,1:size(x,2))=a</VERB> 
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='*'> 
    <VERB>x(:,j)=a</VERB> est interprété comme <VERB>x(1:size(x,1),j)=a</VERB> 
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='*'> 
    <VERB>x(:)=a</VERB> renvoie dans <VERB>x</VERB> la matrice <VERB>a</VERB> remise en forme en accord avec les dimensions de x. <VERB>size(x,&apos;*&apos;)</VERB> doit être égal à<VERB>size(a,&apos;*&apos;)</VERB>
  </DESCRIPTION_ITEM>
 
  <P>
  </P>
  <P>
  </P>

  <DESCRIPTION_ITEM  label='-'> 
    vecteur de booléens. Si un indice (<VERB>i</VERB>  ou <VERB>j</VERB> ) est un vecteur de booléens, il est interprété comme <VERB>find(i)</VERB> ou <VERB>find(j)</VERB>, respectivement. 
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='-'> 
    un polynôme. Si un indice (<VERB>i</VERB>  ou <VERB>j</VERB> ) est un vecteur de polynômes ou de polynômes implicites, il est interprété comme <VERB>horner(i,m)</VERB> ou <VERB>horner(j,n)</VERB>, respectivement, où <VERB>m</VERB> et <VERB>n</VERB> sont les dimensions de <VERB>x</VERB> associées.  Même si cette fonctionnalité marche pour tous les polynômes, il est recommandé d&apos;utiliser des polynômes dans  <VERB>$</VERB> par souci de lisibilité.  
  </DESCRIPTION_ITEM>
 

  <DESCRIPTION_ITEM  label='CAS DES LISTES (types LIST et TLIST)'> 
    S&apos;ils sont présents les <VERB>ki</VERB> donnent le chemin vers un terme d&apos;une sous-liste de la liste <VERB>l</VERB>. Ils permettent de faire une insertion récursive directe sans utiliser de variable intermédiaire.   Les instructions <VERB>l(k1)...(kn)(i)=a</VERB> et <VERB>l(list(k1,...,kn,i)=a)</VERB> sont interprétées comme :  <VERB>lk1   = l(k1)</VERB>  <VERB> ..   = ..    </VERB>  <VERB>lkn   = lkn-1(kn)</VERB>  <VERB> lkn(i) = a</VERB>  <VERB>lkn-1(kn) = lkn</VERB>  <VERB> ..   = ..    </VERB>  <VERB>l(k1) = lk1</VERB>  et les instructions<VERB>l(k1)...(kn)(i,j)=a</VERB> et <VERB>l(list(k1,...,kn,list(i,j))=a</VERB> sont interprétées comme : <VERB>lk1   = l(k1)</VERB>  <VERB> ..   = ..    </VERB>  <VERB>lkn   = lkn-1(kn)</VERB>  <VERB>lkn(i,j) = a</VERB>  <VERB>lkn-1(kn) = lkn</VERB>  <VERB> ..   = ..    </VERB>  <VERB>l(k1) = lk1</VERB>
  </DESCRIPTION_ITEM>
 

  <DESCRIPTION_ITEM  label='i peut être :'> 
  </DESCRIPTION_ITEM>
 

  <DESCRIPTION_ITEM  label='-'> 
    un scalaire réel positif  <VERB>l(0)=a</VERB> ajoute un terme &quot;à gauche&quot; de la liste   <VERB>l(i)=a</VERB> affecte <VERB>a</VERB> au terme <VERB>i</VERB> de la liste <VERB>l</VERB>. Si <VERB>i&gt;size(l)</VERB>, <VERB>l</VERB> est préalablement agrandie et les termes créés sont de type non-défini.   <VERB>l(i)=null()</VERB> supprime le terme <VERB>i</VERB>th de la liste.
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='-'> 
    un polynôme. Si <VERB>i</VERB> est un vecteur de polynômes ou de polynômes implicites il est interprété comme <VERB>horner(i,m)</VERB> où <VERB>m=size(l)</VERB>. Même si cette fonctionnalité marche pour tous les polynômes, il est recommandé d&apos;utiliser des polynômes dans <VERB>$</VERB> par souci de lisibilité.  
  </DESCRIPTION_ITEM>
 
  <P>
    \un nombre réel positif 
  </P>
  <P>
  </P>

  <DESCRIPTION_ITEM  label='-'> 
    un polynôme, interprété comme <VERB>horner(ki,m)</VERB> ou <VERB>m</VERB> est la taille de la sous-liste correspondante. 
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='- une chaîne de caractères associée à un nom d&apos;entrée de sous-liste.'> 
  </DESCRIPTION_ITEM>
 
 
  </DESCRIPTION>
  <ITEMIZE label='REMARQUES'>
  <P>
    Pour les matrices rationnelles et les systèmes dynamiques linéaires stockés sous forme de représentation d&apos;état, la syntaxe <VERB>x(i)</VERB> ne doit pas être utilisée pour l&apos;insertion des éléments d&apos;un vecteur, à cause de la confusion possible avec l&apos;insertion des éléments de liste. La syntaxe <VERB>x(1,j)</VERB> où <VERB>x(i,1)</VERB> doit être utilisée dans ce cas. 
  </P>
  </ITEMIZE>
  <EXAMPLE><![CDATA[
// CAS DES MATRICES
a=[1 2 3;4 5 6]
a(1,2)=10
a([1 1],2)=[-1;-2]
a(:,1)=[8;5]
a(1,3:-1:1)=[77 44 99]
a(1)=%s
a(6)=%s+1
a(:)=1:6
a([%t %f],1)=33
a(1:2,$-1)=[2;4]
a($:-1:1,1)=[8;7]
a($)=123
//
x='test'
x([4 5])=['4','5']
//
b=[1/%s,(%s+1)/(%s-1)]
b(1,1)=0
b(1,$)=b(1,$)+1
b(2)=[1 2] // le numérateur
// CAS des LISTES (types LIST et TLIST)
l=list(1,'qwerw',%s)
l(1)='Changed'
l(0)='Added'
l(6)=['one more';'added']
//
//
dts=list(1,tlist(['x';'a';'b'],10,[2 3]));
dts(2)('a')=33
dts(2)('b')(1,2)=-100
 ]]></EXAMPLE>
  <SEE_ALSO>
    <SEE_ALSO_ITEM> <LINK>find</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>horner</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>parents</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>extraction</LINK> </SEE_ALSO_ITEM>
  </SEE_ALSO>
</MAN>
