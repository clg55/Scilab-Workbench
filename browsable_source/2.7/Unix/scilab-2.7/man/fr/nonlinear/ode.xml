<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?> 
<!DOCTYPE MAN SYSTEM "../../man.dtd">
<MAN>
  <LANGUAGE>fr</LANGUAGE>
  <TITLE>ode  </TITLE>
  <TYPE>Scilab Function  </TYPE>
  <DATE>February 1998  </DATE>
  <SHORT_DESCRIPTION name="ode"> solveur d&apos;équations différentielles ordinaires  </SHORT_DESCRIPTION>
  <CALLING_SEQUENCE>
  <CALLING_SEQUENCE_ITEM>y=ode(y0,t0,t,f)  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>[y,w,iw]=ode([type],y0,t0,t [,rtol [,atol]],f [,jac] [,w,iw])  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>[y,rd,w,iw]=ode(&quot;root&quot;,y0,t0,t [,rtol [,atol]],f  [,jac],ng,g [,w,iw])  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>y=ode(&quot;discrete&quot;,y0,k0,kvect,f)  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>
  <PARAM>
 <PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>y0  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : vecteur ou matrice réelle (conditions initiales).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>t0  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : réel (instant initial).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>t  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : vecteur réel (instants où la solution est renvoyée).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>f  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : fonction externe (fonction Scilab ou chaîne de caractères ou liste).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>type  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : une des chaînes de caractères : <VERB>&quot;adams&quot; &quot;stiff&quot; &quot;rk&quot; &quot;rkf&quot; &quot;fix&quot; &quot;discrete&quot; &quot;roots&quot;</VERB>
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>rtol,atol  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : constantes ou vecteurs réels de même taille que <VERB>y</VERB>.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>jac  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : fonction externe (fonction Scilab, chaîne de caractères ou liste).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>w,iw  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : vecteurs réels
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>ng  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : entier
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>g  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : fonction externe (fonction Scilab, chaîne de caractères ou liste).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>k0  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : entier (instant initial). kvect : vecteur d&apos;entiers
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 </PARAM_INDENT>
  </PARAM>
  <DESCRIPTION>
  <P>
    <VERB>ode</VERB> est la fonction utilisée pour approcher la solution d&apos;une équation différentielle ordinaire (EDO) explicite du premier ordre en temps, définie par :
  </P>
  <P>
     dy/dt=f(t,y) , y(t0)=y0.
  </P>
  <P>
    Il s&apos;agit d&apos;une interface vers diverses librairies, en particulier ODEPACK.
    Le type du problème et la méthode utilisée dépendent de la valeur du
    premier argument optionnel <VERB>type</VERB> qui peut être égal à :
  </P>
 

  <DESCRIPTION_ITEM  label='&lt;aucun&gt; :'> 
    le solveur <VERB>lsoda</VERB> du package ODEPACK est utilisé par défaut. Il choisit automatiquement entre un schéma prédicteur-correcteur d&apos;Adams et un schéma adapté au systèmes raides (stiff) de type &quot;Backward Differentiation Formula&quot; (BDF). Initialement le schéma adapté aux système non raides est choisi puis la méthode adaptée est ensuite choisie dynamiquement. 
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='&quot;adams&quot; :'> 
    Problèmes non raides. Le solveur <VERB>lsode</VERB> du package ODEPACK est utilisé (schéma d&apos;Adams).
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='&quot;stiff&quot; :'> 
    Pour les systèmes raides. Le solveur <VERB>lsode</VERB> du package ODEPACK est utilisé avec le schéma BDF.
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='&quot;rk&quot; :'> 
    Schéma de Runge-Kutta adaptatif d&apos;ordre 4 (RK4).
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='&quot;rkf&quot; :'> 
    Formules de Shampine et Watts basées sur les paires de Runge-Kutta Fehlberg d&apos;ordre 4 et 5 (RKF45). Bien pour les problèmes non raides ou moyennement raides, lorsque le calcul du second membre n&apos;est pas trop coûteux. Cette méthode est à éviter si l&apos;on recherche une très grande précision.
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='&quot;fix&quot;:'> 
    Identique à &quot;rkf&quot;, mais l&apos;interface est simplifiée, i.e. uniquement <VERB>rtol</VERB> et <VERB>atol</VERB>  sont communiqués au solveur. 
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='&quot;root&quot;:'> 
    Solveur d&apos;EDO avec recherche de racines.  Le solveur <VERB>lsodar</VERB> du package ODEPACK est utilisé. C&apos;est une variante de <VERB>lsoda</VERB> permettant la recherche d&apos;une racine d&apos;une fonction vectorielle donnée. Voir ode_root pour plus de détails.
  </DESCRIPTION_ITEM>

  <DESCRIPTION_ITEM  label='&quot;discrete&quot;:'> 
    Simulation en temps discret. Voir ode_discrete pour plus de détails.
  </DESCRIPTION_ITEM>
 
  <P>
    Ici on ne décrit l&apos;usage de <VERB>ode</VERB> que pour des EDO explicites.
  </P>
  <P>
    L&apos;appel le plus simple de <VERB>ode</VERB> est du type :
    <VERB>y=ode(y0,t0,t,f)</VERB>
    où <VERB>y0</VERB> est le vecteur des conditions initiales, <VERB>t0</VERB> est le temps initial, et <VERB>t</VERB> est le vecteur des instants où l&apos;on veut une approximation de la solution. 
    <VERB>y</VERB> est calculée et <VERB>y</VERB>  est la matrice 
    <VERB>y=[y(t(1)),y(t(2)),...]</VERB>.
  </P>
  <P>
    Le paramètre <VERB>f</VERB> de <VERB>ode</VERB> est par exemple une fonction Scilab, dont
    la syntaxe est imposée, ou le nom d&apos;une subroutine Fortran ou C 
    (chaîne de caractères) ou une liste.
  </P>
  <P>
    Si <VERB>f</VERB> est une fonction Scilab, sa syntaxe doit être :
  </P>
  <VERBATIM><![CDATA[
ydot = f(t,y)
   ]]></VERBATIM>
  <P>
    où <VERB>t</VERB> est un scalaire (le temps) et <VERB>y</VERB> un vecteur (l&apos;état).
    Cette fonction renvoie le second membre de l&apos;équation différentielle dy/dt=f(t,y).
  </P>
  <P>
    Si <VERB>f</VERB> est une chaîne de caractères, elle désigne le nom d&apos;une subroutine Fortran
    ou C, i.e. si <VERB>ode(y0,t0,t,&quot;fex&quot;)</VERB> est la
    commande, alors la subroutine <VERB>fex</VERB> est appelée. 
    Cette routine doit avoir la liste d&apos;appel suivante : 
    <VERB>f(n,t,y,ydot)</VERB>. La routine doit être liée dynamiquement à Scilab avec la fonction
    <VERB>link</VERB>. Voir les exemples dans les fichiers
    <VERB>SCIDIR/routines/default/README</VERB> et 
    <VERB>SCIDIR/routines/default/Ex-ode.f</VERB>.
  </P>
  <P>
    L&apos;argument <VERB>f</VERB> peut aussi être une liste :
    si <VERB>ode(y0,t0,t,lst)</VERB>
    est la commande, alors <VERB>lst</VERB> doit être une liste avec la structure suivante :
  </P>
  <VERBATIM><![CDATA[
lst=list(f,u1,u2,...un)
   ]]></VERBATIM>
  <P>
    où <VERB>f</VERB> est une fonction avec la syntaxe :
  </P>
  <VERBATIM><![CDATA[
ydot = f(t,y,u1,u2,...,un)
   ]]></VERBATIM>
  <P>
    cela permet de passer des paramètres sous forme d&apos;arguments supplémentaires de <VERB>f</VERB>.
  </P>
  <P>
    La fonction <VERB>f</VERB> peut renvoyer une matrice <VERB>p x q</VERB> au lieu d&apos;un vecteur. 
    Dans ce cas, on résout le système d&apos;EDO <VERB>n=p+q</VERB> 
    <VERB>dY/dt=F(t,Y)</VERB> où <VERB>Y</VERB> est une matrice <VERB>p x q</VERB>.
    La condition initiale <VERB>Y0</VERB> doit aussi être une matrice <VERB>p x q</VERB> matrix et le résultat renvoyé par <VERB>ode</VERB> est la matrice
    <VERB>p x q(T+1)</VERB> égale à <VERB>[Y(t_0),Y(t_1),...,Y(t_T)]</VERB>.
  </P>
  <P>
    Des paramètres optionnels contrôlent la tolérance du schéma :
    <VERB>rtol</VERB> et <VERB>atol</VERB> 
    sont des valeurs seuil sur les erreurs estimées (relative et absolue) 
    L&apos;erreur estimée sur <VERB>y(i)</VERB> est :
  </P>
  <VERBATIM><![CDATA[
rtol(i)*abs(y(i))+atol(i)
   ]]></VERBATIM>
  <P>
    Si <VERB>rtol</VERB> et/ou <VERB>atol</VERB> sont des constantes <VERB>rtol(i)</VERB> et/ou 
    <VERB>atol(i)</VERB> prennent ces valeurs. Les valeurs par défaut de <VERB>rtol</VERB> et <VERB>atol</VERB>
    sont respectivement <VERB>rtol=1.d-5</VERB> et <VERB>atol=1.d-7</VERB> pour la plupart des solveurs et <VERB>rtol=1.d-3</VERB> et <VERB>atol=1.d-4</VERB> pour <VERB>&quot;rfk&quot;</VERB> et <VERB>&quot;fix&quot;</VERB>.
  </P>
  <P>
    Pour les problèmes raides, il est recommandé de fournir la jacobienne du second membre
    sous forme de l&apos;argument optionnel <VERB>jac</VERB>. Le paramètre <VERB>jac</VERB> de <VERB>ode</VERB> est par exemple une fonction Scilab, dont la syntaxe est imposée, ou le nom d&apos;une subroutine Fortran ou C 
    (chaîne de caractères) ou une liste.
  </P>
  <P>
    Si <VERB>jac</VERB> est une fonction Scilab sa syntaxe doit être :
  </P>
  <VERBATIM><![CDATA[
J=jac(t,y)
   ]]></VERBATIM>
  <P>
    où <VERB>t</VERB> est un scalaire (le temps) et <VERB>y</VERB> un vecteur (l&apos;état).
    La matrice <VERB>J</VERB> doit renvoyer df/dx i.e. 
    <VERB>J(k,i) = dfk /dxi</VERB> avec <VERB>fk</VERB> = k-ième composante de f.
  </P>
  <P>
    Si <VERB>f</VERB> est une chaîne de caractères, elle désigne le nom d&apos;une subroutine Fortran
    ou C. Cette routine doit avoir la liste d&apos;appel suivante : 
    <VERB>jac(n,t,y,ml,mu,J,nrpd)</VERB>. Dans la plupart des cas il n&apos;est pas nécessaire d&apos;utiliser <VERB>ml</VERB>,
    <VERB>mu</VERB> et <VERB>nrpd</VERB> (voir les exemples dans 
    <VERB>SCIDIR/routines/default/Ex-ode.f</VERB>).
  </P>
  <P>
    Si <VERB>jac</VERB> est une liste, les mêmes conventions que pour <VERB>f</VERB> s&apos;appliquent.
  </P>
  <P>
    Les arguments optionnels <VERB>w</VERB> et <VERB>iw</VERB> sont 
    des vecteurs permettant de redémarrer l&apos;intégration au point où elle s&apos;était arrêtée à la sortie de ode.
  </P>
  <P>
    Plus d&apos;options peuvent être passées aux solveurs d&apos;ODEPACK en utilisant la variable
    <VERB>%ODEOPTIONS</VERB>. Voir le help de odeoptions.
  </P>
  </DESCRIPTION>
  <EXAMPLE><![CDATA[
// EDO à une dimension
// dy/dt=y^2-y sin(t)+cos(t), y(0)=0
deff("[ydot]=f(t,y)","ydot=y^2-y*sin(t)+cos(t)")
y0=0;t0=0;t=0:0.1:%pi;
y=ode(y0,t0,t,f)
plot(t,y)
// Simulation de dx/dt = A x(t) + B u(t) avec u(t)=sin(omega*t),
// x0=[1;0]
// la solution x(t) est désirée en t=0.1, 0.2, 0.5 ,1.
// A et u sont passées dans une liste 
// et B et omega sont des variables globales
deff("[xdot]=linear(t,x,A,u)","xdot=A*x+B*u(t)")
deff("[ut]=u(t)","ut=sin(omega*t)")
A=[1 1;0 2];B=[1;1];omega=5;
ode([1;0],0,[0.1,0.2,0.5,1],list(linear,A,u))
//
// EDO matricielle
// Equation différentielle de Ricatti
// Xdot=A'*X + X*A - X'*B*X + C , X(0)=Identité
// Solution en t=[1,2] 
deff("[Xdot]=ric(t,X)","Xdot=A''*X+X*A-X''*B*X+C")   
A=[1,1;0,2]; B=[1,0;0,1]; C=[1,0;0,1];
t0=0;t=0:0.1:%pi;
X=ode(eye(A),0,t,ric)
//
// Calcul de exp(A)
A=[1,1;0,2];
deff("[xdot]=f(t,x)","xdot=A*x");
ode(eye(A),0,1,f)
ode("adams",eye(A),0,1,f)
// EDO raide, avec la jacobienne fournie
A=[10,0;0,-1];
deff("[xdot]=f(t,x)","xdot=A*x");
deff("[J]=Jacobian(t,y)","J=A")
ode("stiff",[0;1],0,1,f,Jacobian)
 ]]></EXAMPLE>
  <SEE_ALSO>
    <SEE_ALSO_ITEM> <LINK>ode_discrete</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>ode_root</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>dassl</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>impl</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>odedc</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>odeoptions</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>csim</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>ltitr</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>rtitr</LINK> </SEE_ALSO_ITEM>
  </SEE_ALSO>
</MAN>
