<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?> 
<!DOCTYPE MAN SYSTEM "../../man.dtd">
<MAN>
  <LANGUAGE>eng</LANGUAGE>
  <TITLE>leastsq  </TITLE>
  <TYPE>Scilab Function  </TYPE>
  <DATE>April 1999  </DATE>
  <SHORT_DESCRIPTION name="leastsq"> 
    Solves non-linear least squaresproblems  
  </SHORT_DESCRIPTION>

  <CALLING_SEQUENCE>
  <CALLING_SEQUENCE_ITEM>[f,xopt]=leastsq([imp,] fun [,Dfun],x0)  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>[f,[xopt,[gradopt]]]=leastsq(fun [,Dfun],[contr],x0,[&apos;algo&apos;],[df0,[mem]],  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>     ,[stop],[&apos;in&apos;])  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>

  <PARAM>
  <PARAM_INDENT>

  <PARAM_ITEM>
  <PARAM_NAME>imp </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : scalar argument used to set the trace mode. <VERB>imp=0</VERB>
    nothing (execpt errors) is reported, <VERB>imp=1</VERB> initial
    and final reports, <VERB>imp=2</VERB> adds a report per iteration,
    <VERB>imp&gt;2</VERB> add reports on linear search. Warning, most
    of these reports are written on the Scilab standard output. 
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>fun </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : external, i.e Scilab function or string (<VERB>fun</VERB> is the
    function defining the least square probleme: see below.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>x0 </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : real vector (initial value of variable to be minimized).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>f  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : value of optimal least square value.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>xopt  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : best value of <VERB>x</VERB> found.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>contr  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : <VERB>&apos;b&apos;,binf,bsup</VERB>  with <VERB>binf</VERB> and
    <VERB>bsup</VERB> real vectors with same dimension as
    <VERB>x0</VERB>. <VERB>binf</VERB> and <VERB>bsup</VERB> are lower
    and upper bounds on <VERB>x</VERB>. 
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>algo  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : A string with possible values :<VERB>&apos;qn&apos;</VERB> or
    <VERB>&apos;gc&apos;</VERB> or <VERB>&apos;nd&apos;</VERB> . This
    string stands for quasi-Newton (default),  conjugate gradient or
    non-differentiable respectively.  Note that
    <VERB>&apos;nd&apos;</VERB> does not accept bounds on
    <VERB>x</VERB> ).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>df0  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : real scalar. Guessed decreasing of <VERB>f</VERB> at first
    iteration. (<VERB>df0=1</VERB> is the default value).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>mem   </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : integer, number of variables used to approximate the  Hessian,
    (<VERB>algo=&apos;gc&apos; or &apos;nd&apos;</VERB>). Default value
    is around 6. 
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>stop  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    :  sequence of optional parameters controlling the  convergence of
  the algorithm. <P></P>
  <VERB>  stop=  &apos;ar&apos;,nap, [iter [,epsg   [,epsf [,epsx]]]]</VERB> 

        <PARAM_INDENT>
        <PARAM_ITEM>
        <PARAM_NAME>&quot;ar&quot;  </PARAM_NAME>
        <PARAM_DESCRIPTION>
          : reserved keyword for stopping rule selection defined as follows:
        </PARAM_DESCRIPTION> 
        </PARAM_ITEM>

        <PARAM_ITEM>
        <PARAM_NAME>nap  </PARAM_NAME>
        <PARAM_DESCRIPTION>
          : maximum number of calls to <VERB>fun</VERB> allowed.
        </PARAM_DESCRIPTION> 
        </PARAM_ITEM>

        <PARAM_ITEM>
        <PARAM_NAME>iter  </PARAM_NAME>
        <PARAM_DESCRIPTION>
          : maximum number of iterations allowed.
        </PARAM_DESCRIPTION> 
        </PARAM_ITEM>

        <PARAM_ITEM>
        <PARAM_NAME>epsg  </PARAM_NAME>
        <PARAM_DESCRIPTION>
          : threshold on gradient norm.
        </PARAM_DESCRIPTION> 
        </PARAM_ITEM>

        <PARAM_ITEM>
        <PARAM_NAME>epsf  </PARAM_NAME>
        <PARAM_DESCRIPTION>
          : threshold controlling decreasing of <VERB>f</VERB>
        </PARAM_DESCRIPTION> 
        </PARAM_ITEM>

        <PARAM_ITEM>
        <PARAM_NAME>epsx  </PARAM_NAME>
        <PARAM_DESCRIPTION>
          : threshold controlling variation of <VERB>x</VERB>. This vector
        (possibly matrix) of same size as <VERB>x0</VERB> can be used to
        scale <VERB>x</VERB>. 
        </PARAM_DESCRIPTION> 
        </PARAM_ITEM>

        </PARAM_INDENT>
  </PARAM_DESCRIPTION>
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>&quot;in&quot;  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : reserved  keyword for initialization of parameters used when
  <VERB>fun</VERB> in given as a Fortran routine (see below). 
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  <PARAM_ITEM>
  <PARAM_NAME>gradopt  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    :  gradient of <VERB>fun</VERB> at <VERB>xopt</VERB>
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>

  </PARAM_INDENT>
  </PARAM>

  <DESCRIPTION>
    Non-linear optimization routine for programs without constraints or with bound constraints: 
   <P></P>
  <VERB>min sum(f(x)).^2</VERB>  w.r.t  <VERB>x</VERB>, 
   Here, <VERB>f</VERB> is a function from R^n to R^m which returns <VERB>f(x)</VERB>, a
    real vector ( value of function at <VERB>x</VERB>). 

  <DESCRIPTION_ITEM  label='fun'> 
    gives the definition of the function <VERB>f(x)</VERB>. It
    is an &quot;external&quot; i.e function, or list or C or Fortran
    routine (see &quot;external&quot;). 
    <P></P>
    This external must return a vector <VERB>y</VERB> such as
    (<VERB>y(j)=f(x)</VERB>) for a given <VERB>x</VERB>.
    <DESCRIPTION_INDENT>

        <DESCRIPTION_ITEM  label='If'> 
          <VERB>fun</VERB> is a Scilab function, the calling sequence for <VERB>fun</VERB> must be:
          <P></P>
          <VERB>y=fun(x, [optional parameters])</VERB>
        </DESCRIPTION_ITEM >

        <DESCRIPTION_ITEM  label='If'> 
        <VERB>fun</VERB>  is defined by a Fortran or C routine first argument must be a
        list:<P></P>
        <VERB> list(fun_name,m,p1,..pl)</VERB>
         <P></P>
        <VERB>fun_name</VERB> is then a character string, it refers to the name of the routine
        which must be linked to Scilab. 
        Here, the generic calling sequences are: 
       <P></P>
        In Fortran
        <VERBATIM><![CDATA[
          subroutine fun(n,m,x,td,y)
          integer n,m
          double precision x(n), td(*), y(m)
         ]]></VERBATIM>
        <P></P>
        In C
       <VERBATIM><![CDATA[
          void fun(int *n,int *m, double *x,double *params, double *y)
       ]]></VERBATIM>
       <P></P>
        <VERB>n</VERB> is the dimension of vector <VERB>x</VERB> ,
        <VERB>m</VERB> is the dimension of vector<VERB>y</VERB>,  
        <VERB>td</VERB> is a vector which contains the parameters <VERB>p1,..pl</VERB>
        </DESCRIPTION_ITEM> 

   </DESCRIPTION_INDENT>
   </DESCRIPTION_ITEM> 

   <DESCRIPTION_ITEM  label='Dfun'> 
     Gives the definition of the function <VERB>df(x)/dx</VERB>. It is
     an &quot;external&quot;.This external must return a matrix
     <VERB>g</VERB> such  as (<VERB>g(i,j)=dfi/dxj</VERB>) for a given
     <VERB>x</VERB>.  
    <DESCRIPTION_INDENT>

        <DESCRIPTION_ITEM  label='If'> 
          <VERB>Dfun</VERB> is a function, the calling sequence for <VERB>fun</VERB> must be:<P></P>
          <VERB>g=Dfun(x, [optional parameters])</VERB> .
        </DESCRIPTION_ITEM> 

        <DESCRIPTION_ITEM  label='If'> 
           <VERB>Dfun</VERB> is defined by a Fortran or C routine first argument must be a
           list:<P></P>
           <VERB>list(fun_name,m,...)</VERB> 
           <VERB>fun_name</VERB> is a character string, it refers to the name of the routine
            which must be linked to Scilab. This function has the same calling
            sequence as  <VERB>fun</VERB>
         </DESCRIPTION_ITEM > 

   </DESCRIPTION_INDENT>
   </DESCRIPTION_ITEM> 

  </DESCRIPTION>

  <EXAMPLE><![CDATA[
a=rand(3,2);b=[1;1;1];x0=[1;-1];
deff('f=fun(x,a,b)','f=a*x-b');
deff('g=dfun(x,a,b)','g=a');

[f,xopt]=leastsq(fun,x0)      //Simplest call
xopt-a\b  //compare with linear algebra solution

[f,xopt]=leastsq(fun,dfun,x0)      //specify gradient

[f,xopt]=leastsq(list(fun,[1 2;3 4],[1;2]),x0)    

deff('f=fun(x,a,b)','f=exp(a*x)-b');
deff('g=dfun(x,a,b)','g=a.*(exp(a*x)*ones(1,size(a,2)))');

[f,xopt]=leastsq(list(fun,[1 2;3 4],[1;2]),x0)  
   ]]>
  </EXAMPLE>

  <SEE_ALSO>
    <SEE_ALSO_ITEM> <LINK>external</LINK> </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM> <LINK>quapro</LINK> </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM> <LINK>linpro</LINK> </SEE_ALSO_ITEM> 
  </SEE_ALSO>
</MAN>
