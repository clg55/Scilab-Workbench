<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>leastsq</title></head><body bgcolor="FFFFFF"><CENTER>Scilab Function  </CENTER><p><b>leastsq -  
    Solves non-linear least squaresproblems  
  </b></p><H3><font color="blue">Sequence d'appel</font></H3><dl><dd><tt>[f,xopt]=leastsq([imp,] fun [,Dfun],x0)  </tt></dd><dd><tt>[f,[xopt,[gradopt]]]=leastsq(fun [,Dfun],[contr],x0,['algo'],[df0,[mem]],  </tt></dd><dd><tt>     ,[stop],['in'])  </tt></dd></dl><H3><font color="blue">Parametres</font></H3><ul><ul>

  <li><tt><b>imp </b></tt>
    : scalar argument used to set the trace mode. <tt><b>imp=0</b></tt>
    nothing (execpt errors) is reported, <tt><b>imp=1</b></tt> initial
    and final reports, <tt><b>imp=2</b></tt> adds a report per iteration,
    <tt><b>imp&gt;2</b></tt> add reports on linear search. Warning, most
    of these reports are written on the Scilab standard output. 
  </li>

  <li><tt><b>fun </b></tt>
    : external, i.e Scilab function or string (<tt><b>fun</b></tt> is the
    function defining the least square probleme: see below.
  </li>

  <li><tt><b>x0 </b></tt>
    : real vector (initial value of variable to be minimized).
  </li>

  <li><tt><b>f  </b></tt>
    : value of optimal least square value.
  </li>

  <li><tt><b>xopt  </b></tt>
    : best value of <tt><b>x</b></tt> found.
  </li>

  <li><tt><b>contr  </b></tt>
    : <tt><b>'b',binf,bsup</b></tt>  with <tt><b>binf</b></tt> and
    <tt><b>bsup</b></tt> real vectors with same dimension as
    <tt><b>x0</b></tt>. <tt><b>binf</b></tt> and <tt><b>bsup</b></tt> are lower
    and upper bounds on <tt><b>x</b></tt>. 
  </li>

  <li><tt><b>algo  </b></tt>
    : A string with possible values :<tt><b>'qn'</b></tt> or
    <tt><b>'gc'</b></tt> or <tt><b>'nd'</b></tt> . This
    string stands for quasi-Newton (default),  conjugate gradient or
    non-differentiable respectively.  Note that
    <tt><b>'nd'</b></tt> does not accept bounds on
    <tt><b>x</b></tt> ).
  </li>

  <li><tt><b>df0  </b></tt>
    : real scalar. Guessed decreasing of <tt><b>f</b></tt> at first
    iteration. (<tt><b>df0=1</b></tt> is the default value).
  </li>

  <li><tt><b>mem   </b></tt>
    : integer, number of variables used to approximate the  Hessian,
    (<tt><b>algo='gc' or 'nd'</b></tt>). Default value
    is around 6. 
  </li>

  <li><tt><b>stop  </b></tt>
    :  sequence of optional parameters controlling the  convergence of
  the algorithm. <p></p>
  <tt><b>  stop=  'ar',nap, [iter [,epsg   [,epsf [,epsx]]]]</b></tt> 

        <ul>
        <li><tt><b>"ar"  </b></tt>
          : reserved keyword for stopping rule selection defined as follows:
        </li>

        <li><tt><b>nap  </b></tt>
          : maximum number of calls to <tt><b>fun</b></tt> allowed.
        </li>

        <li><tt><b>iter  </b></tt>
          : maximum number of iterations allowed.
        </li>

        <li><tt><b>epsg  </b></tt>
          : threshold on gradient norm.
        </li>

        <li><tt><b>epsf  </b></tt>
          : threshold controlling decreasing of <tt><b>f</b></tt>
        </li>

        <li><tt><b>epsx  </b></tt>
          : threshold controlling variation of <tt><b>x</b></tt>. This vector
        (possibly matrix) of same size as <tt><b>x0</b></tt> can be used to
        scale <tt><b>x</b></tt>. 
        </li>

        </ul>
  </li>

  <li><tt><b>"in"  </b></tt>
    : reserved  keyword for initialization of parameters used when
  <tt><b>fun</b></tt> in given as a Fortran routine (see below). 
  </li>

  <li><tt><b>gradopt  </b></tt>
    :  gradient of <tt><b>fun</b></tt> at <tt><b>xopt</b></tt>
  </li>

  </ul></ul><H3><font color="blue">Description</font></H3><dl>
    Non-linear optimization routine for programs without constraints or with bound constraints: 
   <p></p>
  <tt><b>min sum(f(x)).^2</b></tt>  w.r.t  <tt><b>x</b></tt>, 
   Here, <tt><b>f</b></tt> is a function from R^n to R^m which returns <tt><b>f(x)</b></tt>, a
    real vector ( value of function at <tt><b>x</b></tt>). 

  <li><b>fun</b> 
    gives the definition of the function <tt><b>f(x)</b></tt>. It
    is an "external" i.e function, or list or C or Fortran
    routine (see "external"). 
    <p></p>
    This external must return a vector <tt><b>y</b></tt> such as
    (<tt><b>y(j)=f(x)</b></tt>) for a given <tt><b>x</b></tt>.
    

        <li><b>If</b> 
          <tt><b>fun</b></tt> is a Scilab function, the calling sequence for <tt><b>fun</b></tt> must be:
          <p></p>
          <tt><b>y=fun(x, [optional parameters])</b></tt>
        </li>

        <li><b>If</b> 
        <tt><b>fun</b></tt>  is defined by a Fortran or C routine first argument must be a
        list:<p></p>
        <tt><b> list(fun_name,m,p1,..pl)</b></tt>
         <p></p>
        <tt><b>fun_name</b></tt> is then a character string, it refers to the name of the routine
        which must be linked to Scilab. 
        Here, the generic calling sequences are: 
       <p></p>
        In Fortran
        <pre>
          subroutine fun(n,m,x,td,y)
          integer n,m
          double precision x(n), td(*), y(m)
         </pre>
        <p></p>
        In C
       <pre>
          void fun(int *n,int *m, double *x,double *params, double *y)
       </pre>
       <p></p>
        <tt><b>n</b></tt> is the dimension of vector <tt><b>x</b></tt> ,
        <tt><b>m</b></tt> is the dimension of vector<tt><b>y</b></tt>,  
        <tt><b>td</b></tt> is a vector which contains the parameters <tt><b>p1,..pl</b></tt>
        </li> 

   
   </li> 

   <li><b>Dfun</b> 
     Gives the definition of the function <tt><b>df(x)/dx</b></tt>. It is
     an "external".This external must return a matrix
     <tt><b>g</b></tt> such  as (<tt><b>g(i,j)=dfi/dxj</b></tt>) for a given
     <tt><b>x</b></tt>.  
    

        <li><b>If</b> 
          <tt><b>Dfun</b></tt> is a function, the calling sequence for <tt><b>fun</b></tt> must be:<p></p>
          <tt><b>g=Dfun(x, [optional parameters])</b></tt> .
        </li> 

        <li><b>If</b> 
           <tt><b>Dfun</b></tt> is defined by a Fortran or C routine first argument must be a
           list:<p></p>
           <tt><b>list(fun_name,m,...)</b></tt> 
           <tt><b>fun_name</b></tt> is a character string, it refers to the name of the routine
            which must be linked to Scilab. This function has the same calling
            sequence as  <tt><b>fun</b></tt>
         </li> 

   
   </li> 

  </dl><H3><font color="blue">Exemples</font></H3><ul><pre>
a=rand(3,2);b=[1;1;1];x0=[1;-1];
deff('f=fun(x,a,b)','f=a*x-b');
deff('g=dfun(x,a,b)','g=a');

[f,xopt]=leastsq(fun,x0)      //Simplest call
xopt-a\b  //compare with linear algebra solution

[f,xopt]=leastsq(fun,dfun,x0)      //specify gradient

[f,xopt]=leastsq(list(fun,[1 2;3 4],[1;2]),x0)    

deff('f=fun(x,a,b)','f=exp(a*x)-b');
deff('g=dfun(x,a,b)','g=a.*(exp(a*x)*ones(1,size(a,2)))');

[f,xopt]=leastsq(list(fun,[1 2;3 4],[1;2]),x0)  
   
  </pre></ul><H3><font color="blue">Voir aussi</font></H3><p><ul><a href="../programming/external.htm"><tt><b>external</b></tt></a>&nbsp;&nbsp;<a href="quapro.htm"><tt><b>quapro</b></tt></a>&nbsp;&nbsp;<a href="linpro.htm"><tt><b>linpro</b></tt></a>&nbsp;&nbsp;</ul></p></body></html>
