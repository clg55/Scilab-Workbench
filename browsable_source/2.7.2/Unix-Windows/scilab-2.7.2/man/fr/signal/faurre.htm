<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>faurre</title></head><body bgcolor="FFFFFF"><CENTER>Scilab Function  </CENTER><p><b>faurre -  filter computation by simple Faurre algorithm  </b></p><H3><font color="blue">Sequence d'appel</font></H3><dl><dd><tt>[P,R,T]=faurre(n,H,F,G,R0)  </tt></dd></dl><H3><font color="blue">Parametres</font></H3><ul><ul>
  <li><tt><b>n  </b></tt>
    : number of iterations.
  </li>
  <li><tt><b>H, F, G  </b></tt>
    : estimated triple from the covariance sequence of <tt><b>y</b></tt>.
  </li>
  <li><tt><b>R0  </b></tt>
    : E(yk*yk')
  </li>
  <li><tt><b>P  </b></tt>
    : solution of the Riccati equation after n iterations.
  </li>
  <li><tt><b>R, T  </b></tt>
    : gain matrix of the filter.
  </li>
 </ul></ul><H3><font color="blue">Description</font></H3><dl>
  <p>
    This function computes iteratively the minimal solution of the algebraic
    Riccati equation and gives the matrices <tt><b>R</b></tt> and <tt><b>T</b></tt> of the 
    filter model.
    The algorithm tries to compute the solution P as the growing limit of a
    sequence of matrices Pn such that
  </p>
  <pre>
                                     -1
Pn+1=F*Pn*F'+(G-F*Pn*h')*(R0-H*Pn*H')  *(G'-H*Pn*F')
       -1
P0=G*R0 *G'
   </pre>
  <p>
    Note that this method may not converge,especially when F has poles
    near the unit circle. Use preferably the srfaur function.
  </p>
  </dl><H3><font color="blue">Voir aussi</font></H3><p><ul><a href="srfaur.htm"><tt><b>srfaur</b></tt></a>&nbsp;&nbsp;<a href="lindquist.htm"><tt><b>lindquist</b></tt></a>&nbsp;&nbsp;<a href="phc.htm"><tt><b>phc</b></tt></a>&nbsp;&nbsp;</ul></p><H3><font color="blue">Auteur</font></H3><p><ul>G. Le V.  </ul></p></body></html>
