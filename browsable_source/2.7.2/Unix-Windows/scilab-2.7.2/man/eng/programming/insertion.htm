<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>insertion</title></head><body bgcolor="FFFFFF"><CENTER>Scilab Function  </CENTER><p><b>insertion -  matrix and list insertion or modification  </b></p><H3><font color="blue">Calling Sequence</font></H3><dl><dd><tt>x(i,j)=a  </tt></dd><dd><tt>x(i)=a  </tt></dd><dd><tt>l(i)=a  </tt></dd><dd><tt>l(k1)...(kn)(i)=a or l(list(k1,...,kn,i))=a  </tt></dd><dd><tt>l(k1)...(kn)(i,j)=a   or l(list(k1,...,kn,list(i,j))=a  </tt></dd></dl><H3><font color="blue">Parameters</font></H3><ul><ul>
  <li><tt><b>x  </b></tt>
    : matrix  of any  kind (constant, sparse, polynomial,...)
  </li>
  <li><tt><b>l  </b></tt>
    : list 
  </li>
  <li><tt><b>i,j  </b></tt>
    : indices
  </li>
  <li><tt><b>k1,...kn  </b></tt>
    : indices  with integer value
  </li>
  <li><tt><b>a  </b></tt>
    : new entry value
  </li>
 </ul></ul><H3><font color="blue">Description</font></H3><dl>
 

  <li><b>MATRIX CASE</b> 
      <tt><b>i</b></tt> and <tt><b>j</b></tt>, may be:
  </li>
 

  <li><b>-</b> 
    real scalars or vectors or matrices with positive elements. 
  </li>
 

  <li><b>*</b> 
    if <tt><b>a</b></tt> is a matrix with dimensions <tt><b>(size(i,'*'),size(j,'*'))</b></tt> <tt><b>x(i,j)=a</b></tt> returns a new <tt><b>x</b></tt> matrix such as <tt><b>x(int(i(l)),int(j(k)))=a(l,k) </b></tt> for  <tt><b>l</b></tt> from 1 to <tt><b>size(i,'*')</b></tt> and <tt><b>k</b></tt> from 1 to <tt><b>size(j,'*')</b></tt>, other initial entries of <tt><b>x</b></tt> are unchanged. 
  </li>
  <p>
    if <tt><b>a</b></tt> is a scalar  <tt><b>x(i,j)=a</b></tt> returns a new <tt><b>x</b></tt> matrix such as
    <tt><b>x(int(i(l)),int(j(k)))=a </b></tt> for  <tt><b>l</b></tt> from 1 to <tt><b>size(i,'*')</b></tt> and
    <tt><b>k</b></tt> from 1 to <tt><b>size(j,'*')</b></tt>, other initial entries of <tt><b>x</b></tt>
    are unchanged. 
  </p>
  <p>
    If <tt><b>i</b></tt> or  <tt><b>j</b></tt> maximum value exceed corresponding <tt><b>x</b></tt>
    matrix dimension <tt><b>x</b></tt> is previously extended to the required
    dimensions with zeros entries for standard matrices, 0 length character
    string for string matrices and false values for boolean matrices.
  </p>
  <p>
  </p>

  <li><b>*</b> 
    <tt><b>x(i,j)=[]</b></tt> kills rows specified by <tt><b>i</b></tt> if <tt><b>j</b></tt> matches all columns of <tt><b>x</b></tt> or kills columns specified by <tt><b>j</b></tt> if <tt><b>i</b></tt> matches all rows of <tt><b>x</b></tt>. In other cases <tt><b>x(i,j)=[]</b></tt> produce an error.
  </li>

  <li><b>*</b> 
    <tt><b>x(i)=a</b></tt>  with <tt><b>a</b></tt> a vector returns a new <tt><b>x</b></tt> matrix such as <tt><b>x(int(i(l)))=a(l)</b></tt> for  <tt><b>l</b></tt> from 1 to <tt><b>size(i,'*')</b></tt> , other initial entries of <tt><b>x</b></tt> are unchanged.
  </li>
  <p>
    <tt><b>x(i)=a</b></tt>  with <tt><b>a</b></tt> a scalar returns a new <tt><b>x</b></tt> matrix such as
    <tt><b>x(int(i(l)))=a</b></tt> for  <tt><b>l</b></tt> from 1 to <tt><b>size(i,'*')</b></tt> ,
    other initial entries of <tt><b>x</b></tt> are unchanged.
  </p>
  <p>
    If <tt><b>i</b></tt> maximum value exceed  <tt><b>size(x,1)</b></tt>, <tt><b>x</b></tt> is
    previously extended to the required dimension with zeros entries for
    standard matrices, 0 length character string for string matrices and
    false values for boolean matrices. 
  </p>
  <p>
  </p>
 

  <li><b>if</b> 
    <tt><b>x</b></tt> is a 1x1 matrix <tt><b>a</b></tt> may be a row (respectively a column)  vector with  dimension <tt><b>size(i,'*')</b></tt>. Resulting <tt><b>x</b></tt> matrix is a row (respectively a column) vector
  </li>

  <li><b>if</b> 
    <tt><b>x</b></tt> is a row vector <tt><b>a</b></tt> must be a row vector with  dimension  <tt><b>size(i,'*')</b></tt>
  </li>

  <li><b>if</b> 
    <tt><b>x</b></tt> is a column vector <tt><b>a</b></tt> must be a column vector with  dimension  <tt><b>size(i,'*')</b></tt>
  </li>

  <li><b>if</b> 
    <tt><b>x</b></tt> is a general matrix <tt><b>a</b></tt> must be a row or column vector with  dimension <tt><b>size(i,'*')</b></tt> and <tt><b>i</b></tt> maximum value cannot exceed <tt><b>size(x,'*')</b></tt>,
  </li>
 

  <li><b>*</b> 
    <tt><b>x(i)=[]</b></tt> kills entries specified by <tt><b>i</b></tt>.
  </li>
 
  <p>
    -
    the <tt><b>:</b></tt> symbol which stands for "all elements". 
  </p>
 

  <li><b>*</b> 
    <tt><b>x(i,:)=a</b></tt> is interpreted as <tt><b>x(i,1:size(x,2))=a</b></tt> 
  </li>

  <li><b>*</b> 
    <tt><b>x(:,j)=a</b></tt> is interpreted as <tt><b>x(1:size(x,1),j)=a</b></tt> 
  </li>

  <li><b>*</b> 
    <tt><b>x(:)=a</b></tt> returns in <tt><b>x</b></tt> the  <tt><b>a</b></tt> matrix reshaped according to x dimensions. <tt><b>size(x,'*')</b></tt> must be equal to <tt><b>size(a,'*')</b></tt>
  </li>
 
  <p>
  </p>
  <p>
  </p>

  <li><b>-</b> 
    vector of boolean. If an index (<tt><b>i</b></tt>  or <tt><b>j</b></tt> )is a vector of booleans it is interpreted as <tt><b>find(i)</b></tt> or respectively  <tt><b>find(j)</b></tt> 
  </li>

  <li><b>-</b> 
    a polynomial.  If an index (<tt><b>i</b></tt>  or <tt><b>j</b></tt> )is a vector of polynomials or implicit polynomial vector it is interpreted as <tt><b>horner(i,m)</b></tt> or respectively  <tt><b>horner(j,n)</b></tt> where <tt><b>m</b></tt> and <tt><b>n</b></tt> are associated <tt><b>x</b></tt> dimensions.  Even if this feature works for all polynomials, it is recommended to use polynomials in <tt><b>$</b></tt> for readability.  
  </li>
 

  <li><b>LIST OR TLIST CASE</b> 
    If they are present the <tt><b>ki</b></tt> give the path to a sub-list entry of <tt><b>l</b></tt> data structure. They allow a recursive insertion without intermediate copies.  The  <tt><b>l(k1)...(kn)(i)=a</b></tt> and  <tt><b>l(list(k1,...,kn,i)=a)</b></tt> instructions are interpreted as:  <tt><b>lk1   = l(k1)</b></tt>  <tt><b> ..   = ..    </b></tt>  <tt><b>lkn   = lkn-1(kn)</b></tt>  <tt><b> lkn(i) = a</b></tt>  <tt><b>lkn-1(kn) = lkn</b></tt>  <tt><b> ..   = ..    </b></tt>  <tt><b>l(k1) = lk1</b></tt>  And the  <tt><b>l(k1)...(kn)(i,j)=a</b></tt> and <tt><b>l(list(k1,...,kn,list(i,j))=a</b></tt> instructions are  interpreted as:  <tt><b>lk1   = l(k1)</b></tt>  <tt><b> ..   = ..    </b></tt>  <tt><b>lkn   = lkn-1(kn)</b></tt>  <tt><b>lkn(i,j) = a</b></tt>  <tt><b>lkn-1(kn) = lkn</b></tt>  <tt><b> ..   = ..    </b></tt>  <tt><b>l(k1) = lk1</b></tt>
  </li>
 

  <li><b>i may be :</b> 
  </li>
 

  <li><b>-</b> 
    a real non negative scalar.  <tt><b>l(0)=a</b></tt> adds an entry on the "left" of the list   <tt><b>l(i)=a</b></tt> sets the <tt><b>i</b></tt> entry of the list <tt><b>l</b></tt> to <tt><b>a</b></tt>. if <tt><b>i&gt;size(l)</b></tt>, <tt><b>l</b></tt> is previously extended with zero length entries (undefined).   <tt><b>l(i)=null()</b></tt> suppress the <tt><b>i</b></tt>th list entry.
  </li>

  <li><b>-</b> 
    a polynomial.  If <tt><b>i</b></tt>  is a  polynomial  it is interpreted as <tt><b>horner(i,m)</b></tt> where <tt><b>m=size(l)</b></tt>.  Even if this feature works for all polynomials, it is recommended to use polynomials in <tt><b>$</b></tt> for readability.  
  </li>
 
  <p>
    <tt><b>k1,..kn</b></tt> may be :
  </p>
  <p>
  </p>

  <li><b>-</b> 
    real positive scalar.  
  </li>

  <li><b>-</b> 
    a polynomial,interpreted as <tt><b>horner(ki,m)</b></tt> where <tt><b>m</b></tt> is the corresponding sub-list size. 
  </li>

  <li><b>- a character string associated with a sub-list entry name.</b> 
  </li>
 
 
  </dl><H3><font color="blue">REMARKS</font></H3><ul><p>
    For soft coded matrix types such as rational functions and state space linear systems, <tt><b>x(i)</b></tt> syntax may not be used for vector entry insertion due to confusion with list entry insertion. <tt><b>x(1,j)</b></tt> or <tt><b>x(i,1)</b></tt> syntax must be used. 
  </p></ul><H3><font color="blue">Examples</font></H3><ul><pre>
// MATRIX CASE
a=[1 2 3;4 5 6]
a(1,2)=10
a([1 1],2)=[-1;-2]
a(:,1)=[8;5]
a(1,3:-1:1)=[77 44 99]
a(1)=%s
a(6)=%s+1
a(:)=1:6
a([%t %f],1)=33
a(1:2,$-1)=[2;4]
a($:-1:1,1)=[8;7]
a($)=123
//
x='test'
x([4 5])=['4','5']
//
b=[1/%s,(%s+1)/(%s-1)]
b(1,1)=0
b(1,$)=b(1,$)+1
b(2)=[1 2] // the numerator
// LIST OR TLIST CASE
l=list(1,'qwerw',%s)
l(1)='Changed'
l(0)='Added'
l(6)=['one more';'added']
//
//
dts=list(1,tlist(['x';'a';'b'],10,[2 3]));
dts(2)('a')=33
dts(2)('b')(1,2)=-100
 </pre></ul><H3><font color="blue">See Also</font></H3><p><ul><a href="find.htm"><tt><b>find</b></tt></a>&nbsp;&nbsp;<a href="../polynomials/horner.htm"><tt><b>horner</b></tt></a>&nbsp;&nbsp;<a href="parents.htm"><tt><b>parents</b></tt></a>&nbsp;&nbsp;<a href="extraction.htm"><tt><b>extraction</b></tt></a>&nbsp;&nbsp;</ul></p></body></html>
