cvs server: programming/date.man no longer exists, no comparison available
cvs server: programming/getdate.man no longer exists, no comparison available
cvs server: pvm/Example.man no longer exists, no comparison available
cvs server: signal/sinc.man no longer exists, no comparison available
cvs server: utilities/timer.man no longer exists, no comparison available


======================================================================
Index: control/contr.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/control/contr.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
2d1
< .so ../sci.an 
4c3
< contr - controllability, controllable subspace
---
> contr - controllability, controllable subspace, staircase
7,8c6,8
< [n [,U]]=contr(A,B [,tol]) 
< [A1,B1,U,ind]=contr(A,B [,tol])
---
> n=contr(A,B [,tol]) 
> [n,U]=contr(A,B [,tol]) 
> [n,U,ind,V,Ac,Bc]=contr(A,B,[,tol]) 
16,22c16
< : may be the constant rtol or the 2 vector \fV[rtol atol]\fR
< .TP 10
< rtol
< :tolerance used when evaluating ranks (QR factorizations).
< .TP
< atol
< :absolute tolerance (the \fVB\fR matrix is assumed to be 0 if \fVnorm(B)<atol\fR)
---
> : tolerance parameter
30,31c24,28
< A1 
< : block Hessenberg matrix
---
> V
> : orthogonal matrix, change of basis in the control space.
> .TP
> Ac 
> : block Hessenberg matrix \fVAc=U'*A*V\fR
33,34c30,31
< B1 
< : is \fVU'*B\fR.
---
> Bc 
> : is \fVU'*B*V\fR.
37,38c34,35
< : vector associated with controllability indices (dimensions of subspaces \fVB,
< B+A*B,...=ind(1),ind(1)+ind(2),...\fR)
---
> : p integer vector associated with controllability indices 
> (dimensions of subspaces \fVB, B+A*B,...=ind(1),ind(1)+ind(2),...\fR)
48,49c45,60
< \fV[A1,B1,U,ind]=contr(A,B)\fR returns the Hessenberg controllable
< form of \fV(A,B)\fR. 
---
> The pair \fV(Bc, Ac)\fR is in staircase controllable form.
> .nf
>                         |B |sI-A      *  . . .  *      *       |
>                         | 1|    11       .      .      .       |
>                         |  |  A    sI-A    .    .      .       |
>                         |  |   21      22    .  .      .       |
>                         |  |        .     .     *      *       |
>      [U'BV|sI - U'AU] = |0 |     0    .     .                  |
>                         |  |            A     sI-A     *       |
>                         |  |             p,p-1    pp           |
>                         |  |                                   |
>                         |0 |         0          0   sI-A       |
>                         |  |                            p+1,p+1|
> .fi
> .SH REFERENCE
> Slicot library (see ab01od in SCIDIR/routines/slicot).
60c71,73
< canon, cont_mat, unobs, stabil
---
> canon, cont_mat, unobs, stabil, st_ility
> 
> 
======================================================================
Index: control/ricc.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/control/ricc.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
63c63
< [T,d]=gschur(eye(H),H,'cont');T=T(:,1:d);
---
> [T,d]=schur(eye(H),H,'cont');T=T(:,1:d);
75c75
< [T,d]=gschur(H2,H1,'disc');T=T(:,1:d);X1=T(4:6,:)/T(1:3,:);
---
> [T,d]=schur(H2,H1,'disc');T=T(:,1:d);X1=T(4:6,:)/T(1:3,:);
======================================================================
Index: control/ss2tf.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/control/ss2tf.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
8a9,17
> 
> [h]=ss2tf(sl,"b") 
> [Ds,NUM,chi]=ss2tf(sl,"b")
> 
> 
> [h]=ss2tf(sl,rmax) 
> [Ds,NUM,chi]=ss2tf(sl,rmax)
> 
> 
29a39,43
> .PP
> With \fVrmax\fR or \fV"b"\fR argument uses a block diagonalization of
> sl.A matrix and applies "Leverrier" algorithm on blocks.
> If given, \fVrmax\fR controls the conditionning (see bdiag).
> 
======================================================================
Index: dcd/grand.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/dcd/grand.man,v
retrieving revision 1.1
retrieving revision 1.7
diff -r1.1 -r1.7
4c4
< grand - Random number generator 
---
> grand - Random number generator(s) 
12,16c12
< .SH PARAMETERS
< .TP
< grand('advnst',K) 
< : Advances the state of the current generator by 2^K values and 
< resets the initial seed to that value. 
---
> .SH PARAMETERS#1 (generating randoms numbers following a given law)
21,26c17,18
< \fVx^(a-1) * (1-x)^(b-1) / B(a,b)\fR for \fV0 < x < 1\fR
< 
< Method: R. C. H. Cheng 
< Generating Beta Variables with Nonintegral Shape Parameters 
< Communications of the ACM, 21:317-322 (1978) 
< (Algorithms BB and BC)
---
> \fVx^(a-1) * (1-x)^(b-1) / B(a,b)\fR for \fV0 < x < 1\fR. 
> For details see [1].
35,38c27
< (0.0 <= P <= 1.0)
< 
< Method: This is algorithm BTPE from:  Kachitvichyanukul, V. and Schmeiser, B. W. Binomial Random Variate Generation. Communications of the ACM, 31, 2 
< (February, 1988) 216. 
---
> (0.0 <= P <= 1.0). For details see [2].
48,49c37
< over 0 - 1 (endpoints of this interval are not returned) using the 
< current generator
---
> over [0,1) (1 is never returned) using the current generator
53,57c41
< distribution with mean AV.  For details see: 
<  Ahrens, J.H. and Dieter, U.
<  Computer Methods for Sampling From the 
<  Exponential and Normal Distributions.
<  Comm. ACM, 15,10 (Oct. 1972), 873 - 882. 
---
> distribution with mean AV.  For details see [3].
68,101c52
< For details see: 
< .RS
< .TP
< (Case R >= 1.0) 
< : Ahrens, J.H. and Dieter, U.
<  Generating Gamma Variates by a 
<  Modified Rejection Technique. 
<  Comm. ACM, 25,1 (Jan. 1982), 47 - 54.
<  Algorithm GD
< .TP
< (Case 0.0 < R < 1.0)
< : Ahrens, J.H. and Dieter, U.
<  Computer Methods for Sampling from Gamma, 
<  Beta, Poisson and Binomial Distributions. 
<  Computing, 12 (1974), 223-246/ 
<  Adapted algorithm GS.
< .RE
< .TP
< G=grand('getcgn')
< : Returns in G the number of the current random number generator (1..32) 
< .TP
< Sd=grand('getsd')
< : Returns the value of two integer seeds of the current generator
< Sd=[sd1,sd2]
< .TP
< grand('initgn',I)
< : Reinitializes the state of the current generator 
< .RS
< .TP
< I = -1 
< : sets the state to its initial seed 
< .TP
< I = 0
< : sets the state to its last (previous) seed 
---
> For details see [4] (Case R >= 1.0) and [5] (Case 0.0 < R < 1.0).
103,105c54,57
< I = 1
< : sets the state to a new seed 2^w values from its last seed 
< .RE
---
> Y=grand(m,n,'geom',p), Y=grand(x,'geom',p) 
> : Generates random deviates from a geometric distribution (number
> of Bernouilli trials (with probability succes of p) until a succes
> is met). p must be in [pmin,1] (with pmin = 1.3 10^(-307)).
108,109c60,63
< : Returns random integers following a uniform distribution over
<  (1, 2147483562) using the current generator. 
---
> : Returns the basic output of the current generator : random integers 
> following a uniform distribution over [0, 2^32 - 1] for mt, kiss and fsultra,
> [0, 2147483561] for clcg2, [0, 2^31 - 2] for clcg4 and [0, 2^31 - 1]
> for urand.
124,134c78,86
< Generate M observations from the Multinomial distribution. 
< N is the number of categories,
< P is the vector of probabilities. P(i) is the probability that
< an event will be classified into category i. Thus, P(i)
< must be [0,1]. P is of size N-1, (the probability of category N
<  is 1-sum(P).
< Y(:,i) is an observation from multinomial distribution. All Y(:,i)
<  will be nonnegative and their sum will be N. Y is of size NxM
< 
< Algorithm from page 559 of Devroye, Luc. Non-Uniform Random Variate
< Generation. Springer-Verlag, New York, 1986.
---
> Generates \fVM\fR observations from the Multinomial distribution. 
> \fVN\fR is the number of events (put randomly \fVN\fR "balls" into \fVNcat\fR "urns")
> \fVP\fR is the vector of probabilities. \fVP(i)\fR is the probability that
> an event will be classified into category i. Thus,\fVP(i)\fR
> must be in \fV[0,1]\fR. \fVP\fR is of size \fVNcat-1\fR,
>  (the probability of category \fVNcat\fR is \fV1-sum(P)\fR). 
> \fVY(:,i)\fR is an observation from multinomial distribution. All \fVY(:,i)\fR
>  will be nonnegative and their sum will be \fVN\fR. \fVY\fR is of size
> \fVNxM\fR. For details see Algorithm from page 559 of [6].
139,141c91
<  N is the required number of events (N > 0).  P is The probability of an event during a Bernoulli trial (0.0 < P < 1.0).
< 
< Method: Algorithm from page 480 of Devroye, Luc. Non-Uniform Random Variate Generation. Springer-Verlag, New York, 1986.
---
>  N is the required number of events (N > 0).  P is The probability of an event during a Bernoulli trial (0.0 < P < 1.0). For details see Algorithm from page 480 of [6].
167,174c117
< For details see: 
< Ahrens, J.H. and Dieter, U. Extensions of Forsythe's Method for Random
< Sampling from the Normal Distribution. Math. Comput., 27,124
< (Oct. 1973), 927 - 937. 
< .TP
< Sd=grand('phr2sd','string')
< : Uses a phrase (character string) to generate two seeds for the RGN 
< random number generator. Sd is an integer vector of size 2 \fVSd=[Sd1,Sd2]\fR
---
> For details see [7]. 
180,184c123
< For details see:  Ahrens, J.H. and Dieter, U.
<  Computer Generation of Poisson Deviates 
<  From Modified Normal Distributions. 
<  ACM Trans. Math. Software, 8, 2 
<  (June 1982),163-179 
---
> For details see [8].
190,204d128
< grand('setall',ISEED1,ISEED2)
< :
< Sets the initial seed of generator 1 to ISEED1 and ISEED2. The
< initial seeds of the other generators are set accordingly, and
< all generators states are set to these seeds. 
< .TP
< grand('setcgn',G) 
< : Sets the current generator to G. All references to a generator
< are to the current generator. 
< .TP
< grand('setsd',ISEED1,ISEED2)
< : Resets the initial seed and state of generator g to ISEED1 and
< ISEED2. The seeds and states of the other generators remain 
< unchanged. 
< .TP
206,209c130,132
< : Generates integers uniformly distributed between LOW and HIGH. 
< Low is the low bound (inclusive) on integer value to be generated.
< High is the high bound (inclusive) on integer value to be generated.
< If (HIGH-LOW) > 2,147,483,561 prints error message 
---
> : Generates integers uniformly distributed between Low and High
> (included). High and Low must be integers such that  
> (High-Low+1) > 2,147,483,561.
212,213c135,136
< : Generates reals uniformly distributed between LOW and HIGH. 
< Low is the  low bound (exclusive) on real value to be generated 
---
> : Generates reals uniformly distributed between Low and high. 
> Low is the  low bound on real value to be generated 
215,238d137
< .SH DESCRIPTION 
< Interface fo Library of Fortran Routines for Random Number Generation
< (Barry W. Brown and James Lovato, Department of Biomathematics,
< The University of Texas, Houston) 
< 
< This   set of programs contains   32 virtual random number generators.
< Each generator can provide 1,048,576 blocks of numbers, and each block
< is of length 1,073,741,824.  Any generator can be set to the beginning
< or end of the current block or to its starting value.  The methods are
< from the paper  cited  immediately below, and  most of the  code  is a
< transliteration from the Pascal of the paper into Fortran.
< 
< P.  L'Ecuyer and S. Cote.   Implementing a Random  Number Package with
< Splitting Facilities.  ACM Transactions on Mathematical Software 17:1,
< pp 98-111.
< 
< Most users won't need the sophisticated  capabilities of this package,
< and will desire a single generator.  This single generator (which will
< have a non-repeating length  of 2.3 X  10^18 numbers) is the  default.
< In order to accommodate this use, the concept of the current generator
< is added to those of the  cited paper;  references to a  generator are
< always to the current generator.  The  current generator  is initially
< generator number  1; it  can  be  changed by 'setcgn', and the ordinal
< number of the current generator can be obtained from 'getcgn'.
240,253c139
< The user of the default can set the  initial values of the two integer
< seeds with 'setall'.   If the user does  not set the   seeds, the random
< number   generation will  use   the  default   values, 1234567890  and
< 123456789.  The values of the current seeds can be  achieved by a call
< to 'getsd'.  Random number may be obtained as integers ranging from 1 to
< a large integer by reference to option 'lgi' or as a floating point
< number between 0 and 1 by a reference to option 'def'.  These are the
< only routines  needed by a user desiring   a single stream   of random
< numbers.
< .SH CONCEPTS
< A stream of pseudo-random numbers is a sequence, each member  of which
< can be obtained either as an integer in  the range 1..2,147,483,563 or
< as a floating point number in the range [0..1].  The user is in charge
< of which representation is desired.
---
> .SH PARAMETERS#2 (set/get the current generator and its state)
255,269c141,279
< The method contains an algorithm  for generating a  stream with a very
< long period, 2.3 X 10^18.   This  stream  in  partitioned into G (=32)
< virtual generators.  Each virtual generator contains 2^20 (=1,048,576)
< blocks   of non-overlapping   random  numbers.   Each  block is   2^30
< (=1,073,741,824) in length.
< 
< The state of a generator  is determined by two  integers called seeds.
< The seeds can be  initialized  by the  user; the initial values of the
< first must lie between 1 and 2,147,483,562, that of the second between
< 1 and 2,147,483,398.  Each time a number is generated,  the  values of
< the seeds  change.   Three  values   of seeds are remembered   by  the
< generators  at all times:  the   value with  which the  generator  was
< initialized, the value at the beginning of the current block,  and the
< value at the beginning of the next block.   The seeds of any generator
< can be set to any of these three values at any time.
---
> Since Scilab-2.6.x you have the possibility to choose between 
> the following 5 different base generators (which give random 
> numbers following the 'lgi' law, the other laws being gotten from it) : 
> .RS
> .TP
> mt
> The Mersenne-Twister of M. Matsumoto and T. Nishimura, period 
> about 2^19937, state given by an array of 624 integers ; this 
> is the default generator.
> .TP
> kiss
> The Keep It Simple Stupid of G. Marsaglia,  period about 2^123,
> state given by 4 integers.
> .TP
> clcg2
> a Combined 2 Linear Congruential Generator of P. L'Ecuyer,
> period about 2^61, state given by 2 integers ; this is 
> the generator previously used by grand.
> .TP
> clcg4
> a Combined 4 Linear Congruential Generator of P. L'Ecuyer,
> period about 2^121, state given by 4 integers ; this one is 
> splitting in 101 different virtual (non over-lapping) generators 
> which may be useful for different tasks (see TEST EXAMPLE FOR CLCG4).
> .TP
> urand 
> a uniform random number generator based  on  theory  and
> suggestions  given  in  d.e. knuth (1969),  vol  2. State
> given by 1 integer, period of 2^31. urand is the generator 
> used by the scilab \fVrand\fR function
> .TP
> fsultra
> Arif Zaman (arif@stat.fsu.edu) and George Marsaglia
> (geo@stat.fsu.edu).
> .RE
> .TP
> gen=grand('getgen')
> : Gets the current generator ('mt', 'kiss', 'clcg2', 'clcg4', 'urand'
> or 'fsultra')
> .TP
> grand('setgen',gen)
> : Sets the current generator to be gen (= 'mt', 'kiss', 'clcg2',
> 'clcg4', 'urand', 'fsultra')
> .TP
> S = grand('getsd')
> : Gets the current state (the current seeds) of the current generator ; S is
> given as a column vector (of integers) of dimension 624 for mt,
> 4 for kiss, 2 for clcg2 and fsultra, 4 for clcg4 (for this last one you get
> the current state of the current virtual generator) and 1 for urand.
> .TP
> grand('setsd',S), grand('setsd',s1[,s2,s3,s4])
> : Sets the state of the current generator (the new seeds) :
> .RS
> .TP
> for mt 
> S is a vector of integers of dim 624, but a simpler initialisation
> may be done with only one integer s1 (s1 must be in [1,2^32[) ;
> .TP
> for kiss 
> 4 integers s1,s2, s3,s4 in [0,2^32[ must be provided ;
> .TP
> for clcg2 
> 2 integers s1 in [1,2147483562] and s2 in [1,2147483398] must be
> given ;
> .TP
> for clcg4
> 4 integers with s1 in [1,2147483646], s2 in [1,2147483542],
> s3 in [1,2147483422] and s4 in [1,2147483322] are required ;
> CAUTION : with clcg4 you set the seeds of the current virtual
> generator but you may lost the synchronisation between this one
> and the others virtuals generators (ie the sequence generated
> is not warranty to be non over-lapping with a sequence generated
> by another virtual generator)=> use instead the 'setall' option.
> .TP
> for urand 
> one integer in [0,2^31[. 
> .TP
> for fsultra
> 2 integers s1,s2 in [0,2^32[ must be provided ;
> .RE
> .TP
> Sd=grand('phr2sd','string')
> : Uses a phrase (character string) to generate two seeds for the 
> RGN random number generator. Sd is an integer vector of size 
> 2 \fVSd=[Sd1,Sd2]\fR
> 
> .SH OPTIONS SPECIFIC TO CLCG4
> The clcg4 generator may be used as the others generators but it
> offers the advantage to be split in several (101) virtual
> generators with non over-lapping sequences (when you use a classic
> generator you may change the initial state (seeds) in order to
> get another sequence but you are not warranty to get a complete 
> different one). Each virtual generator corresponds to a sequence
> of 2^72 values which is further split into V=2^31 segments (or
> blocks) of length W=2^41. For a given virtual generator you have
> the possibility to return at the beginning of the sequence or
> at the beginning of the current segment or to go directly at the
> next segment. You may also change the initial state (seed) of
> the generator 0 with the 'setall' option which then change also
> the initial state of the other virtual generators so as to get
> synchronisation (ie in function of the new initial state of gen 0
> the initial state of gen 1..100 are recomputed so as to get 101
> non over-lapping sequences.   
> .TP
> grand('setcgn',G) 
> : Sets the current virtual generator for clcg4 (when clcg4 is set, this
> is the virtual (clcg4) generator number G which is used);  the virtual
> clcg4 generators are numbered from 0,1,..,100 (and so G must be an integer in 
> [0,100]) ; by default the current virtual generator is 0.
> .TP
> G=grand('getcgn')
> : Returns in G the number of the current virtual clcg4 generator.
> .TP
> grand('initgn',I)
> : Reinitializes the state of the current virtual generator 
> .RS
> .TP
> I = -1 
> : sets the state to its initial seed 
> .TP
> I = 0
> : sets the state to its last (previous) seed (i.e. to the beginning 
> of the current segment) 
> .TP
> I = 1
> : sets the state to a new seed W values from its last seed (i.e. to
> the beginning of the next segment) 
> .RE
> .TP
> grand('setall',s1, s2, s3, s4)
> :
> Sets the initial state of generator 0 to s1,s2,s3,s4. The
> initial seeds of the other generators are set accordingly
> to have synchronisation. For constraints on s1, s2, s3, s4 
> see 'setsd' option. 
> .TP
> grand('advnst',K) 
> : Advances the state of the current generator by 2^K values and 
> resets the initial seed to that value. 
271,281c281,286
< Of the  32 virtual   generators, exactly one    will  be  the  current
< generator, i.e., that one will  be used to  generate values for 'lgi'
< and 'def'.   Initially, the current generator is   set to number  one.
< The current generator may be changed by calling 'setcgn', and the number
< of the current generator can be obtained using 'getcgn'.
< .SH TEST EXAMPLE
< An example of  the  need  for these capabilities   is as follows.  Two
< statistical techniques are being compared on  data of different sizes.
< The first  technique uses   bootstrapping  and is  thought to   be  as
< accurate using less data   than the second method  which  employs only
< brute force.
---
> .SH TEST EXAMPLE FOR CLCG4
> An example of  the  need of the splitting capabilities of clcg4 is as 
> follows.  Two statistical techniques are being compared on  data of 
> different sizes. The first  technique uses   bootstrapping  and is  
> thought to   be  as accurate using less data   than the second method  
> which  employs only brute force.
294,295c299,300
< With the package, it is a snap.  Use generator 1 to obtain  the sample
< size for  method one and generator 2  to obtain the  data.  Then reset
---
> With clcg4, it is a snap.  Use generator 0 to obtain  the sample
> size for  method one and generator 1  to obtain the  data.  Then reset
300,308d304
< .SH INTERFACE 
< A random number is obtained either  as a random  integer between 1 and
< 2,147,483,562  by using option 'lgi' (large integer) 
< or as a  random  floating point  number  between 0 and 1  by
< using option 'def'.
< 
< The  seed of the  first generator  can  be set by using option
< 'setall';   the values of   the seeds  of   the other 31 generators  are
< calculated from this value.
310,312c306,312
< The number of  the current generator can be set by using option 'setcgn'
< The number of the current  generator can be obtained by using option
< 'getcgn'.
---
> .SH REFERENCES
> .TP
> randlib
> The codes to generate sequences following other laws than def, unf, lgi, 
> uin and geom are from "Library of Fortran Routines for Random Number 
> Generation", by Barry W. Brown and James Lovato, Department of Biomathematics,
> The University of Texas, Houston.
313a314,381
> References used by randlib :
> .RS
> .TP
> [1]
> R. C. H. Cheng "Generating Beta Variables with Nonintegral Shape Parameters" 
> Communications of the ACM, 21:317-322 (1978) (Algorithms BB and BC)
> .TP
> [2]
> algorithm BTPE from:  Kachitvichyanukul, V. and Schmeiser, B. W. "Binomial Random Variate Generation".
> Communications of the ACM, 31, 2 (February, 1988) 216. 
> .TP
> [3]
> Ahrens, J.H. and Dieter, U. "Computer Methods for Sampling From the Exponential and Normal Distributions".
> Comm. ACM, 15,10 (Oct. 1972), 873 - 882. 
> .TP
> [4]
> Ahrens, J.H. and Dieter, U. "Generating Gamma Variates by a Modified Rejection Technique". 
> Comm. ACM, 25,1 (Jan. 1982), 47 - 54. Algorithm GD
> .TP
> [5]
> Ahrens, J.H. and Dieter, U. "Computer Methods for Sampling from Gamma, Beta, Poisson and 
> Binomial Distributions". Computing, 12 (1974), 223-246/ Adapted algorithm GS.
> .TP
> [6]
> Devroye, Luc. "Non-Uniform Random Variate Generation". 
> Springer-Verlag, New York, 1986.
> .TP
> [7]
> Ahrens, J.H. and Dieter, U. "Extensions of Forsythe's Method for Random
> Sampling from the Normal Distribution". Math. Comput., 27,124 (Oct. 1973), 927 - 937. 
> .TP
> [8]
> Ahrens, J.H. and Dieter, U. "Computer Generation of Poisson Deviates From Modified Normal Distributions". 
> ACM Trans. Math. Software, 8, 2 (June 1982),163-179 
> .RE
> .TP 
> mt
> The code is the mt19937int.c by M. Matsumoto and 
> T. Nishimura, "Mersenne Twister: A 623-dimensionally equidistributed 
> uniform pseudorandom number generator", ACM Trans. on Modeling and 
> Computer Simulation Vol. 8, No. 1, January, pp.3-30 1998.
> .TP
> kiss
> The code was given by G. Marsaglia at the end of a thread concerning
> RNG in C in several newsgroups (whom sci.math.num-analysis) "My offer of 
> RNG's for C was an invitation to dance..." only kiss have been included
> in Scilab (kiss is made of a combinaison of severals others which are
> not visible at the scilab level).
> .TP
> clcg2
> The method is from P. L'Ecuyer but the C code is provided at the Luc 
> Devroye home page (http://cgm.cs.mcgill.ca/~luc/rng.html). This
> one have been slighty modified to recover the generator uses previously 
> by grand (but clcg2 don't provide the virtual generators stuff)
> .TP
> clcg4
> The code is from P. L'Ecuyer and Terry H.Andres and provided at the
> P. L'Ecuyer home page ( http://www.iro.umontreal.ca/~lecuyer/papers.html)
> A paper is also provided and this new package is the logical successor
> of an old 's one from : P.  L'Ecuyer and S. Cote.   Implementing a Random  
> Number Package with Splitting Facilities.  ACM Transactions on Mathematical 
> Software 17:1,pp 98-111.
> .TP 
> fsultra 
> code from Arif Zaman (arif@stat.fsu.edu) and George Marsaglia (geo@stat.fsu.edu)
> .TP
> scilab packaging
> By Jean-Philippe Chancelier and Bruno Pincon
======================================================================
Index: elementary/atan.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/elementary/atan.man,v
retrieving revision 1.1
retrieving revision 1.3
diff -r1.1 -r1.3
1c1
< .TH atan G "April 1993" "Scilab Group" "Scilab Function"
---
> .TH atan G "July 2001" "Scilab Group" "Scilab Function"
4c4
< atan - tangent inverse
---
> atan - 2-quadrant and 4-quadrant inverse tangent
7c7,8
< [t]=atan(x)
---
> phi=atan(x)
> phi=atan(y,x)
10c11,12
< .TP 10
---
> .SS first form
> .TP 8
12,15c14,24
< : real or complex vector
< .TP 10
< t
< : real or complex vector
---
> : real or complex scalar, vector or matrix
> .TP 8
> phi
> : real or complex scalar, vector or matrix
> .SS second form
> .TP 8
> x, y
> : real scalars, vectors or matrices of the same size
> .TP 8
> phi
> : real scalar, vector or matrix
17,22c26,42
< The components of vector \fVt\fR are the arctangent of the 
< corresponding entries of vector \fVx\fR.
< .LP
< \fVatan(x,y)\fR is the same as \fVatan(x/y)\fR but \fVy\fR is
< allowed to be zero.
< .SH EXAMPLE
---
> The first form computes the 2-quadrant inverse tangent, which is the
> inverse of \fVtan(phi)\fR.  For real \fVx\fR, \fVphi\fR is in the
> interval (-pi/2, pi/2).  For complex \fVx\fR, \fVatan\fR has two
> singular, branching points \fV+%i\fR,\fV-%i\fR and the chosen branch
> cuts are the two imaginary half-straight lines [i, i*oo) and (-i*oo,
> -i].
> 
> The second form computes the 4-quadrant arctangent (`atan2' in
> Fortran), this is, it returns the argument (angle) of the complex
> number \fVx+i*y\fR.  The range of \fVatan(y,x)\fR is (-pi, pi].
> 
> For real arguments, both forms yield identical values if \fVx>0\fR.
> 
> In case of vector or matrix arguments, the evaluation is done
> element-wise, so that \fVphi\fR is a vector or matrix of the same size
> with \fVphi(i,j)=atan(x(i,j))\fR or \fVphi(i,j)=tan(y(i,j),x(i,j))\fR.
> .SH EXAMPLES
23a44
> // examples with the second form
25a47,59
> atan(0,-1)
> atan(-%eps,-1)
> 
> // branch cuts, [+i, i*oo) and (-i*oo, -i]
> atan(-%eps + 2*%i)
> atan(+%eps + 2*%i)
> atan(-%eps - 2*%i)
> atan(+%eps - 2*%i)
> 
> // values at the branching points
> ieee(2)
> atan(%i)
> atan(-%i)
28a63,64
> .SH AUTHORS (complex atan function)
> B.P., L.V.D.
======================================================================
Index: elementary/binomial.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/elementary/binomial.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
11c11
< : vector, pr(k) = probability (X=k) , with X=B(n,p).
---
> : a row vector with N+1 components 
14c14
< : real number
---
> : real number in [0,1] 
18c18
< integer
---
> an integer >= 0
20,24c20,29
< \fVpr=binomial(p,n)\fR return a binomial probability vector.
< pr(k) = probability (X=k) , with X=B(n,p) i.e the
< probability of k success in n independent trials, (p = proba. of one success).
< \fVpr(k) = C(n,k) p^k (1-p)^(n-k)\fR with 
< C(n,k)= n!/(k!(n-k)!) = prod(1:n)/(prod(1:k)*prod(1:n-k)).
---
> \fVpr=binomial(p,n)\fR return the binomial probability vector. i.e the
> probability of k success in n independent trials, (where p is the probability of one
> success).
> 
> pr(k) = probability(X=k) , with X=B(n,p) 
> .nf
>  pr(k) = C(n,k) p^k (1-p)^(n-k)
>  with
>  C(n,k)= n!/(k!(n-k)!) = prod(1:n)/(prod(1:k)*prod(1:n-k)).
> .fi
======================================================================
Index: elementary/full.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/elementary/full.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
4,5c4,5
< full -  sparse to full matrix conversion
< .SH CALING SEQUENCE
---
> full - sparse to full matrix conversion
> .SH CALLING SEQUENCE
======================================================================
Index: elementary/mean.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/elementary/mean.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
22,23c22,25
< \fVy=mean(x,'r')\fR (or, equivalently, \fVy=mean(x,1)\fR) is the rowwise mean. It returns in each 
< entry of the column vector \fVy\fR the mean of each row of \fVx\fR.
---
> \fVy=mean(x,'r')\fR (or, equivalently, \fVy=mean(x,1)\fR) is the
> rowwise mean. It returns a row vector:
>  \fVy(j)= mean(x(:,j))\fR
> 
26,27c28,30
< \fVy=mean(x,'c')\fR (or, equivalently, \fVy=mean(x,2)\fR) is the columnwise mean. It returns in each entry of the row vector 
< \fVy\fR the mean of each column  of \fVx\fR.
---
> \fVy=mean(x,'c')\fR (or, equivalently, \fVy=mean(x,2)\fR) is the
> columnwise mean. It returns a column  vector: \fVy(i)= mean(x(i,:))\fR
> 
======================================================================
Index: elementary/sparse.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/elementary/sparse.man,v
retrieving revision 1.1
retrieving revision 1.3
diff -r1.1 -r1.3
4c4
< sparse -  sparse matrix definition
---
> sparse - sparse matrix definition
16a17,19
> .TP
> v
> : vector 
======================================================================
======================================================================
Index: elementary/sum.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/elementary/sum.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
23,25c23,24
< \fVy=sum(x,'r')\fR (or, equivalently, \fVy=sum(x,1)\fR) is the rowwise sum. It returns in each 
< entry of the row vector \fVy\fR the sum of the rows of \fVx\fR (The sum is performed on the 
< row indice : \fVy(j)= sum(x(i,j),i=1,m)\fR).
---
> \fVy=sum(x,'r')\fR (or, equivalently, \fVy=sum(x,1)\fR) is the rowwise
> sum: \fVy(j)= sum(x(:,j))\fR. \fVy\fR is a row vector
28,29c27
< in each entry of the column vector \fVy\fR the sum of the columns of \fVx\fR 
< (The sum is performed on the column indice:  \fVy(i)= sum(x(i,j),j=1,n)\fR)).
---
> in each entry of the column vector \fVy\fR the sum :  \fVy(i)= sum(x(i,:))\fR)).
======================================================================
Index: elementary/typeof.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/elementary/typeof.man,v
retrieving revision 1.1
retrieving revision 1.3
diff -r1.1 -r1.3
4c4
< typeof -  object type
---
> typeof - object type
47a48,50
> .TP
> if object is a \fV tlist\fR or \fVmlist\fR, \fV t\fR is the first
> string in the first list entry.
51a55
> 
53a58
> 
56a62
> 
58a65,67
> 
> L=tlist(['V','a','b'],18,'Scilab');
> typeof(L)
======================================================================
Index: fileio/fileinfo.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/fileio/fileinfo.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
39a40,64
> .TP
> x(7)
> : The date of last change 
> .TP
> x(8)
> : The date of last access 
> .TP
> x(9)
> : The device type (if inode device) 
> .TP
> x(10)
> : The blocksize for filesystem I/O 
> .TP
> x(11)
> : The  number of blocks allocated 
> .TP
> x(12)
> : The inode 
> .TP
> x(13)
> : The number of hard links 
> .SH REFERENCE
> This function is an interface to the C function stat.
> .SH AUTHOR
> S. Steer INRIA
47c72
< getdate, file, dispfiles, newest
---
> getdate, file, dispfiles, newest, isdir
======================================================================
Index: fileio/fscanf.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/fileio/fscanf.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
40c40
< printf, read, scanf, sscanf 
---
> printf, read, scanf, sscanf, mfscanf
======================================================================
Index: fileio/lines.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/fileio/lines.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
8c8
< nlc=lines()
---
> ncl=lines()
19,20c19,20
< nlc
< : a 1x2 vector [nl,nc]
---
> ncl
> : a 1x2 vector [nc,nl]
36c36,38
< are automatically set according to the output window size.
---
> are automatically set according to the output window size, these
> parameters are also automaticaly modified when the window is resized.
> 
======================================================================
Index: fileio/mgetl.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/fileio/mgetl.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
25,28c25,29
< If \fVm\fR is given \fVmgetl\fR tries to read exactly m lines, if an
< end of file occurs before \fVm\fR lines are read an error is
< issued. This option is useful to sequentialy read part of a file
< as follow
---
> If \fVm\fR is given \fVmgetl\fR tries to read exactly m lines. This
> option is useful to sequentialy read part of a file. In this case if
> an end of file (EOF) occurs before \fVm\fR lines are read the read lines are
> returned (it is possible to check if EOF had occured using the meof
> function) issued. 
======================================================================
======================================================================
Index: fileio/mopen.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/fileio/mopen.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
14c14,15
< mode : a character string that controls whether the file is opened
---
> mode 
> : a character string that controls whether the file is opened
======================================================================
Index: fileio/mprintf.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/fileio/mprintf.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
15c15,16
< fd : scalar, file descriptor given by \fVmopen\fR (it's a positive
---
> fd 
> : scalar, file descriptor given by \fVmopen\fR (it's a positive
======================================================================
Index: fileio/mscanf.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/fileio/mscanf.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
2d1
< .so ../sci.an
20c19,20
< fd : scalar, file descriptor given by \fVmopen\fR (it's a positive
---
> fd 
> : scalar, file descriptor given by \fVmopen\fR (it's a positive
======================================================================
Index: functions/genlib.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/functions/genlib.man,v
retrieving revision 1.1
retrieving revision 1.3
diff -r1.1 -r1.3
6d5
< 
9c8
< genlib(lib-name [,dir-name])
---
> genlib(lib-name [,dir-name, [ force [,verbose]]])
20c19,21
< 
---
> .TP
> force,verbose
> : boolean values (default values \fV%f\fR). 
26c27,31
< \fV.sci\fR file, \fVgenlib\fR does not translate and save the file.
---
> \fV.sci\fR file, \fVgenlib\fR does not translate and save the file. 
> 
> This default behaviour can be changed if \fVforce\fR is given and 
> set to \fV%t\fR. In this latter case the recompilation iis always 
> performed for each \fV.sci\fR file. 
30a36,38
> 
> If \fVverbose\fR is et to \fV%t\fR informations are displayed during 
> the build process.
======================================================================
Index: functions/lib.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/functions/lib.man,v
retrieving revision 1.1
retrieving revision 1.3
diff -r1.1 -r1.3
6d5
< 
17,21c16,22
< compiled Scilab function (\fV.bin\fR) files.  In addition to these
< files \fVlib-dir\fR must have a file called \fVnames\fR, that contains
< the names of the functions defined in \fVlib-dir\fR.  On success, all
< functions in \fVlib-dir\fR are available from within Scilab.  They are
< loaded on demand when called for the first time.
---
> compiled Scilab function (\fV.bin\fR) files.
> 
> In addition to these files \fVlib-dir\fR must have a file called
> \fVnames\fR, that contains the names of the functions defined in
> \fVlib-dir\fR.  On success, all functions in \fVlib-dir\fR are
> available from within Scilab.  They are loaded on demand when called
> for the first time.
29,46c30
< As an example, given the following definitions
< .nf
<     deff('z = myplus(x, y)', 'z = x + y')
<     deff('z = yourplus(x, y)', 'x = x - y')
<     lib_dir = '/home/joeuser/myscidir'
< .fi
< \fVmyplus\fR and \fVyourplus\fR are compiled into \fVlib_dir\fR with
< the commands
< .nf
<     save(lib_dir + '/myplus.bin', myplus)
<     save(lib_dir + '/yourplus.bin', yourplus)
< .fi
< A library can now be created from the two \fV.bin\fR files with the
< command
< .nf
<         xlib = lib(lib_path + '/')
< .fi
< \fVxlib\fR is a Scilab variable of type "library".  A library variable
---
> A library variable
48c32
< user-specific startup file (\fV$HOME/.scilab\fR).
---
> user-specific startup file (see startup).
51,52c35,54
< Scilab tacitly assumes that file \fVfoo.bin\fR defines only a single
< function named \fVfoo\fR.
---
> Scilab tacitly assumes that each xxxx.bin file defines a 
> variable named \fVxxxx\fR.
> .SH EXAMPLE
> .nf
> //define some variables
> function z = myplus(x, y), z = x + y,endfunction
> function z = yourplus(x, y), x = x - y,endfunction
> A=1:10;
> 
> //create the *.bin files in libdir
> libdir=TMPDIR
> save(libdir + '/myplus.bin', myplus);
> save(libdir + '/yourplus.bin', yourplus);
> save(libdir + '/A.bin', A);
> 
> //create the name file
> mputl(['myplus';'yourplus';'A'],TMPDIR+'/names');
> 
> //build the library containing myplus and yourplus
> xlib = lib(libdir+'/')
53a56,63
> //erase the variables
> clear myplus yourplus A
> 
> //Automatic loading and execution
> myplus(1,2)
> 
> A
> .fi
55c65
< genlib, save, deff, getf, whereis
---
> library, genlib, save, deff, getf, whereis
======================================================================
Index: graphics/Matplot.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/graphics/Matplot.man,v
retrieving revision 1.1
retrieving revision 1.3
diff -r1.1 -r1.3
7a8
> plot2d(a,<opt_args>)
10c11
< .TP 3
---
> .TP 11
14,15c15,156
< strf,rect,nax
< : optional arguments, see \fVplot2d\fR.
---
> <opt_args>
> : This represents a sequence of statements \fVkey1=value1,
> key2=value2\fR,... where \fVkey1\fR, \fVkey2,...\fR can be one of the
> following:
> .RS
> .TP 9
> rect 
> : sets the bounds of the plot. If this key is given and neither \fVframeflag\fR
> nor \fVstrf\fR is  given then the \fVy\fR character of \fVstrf\fR is
> supposed to be \fV7\fR.  See below for value.
> .TP
> nax 
> : sets the grids definition. If this key is given and neither
> \fVaxesflag\fR nor \fVstrf\fR is given then the \fVz\fR character of
> \fVstrf\fR is supposed to be \fV1\fR.  See below for value.
> .TP
> frameflag
> : specifies how the frame of the plot is computed. The value is an
> integer ranging from 0 to 8. It corresponds to the \fVy\fR character of \fVstrf\fR. See below.
> .TP
> axesflag
> : specifies what kind of axes are drawn around the plot. The value is
> an integer ranging from 0 to 5. It corresponds to the \fVz\fR character of \fVstrf\fR. See below.
> .RE
> .TP
> .TP
> strf
> : 
> is a string of length 3 \fV"xyz"\fR.
> .RS
> .TP
> The default is \fV"081"\fR.
> .TP 3
> x
> : controls the display of captions.
> .RS
> .TP 5
> x=0
> : no caption.
> .TP
> x=1
> : captions are displayed. They are given by the optional argument \fVleg\fR.
> .RE
> .TP
> y
> : controls the computation of the actual coordinate ranges from the
> minimal requested values. Actual ranges can be larger than minimal
> requirements.
> .IG
> 
> .TS
> tab(@);
> l l l l.
>    requirements@ranges       @ranges    @ranges
>                @of a previous@given by  @computed from
> actual         @plot         @rect arg  @x and y
> -------------- @------------ @--------- @-------------
> requested      @             @          @
> one            @      y=0    @    y=1   @      y=2
> -------------- @------------ @--------- @-------------
> Computed       @             @          @ 
> for isometric  @             @    y=3   @      y=4
> view           @             @          @
> -------------- @------------ @--------- @-------------
> Enlarged       @             @          @
> For pretty     @             @    y=5   @      y=6
> axes           @             @          @
> -------------- @------------ @--------- @-------------
> Previous and   @             @          @
> current        @             @    y=7   @      y=8
> plots merged   @             @          @
> -------------- @------------ @--------- @-------------
> 
> .TE
> .FI
> \" This is for LaTeX 
> .LA 
> .LA \begin{tabular}{|l|l|l|l|}                               \hline
> .LA    requirements&ranges       &ranges    &ranges       \\    
> .LA                &of a previous&given by  &computed from\\
> .LA actual         &plot         &rect arg  &x and y      \\ \hline
> .LA requested      &             &          &             \\
> .LA one            &      y=0    &    y=1   &      y=2    \\ \hline
> .LA Computed       &             &          &             \\
> .LA for isometric  &             &    y=3   &      y=4    \\
> .LA view           &             &          &             \\ \hline
> .LA Enlarged       &             &          &             \\  
> .LA For pretty     &             &    y=5   &      y=6    \\
> .LA axes           &             &          &             \\ \hline
> .LA Previous and   &             &          &             \\
> .LA current        &             &    y=7   &      y=8    \\
> .LA plots merged   &             &          &             \\ \hline
> .LA \end{tabular}
> .LA 
> 
> .TP
> z 
> : controls the display of information on the frame around the plot.
> If axes are requested, the number
> of tics can be specified by the \fVnax\fR optional argument.
> .RS
> .TP 5
> z=0
> : 
> nothing is drawn around the plot.
> .TP
> z=1 
> : 
> axes are drawn, the y=axis is displayed on the left. 
> .TP
> z=2
> : 
> the plot is surrounded by a box without tics.
> .TP
> z=3 
> : 
> axes are drawn, the y=axis is displayed on the right. 
> .TP
> z=4
> : 
> axes are drawn centred in the middle of the frame box. 
> .TP
> z=5 
> : 
> axes are drawn so as to cross at point \fV(0,0)\fR.  If point
> \fV(0,0)\fR does not lie inside the frame, axes will not appear on the graph.
> .RE
> .RE
> .TP
> rect
> : 
> This argument is used when the second character y of argument \fVstrf\fR is 1,
> 3 or 5. It is a row vector of size 4 and gives the dimension of the frame: 
> \fVrect=[xmin,ymin,xmax,ymax]\fR.
> .TP
> nax
> : 
> This argument is used when the third character z of argument \fVstrf\fR is 1.
> It is a row vector with four entries \fV[nx,Nx,ny,Ny]\fR where
> \fVnx\fR (\fVny\fR) is the number of subgraduations on the x (y) axis and
> \fVNx\fR (\fVNy\fR) is the number of graduations on the x (y) axis.
> 
20c161
< \fV(x=j,y=(n2-i+1))\fR.
---
> \fV(x=j,y=(n1-i+1))\fR.
======================================================================
Index: graphics/contour.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/graphics/contour.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
156c156,157
< \fVstring=""\fR to switch back to default format.
---
> \fVstring=""\fR to switch back to default format and Use 
> \fVstring=" "\fR to suppress printing.
======================================================================
Index: graphics/contour2d.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/graphics/contour2d.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
52a53
> 
56c57,58
< \fVstring=""\fR to switch back to default format.
---
> \fVstring=""\fR to switch back to default format and Use 
> \fVstring=" "\fR to suppress printing.
57a60
> 
======================================================================
Index: graphics/driver.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/graphics/driver.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
35,37c35,51
< : output into Gif format (beta test driver written by Tom Leitner 
< (http://wiis.tu-graz.ac.at/people/tom.html).
< Note that line thickness is not handled yet.
---
> : output into Gif format based on gd (http://www.boutell.com/gd)
> .TP
> "PPM" 
> : output into PPM format based on gd (http://www.boutell.com/gd)
> .SH REMARK
> To convert "GIF" or "PPM" files to other image format or for building
> animation one can use the "convert" program for ImageMagic
> (http://www.imagemagick.org/)
> .LP
> For example if one has generated a sequence of Gif files named
> \fVimg*.gif\fr it is possible to build an animated Gif file (named
> anim.gif) by
> .nf
> convert -delay 10  img*.gif anim.gif  
> .fi
> 
> 
======================================================================
Index: graphics/fchamp.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/graphics/fchamp.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
8c8
< fchamp(x,y,xr,yr,<opt_args>)
---
> fchamp(f,t,xr,yr,<opt_args>)
18c18
< where \fVf\fR is supposed to be a function of type \fVy=f(t,x,[u])\fR.
---
> where \fVf\fR is supposed to be a function of type \fVy=f(t,xy [p1,..pn])\fR.
22c22
< \fVf\fR at point \fVx\fR and at time \fVt\fR.
---
> \fVf\fR at point \fVxy=[x,y]\fR and at time \fVt\fR.
26,27c26,27
< \fVlist(f,u1)\fR
< where \fVf\fR is a function of type \fVy=f(t,x,u)\fR and \fVu1\fR gives the value of the parameter \fVu\fR.
---
> \fVlist(f,P1,..Pn)\fR
> where \fVf\fR is a function of type \fVy=f(t,xy,p1,..pn)\fR and \fVPi\fR gives the value of the parameter \fVpi\fR.
======================================================================
Index: graphics/fcontour.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/graphics/fcontour.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
39a40,46
> You can change the format of the floating point number printed on the levels
> by using \fVxset("fpf",string)\fR where \fVstring\fR gives the 
> format in C format syntax (for example \fVstring="%.3f"\fR). Use 
> \fVstring=""\fR to switch back to default format and Use 
> \fVstring=" "\fR to suppress printing.
> .LP
> 
======================================================================
Index: graphics/fcontour2d.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/graphics/fcontour2d.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
41a42,48
> .LP
> You can change the format of the floating point number printed on the levels
> by using \fVxset("fpf",string)\fR where \fVstring\fR gives the 
> format in C format syntax (for example \fVstring="%.3f"\fR). Use 
> \fVstring=""\fR to switch back to default format and Use 
> \fVstring=" "\fR to suppress printing.
> .LP
======================================================================
Index: graphics/getfont.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/graphics/getfont.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
7a8,10
> fnt=getfont()
> fnt=getfont(str)
> fnt=getfont(S=str,font=[fId,fSize])
18a22,24
> .TP
> fnt
> : vector [fId,fSize]
21,22c27,37
< Example of use: \fV[fId,fSize]=getfont()\fR. \fVxset("font",fId,fSize)\fR.
< \fVplot2d(0,0,rect=[0 0 10 10],axesflag=0)\fR;\fVxstring(5,5,"string")\fR.
---
> User has to select a font and a size clicking on the corresponding
> displayed character. Killing a keyboard key changes the displayed
> character.
> .SH EXAMPLES
> .nf
> [fId,fSize]=getfont();
> xset("font",fId,fSize)
> plot2d(0,0,rect=[0 0 10 10],axesflag=0)
> xstring(5,5,"string")
> .fi
> 
24c39
< xset, getmark
---
> xset, getmark, xlfont
======================================================================
Index: graphics/histplot.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/graphics/histplot.man,v
retrieving revision 1.1
retrieving revision 1.3
diff -r1.1 -r1.3
7a8
> histplot(npoint,data,<opt_args>)
18a20,61
> .TP
> <opt_args>
> : This represents a sequence of statements \fVkey1=value1,
> key2=value2\fR,... where \fVkey1\fR, \fVkey2,...\fR  can be one of the
> following:
> .RS
> .TP 9
> normalization
> : if false, the values drawn along the y axis are the numbers \fVNi\fR of
> elements in each bins. if true (this is the default value) the values
> drawn along the y axis are Ni/N/lbi where N is the total numbers of
> elements and lbi the length of the ith bin.
> .TP
> style
> : sets the style for each curve, see below for value.
> .TP
> leg 
> : sets the curves captions. If this key is given and \fVstrf\fR
> is not given then \fVx\fR character of \fVstrf\fR is supposed to be
> \fV1\fR. See below for value.
> .TP
> rect 
> : sets the bounds of the plot. If this key is given and neither \fVframeflag\fR
> nor \fVstrf\fR is  given then the \fVy\fR character of \fVstrf\fR is
> supposed to be \fV7\fR.  See below for value.
> .TP
> nax 
> : sets the grids definition. If this key is given and neither
> \fVaxesflag\fR nor \fVstrf\fR is given then the \fVz\fR character of
> \fVstrf\fR is supposed to be \fV1\fR.  See below for value.
> .TP
> logflag
> : sets the graduation type (linear or logarithmic) along the axes. See below for value.
> .TP
> frameflag
> : specifies how the frame of the plot is computed. The value is an
> integer ranging from 0 to 8. It corresponds to the \fVy\fR character of \fVstrf\fR. See below.
> .TP
> axesflag
> : specifies what kind of axes are drawn around the plot. The value is
> an integer ranging from 0 to 5. It corresponds to the \fVz\fR character of \fVstrf\fR. See below.
> .RE
23c66
< the values stored in \fVdata\fR using \fVnpoint\fR equally spaced classes.
---
> the values stored in \fVdata\fR using \fVnpoint\fR equally spaced bins.
27,29c70,81
< values stored in \fVdata\fR using the classes \fV]npoint(k),npoint(k+1)]\fR.
< .LP
< Enter the command \fVhistplot()\fR to see a demo.
---
> values stored in \fVdata\fR using the bins \fV]npoint(k),npoint(k+1)]\fR.
> .SH EXAMPLE
> .nf
> histplot()
> 
> d=rand(1,10000,'normal');
> xbasc();histplot(20,d)
> 
> xbasc();histplot(20,d,normalization=%f)
> xbasc();histplot(20,d,leg='rand(1,10000,''normal'')',style=5)
> 
> .fi
31c83
< hist3d, plot2d
---
> hist3d, plot2d, gsearch
======================================================================
Index: gui/addmenu.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/gui/addmenu.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
89,93c89,90
< code=[
<  '#include ""'+SCI+'/routines/machine.h""'
<  'void C2F(foo)(name,win,entry)'
<  '     char *name;'
<  '     int * win,*entry;'
---
> code=[ '#include ""machine.h""'
>  'void foo(char *name,int *win,int *entry)'
99c96
<  '}']
---
>  '}'];
100a98
> dir=getcwd(); chdir(TMPDIR)
103,105c101,103
< ilib_gen_Make('foo','foo','',TMPDIR+'/Makefile',%f)
< // Compiling and linking
< link(ilib_compile('foo',TMPDIR+'/Makefile'),'foo')
---
> ilib_for_link('foo','foo.o',[],'c');
> exec('loader.sce');
> chdir(dir);
108d105
< 
======================================================================
Index: linear/gschur.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/linear/gschur.man,v
retrieving revision 1.1
retrieving revision 1.3
diff -r1.1 -r1.3
4c4
< gschur - generalized Schur form (matrix pencils).
---
> gschur - generalized Schur form (obsolete).
13,31d12
< .TP 10
< A, E
< : two real square matrices
< .TP
< flag
< : character string (\fV'c'\fR or \fV'd'\fR)
< .TP
< extern
< : Scilab ``external'' function (usual case). Could be also a list or a character
< string
< .TP
< As,Es
< : two real square matrices
< .TP
< Q, Z
< : two non-singular real matrices
< .TP
< dim
< : integer (dimension of subspace)
32a14,17
> This function is obsolete and is now included in the \fVschur\fR
> function. In most cases the \fVgschur\fR function will still work as
> before, but it will be removed in the future release.
> 
34,48c19
< Schur form of matrix pencils (QZ algorithm):
< .nf
< [As,Es] = gschur(A,E)
< .fi
< produces a quasi triangular \fVAs\fR matrix
< and a triangular \fVEs\fR matrix which are the generalized
< Schur form of the pair \fVA, E\fR.
< .LP
< .nf
< [As,Es,Q,Z] = gschur(A,E)
< .fi
< returns in addition two unitary matrices
< \fVQ\fR and \fVZ\fR such that \fVAs=Q*A*Z\fR and \fVEs=Q*E*Z\fR. 
< .LP
< Ordered stable form:
---
> The first three syntaxes can be replaced by
50c21,40
< [As,Es,Z,dim] = gschur(A,E,'c')
---
> [As,Es]=schur(A,E)
> [As,Es,Q,Z]=schur(A,E);Q=Q' //NOTE THE TRANPOSITION HERE
> [As,Es,Z,dim] = schur(A,E,flag) 
> .fi
> The last syntax requires little more adaptations:
> .TP 3
> if
> extern is a scilab function  the new calling sequence should be
> \fV[As,Es,Z,dim]= schur(A,E,Nextern)\fR
> with Nextern defined as follow:
> 
> .nf
> function t=Nextern(R)
> if R(2)==0 then
>   t=extern([1,R(1),R(3)])==1
> else
>   c=(R(1)+%i*R(2))/R(3)
>   t=extern([2,real(c+c'),real(c*c')])==1
> end
> endfunction
52,93c42,58
< returns the real generalized
< Schur form of the pencil \fVs*E-A\fR. In addition, the dim first columns 
< of \fVZ\fR span a basis of the right eigenspace  associated with 
< eigenvalues with negative real parts (stable "continuous
< time" generalized eigenspace).
< .nf
< [As,Es,Z,dim] = gschur(A,E,'d')
< .fi
< returns the real generalized
< Schur form of the pencil \fVs*E-A\fR. In addition, the dim first columns 
< of \fVZ\fR make a basis of the right eigenspace  associated with 
< eigenvalues with magnitude lower than 1 (stable "discrete
< time" generalized eigenspace).
< .LP
< General subspace:
< .nf
< [As,Es,Z,dim] = gschur(A,E,extern)
< .fi
< returns the real generalized Schur form of the pencil \fVs*E-A\fR. 
< In addition, the dim first columns 
< of \fVZ\fR make a basis of the right eigenspace  associated with 
< eigenvalues of the pencil which are selected according to a
< rule which is given by the scilab function extern.
< (See \fVschur\fR for definition of this function).
< .SH EXAMPLE
< .nf
< s=%s;
< F=[-1,s,0,0;0,-1,0,0;0,0,2+s,0;0,0,0,-2+s];
< roots(det(F))
< [E,A]=pen2ea(F);
< [As,Es,Z,dim] = gschur(A,E,'c')
< // Other example
< a=rand(4,4);b=rand(4,4);[as,bs,qs,zs]=gschur(a,b);
< norm(qs*a*zs-as)
< norm(qs*b*zs-bs )
< clear a;
< a(8,8)=2;a(1,8)=1;a(2,[2,3,4,5])=[0.3,0.2,4,6];a(3,[2,3])=[-0.2,.3];
< a(3,7)=.5;
< a(4,4)=.5;a(4,6)=2;a(5,5)=1;a(6,6)=4;a(6,7)=2.5;a(7,6)=-10;a(7,7)=4;
< b=eye(8,8);b(5,5)=0;
< [al,be]=gspec(a,b);
< [bs,as,q,n]=gschur(b,a,'disc');n-4
---
> .TP
> if 
> extern is the name of an external function coded in Fortran or C
> the new calling sequence should be
> \fV[As,Es,Z,dim]= schur(A,E,'nextern')\fR
> with nextern defined as follow:
> .nf
>       logical function nextern(ar,ai,beta)
>       double precision ar,ai,beta
>       integer r,extern
>       if (ai.eq.0.0d0) then
>         r=extern(1,ar,beta,0.0d0,0.0d0)
>       else
>         r=extern(2,0.0d0,0.0d0,2.0d0*ar,ar*ar+ai*ai)
>       endif
>       nextern=r.eq.1
>       end
94a60
> 
96c62,63
< external, gspec, pencan, penlaur, coffg, kroneck
---
> external, schur
> 
======================================================================
Index: linear/gspec.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/linear/gspec.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
4c4
< gspec - eigenvalues of matrix pencil
---
> gspec - eigenvalues of matrix pencil (obsolete)
10,19c10
< .SH PARAMETERS
< .TP 10
< A, E
< : real square matrices
< .TP
< al, be
< : real vectors
< .TP
< Z
< : real square non-singular matrix
---
> 
21,30c12,14
< .Vb [al,be] = gspec(A,E) 
< returns the spectrum of the matrix pencil
< s E - A, i.e. the roots of the polynomial matrix s E - A.
< The eigenvalues are given by \fVal./be\fR and if \fVbe(i) = 0\fR the ith
< eigenvalue is at infinity. (For \fVE = eye(A), al./be\fR is \fVspec(A)\fR).
< .LP
< .Vb [al,be,Z] = gspec(A,E)
< returns in addition the matrix \fVZ\fR of generalized
< right eigenvectors of the pencil.
< .SH EXAMPLE
---
> 
> This function is now included in the \fVspec\fR function.
> the calling syntax must be replaced by
32,36c16,17
< A=rand(3,3);
< [al,be,Z] = gspec(A,eye(A));al./be
< clean(inv(Z)*A*Z)  //displaying the eigenvalues (generic matrix)
< A=A+%i*rand(A);E=rand(A);
< roots(det(%s*E-A))   //complex case
---
> [al,be]=spec(A,E)
> [al,be,Z]=spec(A,E)
39c20
< gschur, balanc, spec, kroneck
---
> spec
======================================================================
Index: linear/lu.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/linear/lu.man,v
retrieving revision 1.1
retrieving revision 1.3
diff -r1.1 -r1.3
11c11
< .TP
---
> .TP 2
13,16c13,20
< : real or complex square matrix (n x n).
< .TP 8
< L,U
< : two real or complex matrices  (n x n).
---
> : real or complex  matrix (m x n).
> .TP 
> L
> :  real or complex matrices  (m x min(m,n)).
> .TP 
> U
> : real or complex matrices  (min(m,n) x n ).
> 
24c28
< a permutation matrix E. 
---
> a permutation matrix \fVE\fR. 
34,39c38,40
< .SH REMARK
< 
< If \fVA\fR is a real matrix, using the function \fVlufact\fR and
< \frluget\fR it is possible to obtain the permutation matrices and also
< when \fVA\fR is not full rank the column compression of the matrix
< \fVL\fR.
---
> .SH REFERENCES
> lu decompositions are based on the Lapack routines
> DGETRF for  real matrices and  ZGETRF for the complex case.
41,47d41
< .nf 
< [h,rk]=lufact(sparse(a))  // lufact works with sparse real matrices 
< [P,L,U,Q]=luget(h)
< ludel(h)
< P=full(P);L=full(L);U=full(U);Q=full(Q); 
< // P,Q are permutation matrices P*L*U*Q=A 
< .fi 
======================================================================
Index: linear/qr.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/linear/qr.man,v
retrieving revision 1.1
retrieving revision 1.3
diff -r1.1 -r1.3
2d1
< .so ../sci.an
7,8c6,7
< [Q,R]=qr(X)
< [Q,R,E]=qr(X)
---
> [Q,R]=qr(X [,"e"])
> [Q,R,E]=qr(X [,"e"])
29c28
< : integer (QR-rank of \fVX*E\fR)
---
> : integer (QR-rank of \fVX\fR)
31c30,32
< .Vb [Q,R] = qr(X)
---
> .TP 1
> -
> \fV[Q,R] = qr(X)\fR
33,34c34,38
< the same dimension as \fVX\fR and a unitary matrix \fVQ\fR so that
< \fVX = Q*R\fR.
---
> the same dimension as \fVX\fR and an orthogonal (unitary in the complex case)
> matrix \fVQ\fR so that \fVX = Q*R\fR. \fV[Q,R] = qr(X,"e")\fR produces
> an "economy size": If \fVX\fR is m-by-n with m > n, then only the
> first n columns of \fVQ\fR  are computed as well as the first n rows
> of \fVR\fR.
36c40,49
< .Vb [Q,R,E] = qr(X)
---
> From \fVQ*R = X\fR , it follows that
> the kth column of the matrix \fVX\fR, is expressed as a linear combination
> of the k first columns of \fVQ\fR (with coefficients \fV R(1,k), ..., R(k,k) \fR). The  k first columns of \fVQ\fR make an orthogonal basis
> of the subspace spanned by the k first comumns of \fVX\fR. If column \fVk\fR
> of \fVX\fR (i.e. \fVX(:,k)\fR ) is a linear combination of the first 
> \fVp\fR columns of \fVX\fR, then the entries \fVR(p+1,k), ..., R(k,k)\fR
> are zero. It this situation, \fVR\fR is upper trapezoidal. If \fVX\fR has
> rank \fVrk\, rows \fVR(rk+1,:), R(rk+2,:), ...\fR are zeros.
> .TP
> \fV[Q,R,E] = qr(X)\fR
39,41c52,61
< a unitary \fVQ\fR so that \fVX*E = Q*R\fR.
< .LP
< .Vb [Q,R,rk,E] = qr(X ,tol) 
---
> an orthogonal (or unitary) \fVQ\fR so that \fVX*E = Q*R\fR.
> If \fVrk\fR is the rank of \fVX\fR, the \fVrk\fR first 
> entries along the main diagonal of \fVR\fR,
> i.e. \fVR(1,1), R(2,2), ..., R(rk,rk)\fR are all different
> from zero.  \fV[Q,R,E] = qr(X,"e")\fR produces
> an "economy size": If \fVX\fR is m-by-n with m > n, then only the
> first n columns of \fVQ\fR  are computed as well as the first n rows
> of \fVR\fR.
> .TP
> \fV[Q,R,rk,E] = qr(X ,tol)\FR
44,46c64,66
< larger than \fVtol\fR.
< .LP
< .Vb [Q,R,rk,E] = qr(X) 
---
> larger than a given threshold \fVtol\fR.
> .TP
> \fV[Q,R,rk,E] = qr(X) \FR
49c69,75
< larger than \fVR(1,1)*%eps*max(size(R)\fR.
---
> larger than \fVtol=R(1,1)*%eps*max(size(R))\fR.
> See \fVrankqr\fR for a rank revealing QR factorization, using the
> condition number of \fVR\fR.
> .SH REFERENCES
> qr decomposition are based  the Lapack routines
> DGEQRF, DGEQPF, DORGQR for the real matrices and  ZGEQRF, ZGEQPF,
> ZORGQR for the complex case.
51a78,88
> // QR factorization, generic case
> // X is tall (full rank)
> X=rand(5,2);[Q,R]=qr(X); [Q'*X R]
> //X is fat (full rank)
> X=rand(2,3);[Q,R]=qr(X); [Q'*X R]
> //Column 4 of X is a linear combination of columns 1 and 2:
> X=rand(8,5);X(:,4)=X(:,1)+X(:,2); [Q,R]=qr(X); R, R(:,4)
> //X has rank 2, rows 3 to $ of R are zero:
> X=rand(8,2)*rand(2,5);[Q,R]=qr(X); R
> //Evaluating the rank rk: column pivoting ==> rk first
> //diagonal entries of R are non zero :
58c95
< rank, svd, rowcomp, colcomp
---
> rankqr, rank, svd, rowcomp, colcomp
======================================================================
Index: linear/schur.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/linear/schur.man,v
retrieving revision 1.1
retrieving revision 1.5
diff -r1.1 -r1.5
4c4
< schur - [ordered] Schur decomposition
---
> schur - [ordered] Schur decomposition of matrix and pencils
8,9c8,15
< [U,dim]=schur(A,flag)
< [U,dim]=schur(A,myfunction)
---
> [U,dim [,T] ]=schur(A,flag)
> [U,dim [,T] ]=schur(A,extern1)
> 
> [As,Es [,Q,Z]]=schur(A,E)
> [As,Es [,Q],Z,dim] = schur(A,E,flag) 
> [Z,dim] = schur(A,E,flag) 
> [As,Es [,Q],Z,dim]= schur(A,E,extern2)
> [Z,dim]= schur(A,E,extern2)
12c18
< .TP 10
---
> .TP 8
14,15c20,23
< : real or complex matrix. For ordered forms \fVA\fR is
< assumed real.
---
> : real or complex square matrix. 
> .TP
> E 
> : real or complex square matrix with same dimensions as \fV A\fR. 
20,21c28,33
< myfunction
< : an ``external'' function (this parameter can also be a list or character string)
---
> extern1
> : an ``external'', see below
> .TP
> extern2
> : an ``external'', see below
> 
25a38,43
> Q
> : orthogonal or unitary square matrix
> .TP
> Z
> : orthogonal or unitary square matrix
> .TP
27c45,51
< : matrix
---
> : upper triangular or quasi-triangular square matrix
> .TP
> As
> : upper triangular or quasi-triangular square matrix
> .TP
> Es
> : upper triangular  square matrix
33,35c57,64
< .SH Usual schur form
< .Vb [U,T] = schur(A)
< produces a Schur matrix \fVT\fR
---
> .TP 1
> -
> MATRIX SCHUR FORM
> .RS
> .TP 8
> Usual
> schur form:
> \fV [U,T] = schur(A)\fR produces a Schur matrix \fVT\fR
44,45c73,77
< .SH Ordered stable form
< .Vb [U,dim]=schur(A,'c')
---
> .TP
> Ordered 
> Schur forms  
> .LP
> \fV[U,dim]=schur(A,'c')\fR
51c83
< .Vb [U,dim]=schur(A,'d')
---
>  \fV[U,dim]=schur(A,'d')\fR
56,57c88,89
< .SH General eigenspace
< .Vb [U,dim]=schur(A,a_function)
---
> .LP
>  \fV [U,dim]=schur(A,extern1)\fR
61,63c93,103
< selected by the function \fVa_function\fR.
< .LP
< This function must be of the following type (here \fVa_function\fR is "\fVrule\fR"):
---
> selected by the external function \fVextern1\fR (see external for details). 
> .RS
> .TP 3
> if
> \fVextern1\fR is described by a Scilab function, it should have the following
> calling sequence: \fVs=extern1(Ev)\fR, where Ev is an eigenvalue and
> \fVs\fR a boolean.
> .TP
> if
> \fVextern1\fR is described by a C or Fortran function it should have the following
> calling sequence:
65c105,136
< function [flag]=rule(x)
---
> int extern1(double *EvR, double *EvI)
> .fi
> where \fVEvR\fR and \fVEvI\fR are  eigenvalue real and complex parts.
> .RE
> a true or non zero returned value stands for selected eigenvalue.
> .RE
> .TP
> -
> PENCIL SCHUR FORMS
> .RS
> .TP 8
> Usual
> Pencil Schur form
> \fV[As,Es] = schur(A,E)\fR produces a quasi triangular \fVAs\fR matrix
> and a triangular \fVEs\fR matrix which are the generalized
> Schur form of the pair \fVA, E\fR.
> .LP
> \fV[As,Es,Q,Z] = schur(A,E)\fR
> returns in addition two unitary matrices
> \fVQ\fR and \fVZ\fR such that \fVAs=Q'*A*Z\fR and \fVEs=Q'*E*Z\fR. 
> .TP
> Ordered 
> Schur forms:
> .LP
> \fV[As,Es,Z,dim] = schur(A,E,'c')\fR
> returns the real generalized
> Schur form of the pencil \fVs*E-A\fR. In addition, the dim first columns 
> of \fVZ\fR span a basis of the right eigenspace  associated with 
> eigenvalues with negative real parts (stable "continuous
> time" generalized eigenspace).
> .LP
> \fV[As,Es,Z,dim] = schur(A,E,'d')\fR
67c138,144
< flag=...
---
> returns the real generalized
> Schur form of the pencil \fVs*E-A\fR. In addition, the dim first columns 
> of \fVZ\fR make a basis of the right eigenspace  associated with 
> eigenvalues with magnitude lower than 1 (stable "discrete
> time" generalized eigenspace).
> .LP
> \fV[As,Es,Z,dim] = schur(A,E,extern2)\fR
69,84c146,166
< \fVx\fR is a vector with three components which characterizes
< either a real eigenvalue or a pair of complex conjugate
< eigenvalues.
< .LP
< If \fVx(1)=1\fR, a real eigenvalue is considered and this
< eigenvalue is \fVx(2)/x(3)\fR.
< .LP
< If \fVx(1)=2\fR, a pair of complex conjugate eigenvalues is
< considered. The sum of these two eigenvalues (twice
< the real part) is \fVx(2)\fR and the product (squared magnitude)
< is \fVx(3)\fR.
< .LP
< On return, flag should be 1 if the real eigenvalue is 
< selected or the pair of eigenvalues is selected and
< 0 otherwise.
< .SH Example of function
---
> returns the real generalized Schur form of the pencil \fVs*E-A\fR. 
> In addition, the dim first columns 
> of \fVZ\fR make a basis of the right eigenspace  associated with 
> eigenvalues of the pencil which are selected according to a
> rule which is given by the function \fVextern2\fR. (see external
> for details)
> .RS
> .TP 3
> if 
> \fVextern2\fR is described by a Scilab function, it should have the
> following calling sequence: \fVs=extern2(Alpha,Beta)\fR, where
> \fVAlpha\fR and \fVBeta\fR defines a generalized eigenvalue and 
> \fVs\fR a boolean.
> .TP
> if
> \fVextern2\fR is described by a C or Fortran function it should have the following
> calling sequence:
> .nf
> int extern2(double *AlphaR, double *AlphaI, double *Beta)
> .fi
> if \fVA\fR and \fVE\fR are real and
86,96c168,170
<         function [flag]=disc(x)
<         ls =x(1);flag=0;
<         select  ls
<            case 1 then if abs(x(2)) < ro*abs(x(3)) then flag=1;end
<            case 2 then if x(3) < ro*ro then flag=1;end
<         end
< .fi
< The function \fVdisc\fR selects the eigenvalues with magnitude lower
< than a given scalar \fVro\fR. And for \fVro=1\fR the calling sequence
< \fV[U,dim]=schur(A,'d')\fR and \fV[U,dim]=schur(A,disc)\fR are
< equivalent.
---
> int extern2(double *AlphaR, double *AlphaI, double *BetaR, double *BetaI)
> .fi
> if \fVA\fR or \fVE\fR are complex.
98,99c172,181
< Another useful example is \fV%choose\fR 
< (see function code in \fVSCIDIR/macros/percent\fR)
---
>  \fVAlpha\fR, and \fVBeta\fR defines the generalized eigenvalue.
> .RE
> a true or non zero returned value stands for selected generalized eigenvalue.
> .RE
> .SH REFERENCES
> Matrix schur form computations are based on the Lapack routines DGEES
> and ZGEES.
> .LP
> Pencil schur form computations are based on the Lapack routines DGGES
> and ZGGES.
101a184,185
> //SCHUR FORM OF A MATRIX
> //----------------------
103,108c187,227
< [U,d]=schur(A,'c');
< A1=U'*A*U;
< spec(A1(1:d,1:d))      //stable cont. eigenvalues
< [U,d]=schur(A,'c');
< A1=U'*A*U;
< spec(A1(1:d,1:d))      //stable disc. eigenvalues
---
> [U,T]=schur(A);T
> 
> [U,dim,T]=schur(A,'c');
> T(1:dim,1:dim)      //stable cont. eigenvalues
> 
> function t=mytest(Ev),t=abs(Ev)<0.95,endfunction
> [U,dim,T]=schur(A,mytest);
> T(1:dim,1:dim)  
> 
> // The same function in C (a Compiler is required)
> C=['int mytest(double *EvR, double *EvI) {' //the C code
>    'if (*EvR * *EvR + *EvI * *EvI < 0.9025) return 1;'
>    'else return 0; }';]
> mputl(C,TMPDIR+'/mytest.c')
> link(G_make(TMPDIR+'/mytest.o','c'), 'mytest',"C")
> [U,dim,T]=schur(A,'mytest');
> //SCHUR FORM OF A PENCIL
> //----------------------
> F=[-1,%s, 0,   1;
>     0,-1,5-%s, 0;
>     0, 0,2+%s, 0;
>     1, 0, 0, -2+%s];
> A=coeff(F,0);E=coeff(F,1);
> [As,Es,Q,Z]=schur(A,E);
> Q'*F*Z //It is As+%s*Es
> 
> 
> [As,Es,Z,dim] = schur(A,E,'c')
> function t=mytest(Alpha,Beta),t=real(Alpha)<0,endfunction
> [As,Es,Z,dim] = schur(A,E,mytest)
> 
> //the same function in Fortran (a Compiler is required)
> ftn=['integer function mytest(ar,ai,b)' //the fortran code
>       'double precision ar,ai,b'
>       'mytest=0'
>       'if(ar.lt.0.0d0) mytest=1'
>       'end']
> mputl('      '+ftn,TMPDIR+'/mytest.f')
> link(G_make(TMPDIR+'/mytest.o'), 'mytest',"F")
> 
> [As,Es,Z,dim] = schur(A,E,'mytest')
111c230
< gschur, ricc, pbig, psmall
---
> spec, bdiag, ricc, pbig, psmall
======================================================================
Index: linear/spec.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/linear/spec.man,v
retrieving revision 1.1
retrieving revision 1.4
diff -r1.1 -r1.4
4c4
< spec - eigenvalues
---
> spec - eigenvalues of matrices and pencils
7a8,15
> [X,diagevals]=spec(A)
> 
> evals=spec(A,E)
> [al,be]=spec(A,E)
> [al,be,Z]=spec(A,E)
> [al,be]=spec(A,E)
> [al,be,Q,Z]=spec(A,E)
> 
13a22,24
> E
> : real or complex square matrix with same dimensions as \fV A\fR
> .TP
15c26,45
< : real or complex vector
---
> : real or complex vector, the eigenvalues
> .TP
> diagevals
> : real or complex diagonal matrix (eigenvalues along the diagonal)
> .TP
> al 
> : real or complex vector, al./be gives the eigenvalues
> .TP
> be 
> : real vector, al./be gives the eigenvalues
> .TP
> X
> : real or complex invertible square matrix, matrix eigenvectors.
> .TP
> Q
> : real or complex invertible square matrix, pencil left eigenvectors.
> .TP
> Z
> : real or complex invertible square matrix, pencil right eigenvectors.
> 
17,18c47,73
< .Vb evals=spec(A)
< returns in  vector \fVevals\fR the eigenvalues of \fVA\fR.
---
> .TP 10
> spec(A)
> :
> \fV evals=spec(A)\fR returns in  vector \fVevals\fR the eigenvalues of \fVA\fR.
> .LP
> \fV [evals,X] =spec(A)\fR returns in  addition the eigenvectors
> \fVA\fR (if they exist). See also \fVbdiag\fR
> .TP
> spec(A,B)
> :
> \fVevals=spec(A,E)\fR returns the spectrum of the matrix pencil
> s E - A, i.e. the roots of the polynomial matrix s E - A.
> .LP
> \fV[al,be] = spec(A,E)\fR returns the spectrum of the matrix pencil
> s E - A, i.e. the roots of the polynomial matrix s E - A.
> The eigenvalues are given by \fVal./be\fR and if \fVbe(i) = 0\fR the ith
> eigenvalue is at infinity. (For \fVE = eye(A), al./be\fR is \fVspec(A)\fR).
> .LP
> \fV [al,be,Z] = spec(A,E)\fR returns in addition the matrix \fVZ\fR of 
> generalized right eigenvectors of the pencil.
> 
> .LP
> \fV [al,be,Q,Z] = spec(A,E)\fR returns in addition the matrix \fVQ\fR
> and \fVZ\fR of generalized left and right eigenvectors of the pencil.
> .SH REFERENCES
> Matrix eigeinvalues computations are based on the Lapack routines DGEEV
> and ZGEEV.
20c75,76
< Eigenvectors are obtained by \fVbdiag\fR.
---
> Pencil eigeinvalues computations are based on the Lapack routines DGGEV
> and ZGGEV.
22a79
> // MATRIX EIGENVALUES
30,31c87
< [Ab,X,bs]=bdiag(A);
< Ab
---
> [S,X]=bdiag(A);
32a89,97
> 
> // PENCIL EIGENVALUES
> A=rand(3,3);
> [al,be,Z] = spec(A,eye(A));al./be
> clean(inv(Z)*A*Z)  //displaying the eigenvalues (generic matrix)
> A=A+%i*rand(A);E=rand(A);
> roots(det(%s*E-A))   //complex case
> 
> 
35c100
< poly, det, gspec, schur, bdiag, colcomp
---
> poly, det, schur, bdiag, colcomp
======================================================================
======================================================================
======================================================================
Index: linear/svd.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/linear/svd.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
9c9,10
< [U,S,V]=svd(X,0)
---
> [U,S,V]=svd(X,0) (obsolete)
> [U,S,V]=svd(X,"e")
35c36,39
< .Vb [U,S,V] = svd(X,0) produces the "economy size"
---
> .Vb [U,S,V] = svd(X,"e")
> or 
> .Vb [U,S,V] = svd(X,0)
>  produces the "economy size"
46a51,54
> .SH REFERENCES
> svd decompositions are based on  the Lapack routines
> DGESVD for  real matrices and  ZGESVD for the complex case.
> 
======================================================================
Index: metanet/mesh2d.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/metanet/mesh2d.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
134a135,150
> 
> //An example with a random set of points
> function []=test(X,Y)
>   Tr=mesh2d(X,Y);
>   plot2d(X,Y,[-1,-2,3]);
>   [m,n]=size(Tr);
>   xpols= matrix(X(Tr),m,n); 
>   ypols= matrix(Y(Tr),m,n);
>   xset("colormap",rand(2*n,3)); 
>   xfpolys(xpols,ypols,[n/4:n/4+n-1]);
> endfunction 
> N=1000;xbasc();X=rand(1,N); Y=rand(1,N);
> xset("wdim",700,700);
> test(X,Y);
> xset('default');
> 
======================================================================
Index: nonlinear/derivative.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/nonlinear/derivative.man,v
retrieving revision 1.1
retrieving revision 1.3
diff -r1.1 -r1.3
1,2c1
< .TH derivative 1 "April 1993" "Scilab Group" "Scilab Function"
< .so ../sci.an 
---
> .TH derivative  "Scilab Function"
4,5c3,4
< derivative- approximate derivative
< .SH CALLING SEQUENCE
---
> derivative - approximate derivatives of a function
> .SH CALLING SEQUENCES
7,8c6,7
< J=derivative(f,x0,h)
< [J,J2]=derivative(f,x0,h)
---
> derivative(F,x)
> [J [,H]] = derivative(F,x [,h ,order ,H_form ,Q])
11,13d9
< .TP 10
< f
< : Scilab function \fVf: R^n --> R^p\fR 
15,16c11,14
< x0  
< : real column vector (of dimension n)
---
> F         
> : a Scilab function F: R^n --> R^m or a list(F,p1,...,pk),
> where F is a scilab function in the form y=F(x,p1,...,pk),
> p1, ..., pk being any scilab objects (matrices, lists,...).
18,19c16,17
< h
< : (small) positive real number (default is 1.d-7)
---
> x         
> : real column vector of dimension n.
21,22c19,20
< J
< : real p x n Jacobian matrix 
---
> h         
> : (optional) real, the stepsize used in the finite difference approximations.
24,25c22,53
< J2 
< : real p x (p*n)  matrix
---
> order     
> : (optional) integer, the order of the finite difference formula
> used to approximate the derivatives (order = 1,2 or 4, default is order=2 ).
> .TP
> H_form    
> : (optional) string, the form in which the Hessean will be returned.
> Possible forms are:
> .RS
> .TP
> H_form='default'  
> : H is a m x (n^2) matrix ; in this form, the k-th row of H 
> corresponds to the Hessean of the k-th component of F, given 
> as the following row vector :
> .nf
> 
>   [ d(grad(F_k))/dx_1 | ..... | d(grad(F_k))/dx_n ] 
> 
> .fi
> ((grad(F_k) being a row vector).
> .TP
> H_form='blockmat' : 
> H is a m x (nxn) block matrix : the classic Hessean matrices
> (of each component of F) are stacked by row (H = [H1 ; H2 ; ... ; Hm]
> in scilab syntax).
> .TP
> H_form='hypermat' : 
> H is a n x n matrix for m=1, and a n x n x m hypermatrix otherwise. 
> H(:,:,k) is the classic Hessean matrix of the k-th component of F.
> .RE
> .TP
> Q         
> : (optional) real matrix, orthogonal (default is eye(n,n)). 
27c55,62
< Approximate derivatives of a function f: \fVR^n --> R^p\fR.
---
> Numerical approximation of the first and second derivatives of a function
> F: R^n --> R^m at the point x. The Jacobian is computed  by approximating
> the directional derivatives of the components of F in the direction of 
> the columns of Q. 
> (For m=1, v=Q(:,k) : grad(F(x))*v = Dv(F(x)).)
> The second derivatives are computed by composition of first order derivatives.
> If H is given in its default form the Taylor series of F(x) up to terms of second 
> order is given by :
29,30c64,66
< f(x) = f(x0) + D1f(x0) *dx + 1/2* D2f(x0) *(dx.*.dx) +...
< J = D1f(x0) ; J2=D2f(x0)
---
> 
>   F(x+dx) = F(x) + J(x)*dx + 1/2*H(x)*(dx .*. dx) + ...
> 
32,34c68,78
< Derivatives are evaluated by finite difference:f_i(x+h)-f_i(x))/h.
< Caution: h should be carefully chosen...
< .SH EXAMPLE
---
> (([J,H]=derivative(F,x,H_form='default'), J=J(x), H=H(x).) 
> .SH REMARKS
> Numerical approximation of derivatives is generally an unstable process. 
> The step size h must be small to get a low error but if it is too small floating 
> point errors will dominate by cancellation. As a rule of thumb don't change the 
> default step size. 
> To work around numerical difficulties one may also change the order and/or choose
> different orthogonal matrices Q (the default is eye(n,n)), especially if the 
> approximate derivatives are used in optimization routines.
> All the optional arguments may also be passed as named arguments, so that
> one can use calls in the form :
36,39c80,82
< deff('y=f(x)','y=[sin(x(1))*cos(x(2));x(1)^2*x(2)^2;1+x(1)*x(2)^2]')
< x0=[1;2];eps=0.001;h=eps*[2;5];
< [J,J2]=derivative(f,x0);
< [f(x0+h)-f(x0)-J*h ,0.5*J2*(h.*.h)]
---
> derivative(F, x, H_form = "hypermat")
> derivative(F, x, order = 4) etc.
> 
41,42c84,93
< .SH SEE ALSO
< mtlb_diff, derivat
---
> .SH AUTHORS
> Rainer von Seggern, Bruno Pincon
> .SH EXAMPLES
> .nf
>   function y=F(x)
>    y=[sin(x(1)*x(2))+exp(x(2)*x(3)+x(1)) ; sum(x.^3)];
>  endfunction
>  function y=G(x,p) 
>    y=[sin(x(1)*x(2)*p)+exp(x(2)*x(3)+x(1)) ; sum(x.^3)];
>  endfunction
43a95,97
>  x=[1;2;3];[J,H]=derivative(F,x,H_form='blockmat');
>  disp(J)
>  disp(H)
44a99,106
>  n=3;
>  // form an orthogonal matrix :   
>  nu=0; while nu<n, [Q,nu]=colcomp(rand(n,n)); end  
>  for i=[1,2,4]
>     [J,H]=derivative(F,x,order=i,H_form='blockmat',Q=Q);
>     mprintf("order= %d \\n",i);
>     disp(H);
>  end
45a108,138
>  p=1;h=1e-3;
>  [J,H]=derivative(list(G,p),x,h,2,H_form='hypermat');
>  disp(H);
>  [J,H]=derivative(list(G,p),x,h,4,Q=Q);
>  disp(H)
> 
>  // Taylor series example:
>  dx=1e-3*[1;1;-1];
>  [J,H]=derivative(F,x);
>  F(x+dx)
>  F(x+dx)-F(x)
>  F(x+dx)-F(x)-J*dx
>  F(x+dx)-F(x)-J*dx-1/2*H*(dx .*. dx)
> 
>  // A trivial example
>  function y=f(x,A,p,w), y=x'*A*x+p'*x+w; endfunction
>  // with Jacobian and Hessean given by J(x)=x'*(A+A')+p', and H(x)=A+A'.
>  A = rand(3,3); p = rand(3,1); w = 1;
>  x = rand(3,1);
>  [J,H]=derivative(list(f,A,p,w),x,h=1,H_form='blockmat')
>  // Since f(x) is quadratic in x, approximate derivatives of order=2 or 4 by finite
>  // differences should be exact for all h~=0. The apparent errors are caused by
>  // cancellation in the floating point operations, so a "big" h is choosen.
>  // Comparison with the exact matrices:
>  Je = x'*(A+A')+p'
>  He = A+A'
>  clean(Je - J)
>  clean(He - H)
> .fi
> .SH SEE ALSO
> SSCI/macros/optim/numdiff.sci, derivat
======================================================================
Index: nonlinear/int3d.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/nonlinear/int3d.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
116d115
< deff('v=f(xyz,numfun)','v=exp(xyz''*xyz)')
119a119,142
> 
> 
> //integration over a cube  -1<=x<=1;-1<=y<=1;-1<=z<=1
> 
> //  bottom  -top-     right    -left-   front   -rear- 
> X=[ 0, 0,    0, 0,    0, 0,    0, 0,    0, 0,    0, 0;          
>    -1,-1,   -1,-1,    1, 1,   -1,-1,   -1,-1,   -1,-1; 
>     1,-1,    1,-1,    1, 1,   -1,-1,    1,-1,    1,-1;     
>     1, 1,    1, 1,    1, 1,   -1,-1,    1, 1,    1, 1];         
> Y=[ 0, 0,    0, 0,    0, 0,    0, 0,    0, 0,    0, 0; 
>    -1,-1,   -1,-1,   -1, 1,   -1, 1,   -1,-1,    1, 1;
>    -1, 1,   -1, 1,    1, 1,    1, 1,   -1,-1,    1, 1;   
>     1, 1,    1, 1,   -1,-1,   -1,-1,   -1,-1,    1, 1]; 
> Z=[ 0, 0,    0, 0,    0, 0,    0, 0,    0, 0,    0, 0;
>    -1,-1,    1, 1,   -1, 1,   -1, 1,   -1,-1,   -1,-1; 
>    -1,-1,    1, 1,   -1,-1,   -1,-1,   -1, 1,   -1, 1;  
>    -1,-1,    1, 1,    1,-1,    1,-1,    1, 1,    1, 1];      
> 
> function v=f(xyz,numfun),v=exp(xyz'*xyz),endfunction
> [result,err]=int3d(X,Y,Z,f,1,[0,100000,1.d-5,1.d-7])
> 
> function v=f(xyz,numfun),v=1,endfunction
> [result,err]=int3d(X,Y,Z,f,1,[0,100000,1.d-5,1.d-7])
> 
122c145
< intc, intl, int3d
---
> intc, intl, int2d
124c147
< Fortran routine dqtet.f
---
> Fortran routine dcutet.f
======================================================================
Index: nonlinear/leastsq.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/nonlinear/leastsq.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
91,92c91,93
< is an "external" i.e function, or list or Fortran routine (see "external").
< This external must return (\fVf(x)\fR) for a given \fVx\fR.
---
> is an "external" i.e function, or list or C or Fortran routine (see "external").
> This external must return a vector \fVf\fR such 
> as (\fVf(j)=fj(x)\fR) for a given \fVx\fR. 
107,108c108,119
< Here, the generic calling sequence for the Fortran subroutine is: 
< \fVsubroutine fun(m,n,x,td,f)\fR
---
> Here, the generic calling sequence is: 
> In Fortran
> .nf
>       subroutine fun(n,m,x,td,f)
>       integer n,m
>       double precision x(n), td(*), f(m)
> .fi
> In C
> .nf
>       void fun(int *n,int *m, double *x,double *params, double *f)
> .fi
> 
135,138c146,147
< which must be linked to Scilab. 
< .LP
< Here, the generic calling sequence for the Fortran subroutine is: 
< \fVsubroutine dfun(m,n,x,td,g)\fR
---
> which must be linked to Scilab. This function has the same calling
> sequence as  \fVfun\fR
======================================================================
Index: nonlinear/linpro.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/nonlinear/linpro.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
31c31
< large negative  number (e.g. \fVci(j) = -(% eps)^(-1)\fR.
---
> large negative  number (e.g. \fVci(j) = -number_properties('huge')\fR.
======================================================================
Index: nonlinear/optim.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/nonlinear/optim.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
14,15c14,16
< : external, i.e Scilab function or string (\fVcostf\fR is the cost function: see below its
< calling sequence (Scilab or Fortran)).
---
> : external, i.e Scilab function list or string (\fVcostf\fR is the
> cost function: see below its calling sequence (Scilab or
> Fortran)). See also external for details about external functions.
173c174
< external, quapro, linpro, datafit, leastsq
---
> external, quapro, linpro, datafit, leastsq, numdiff
======================================================================
Index: programming/equal.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/programming/equal.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
5a6,7
> .TP 2
> -
7,9c9,55
< .LP
< == denote equality comparison between two expressions and returns a boolean
< matrix.
---
> .TP
> -
>  \fV a == b\fR  denotes equality comparison between  expressions \fV a\fR
> and \fV b\fR:
> .RS
> .TP 5
> With 
> matrix objects,
> .RS
> .TP 3
> If
> \fV a\fR and \fV b\fR are matrices with same types and identical
> dimensions, the comparison is performed element by element and the
> result is a matrix of booleans.
> .TP
> If 
> \fV a\fR and \fV b\fR are matrices with same types, but \fV a\fR or
> \fV b\fR is a 1 by 1 matrix the scalar is compared with each element
> of the matrix. The result is a matrix of booleans. 
> .TP
> In
> The others cases the result is the boolean \fV %f\fR 
> .RE
> .TP
> With 
> list objects,
> .RS
> .TP 3
> If
> \fV a\fR and \fV b\fR are lists with  identical
> sizes, the comparison is performed element by element and and
> recursively. The result is a row vector of booleans.
> .TP
> If 
> \fV a\fR and \fV b\fR are lists with non equal sizes the result is the
> boolean \fV %f\fR.
> .RE
> .TP
> With 
> tlist and mlist object. If no overloading function is defined the \fV list\fR
> comparison method is used.
> .TP
> With
> other data types (functions, libraries,...) , the result is \fV %t\fR if the
> objects are identical and \fV %f\fR in the other case.
> .RE
> Comparison between different data types returns \fV %f\fR.
18c64
< less, boolean
---
> less, boolean, isequal
======================================================================
Index: programming/find.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/programming/find.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
7,8c7,8
< [ii]=find(x)
< [ir,ic]=find(x)
---
> [ii]=find(x [,nmax])
> [ir,ic]=find(x [,nmax])
13a14,18
> .TP
> nmax
> : an integer giving the maximum number of indices to return. The
> default value is -1 which stands for "all". This option can be used
> for efficiency, to avoid searching all indices.
======================================================================
Index: programming/format.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/programming/format.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
47c47
< format()
---
> format("v")
======================================================================
Index: programming/lasterror.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/programming/lasterror.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
8a9
> [str,n,line,func]=lasterror([opt])
13c14,15
< : vector of character strings or an empty matrix. The last
---
> : 
> vector of character strings or an empty matrix. The last
17c19,29
< : integer, 0 or the last recorded error number.
---
> : 
> integer, 0 or the last recorded error number.
> .TP
> line 
> : 
> integer, 0 or the last recorded function line number.
> .TP
> func 
> : 
> string,the last recorded function name
> 
20c32,33
< : boolean, if %t recorded message is cleared. Default is %t.
---
> : 
> boolean, if %t recorded message is cleared. Default is %t.
24c37,38
< function allows to get the message and the error number out of these
---
> function allows to get the message,  the error number, the current
> function (if any) and the current line of the current function out of these
======================================================================
Index: programming/overloading.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/programming/overloading.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
41a42
> compiled function @mc
55a57
> .LA  compiled function&mc\\ \hfill
======================================================================
Index: pvm/pvm_barrier.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/pvm/pvm_barrier.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
4,5c4
< pvm_barrier - blocks the calling process until all processes
< in a group have called it.
---
> pvm_barrier - blocks the calling process until all processes in a group have called it.
22,26c21,22
< \fVpvm_barrier\fR blocks the calling process until
< .I count
< members of the
< .I group
< have called pvm_barrier.
---
> \fVpvm_barrier\fR blocks the calling process until \fVcount\fR
> members of the \fVgroup\fR have called pvm_barrier.
======================================================================
Index: pvm/pvm_parent.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/pvm/pvm_parent.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
4,5c4
< pvm_parent - returns the tid of the process that spawned
< the calling process.
---
> pvm_parent - tid of the process that spawned the calling process.
17,19c16
< returns the
< .I tid
< of the process
---
> returns the \fVtid\fR of the process
22,24c19
< not created with pvm_spawn, then
< .I tid
< is set to
---
> not created with pvm_spawn, then \fVtid\fR is set to
26d20
< 
======================================================================
Index: pvm/pvm_tasks.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/pvm/pvm_tasks.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
4,5c4
< pvm_tasks - returns information about the tasks running
< on the virtual machine.
---
> pvm_tasks - information about the tasks running on the virtual machine.
8c7
< res  = pvm_tasks([where 0])
---
> res  = pvm_tasks([where])
12,13c11,12
< where (optional)
< : integer, specifying what tasks to return information about.
---
> where 
> : (optional) integer, specifying what tasks to return information about.
15d13
< .ta 0.5i 1.5i
17d14
< 
22,24c19,26
< .IP res,  list of 7 elements such that:
< .br
< .IP res(1): 
---
> .TP 
> res
> : 
> list of 7 elements such that:
> .RS
> .TP 6
> res(1)
> : 
26,27c28,30
< .br
< .IP res(2): 
---
> .TP
> res(2)
> : 
29,30c32,35
< .br
< .IP res(3): 
---
> 
> .TP 
> res(3)
> : 
32,33c37,40
< .br
< .IP res(4): 
---
> 
> .TP 
> res(4)
> : 
35,36c42,45
< .br
< .IP res(5): 
---
> 
> .TP 
> res(5)
> : 
39,40c48,50
< .br
< .IP res(6): 
---
> .TP 
> res(6)
> : 
42,43c52,54
< .br
< .IP res(7): 
---
> .TP 
> res(7)
> : 
45c56
< 
---
> .RE
97c108
< .SH SEE ALS
---
> .SH SEE ALSO
======================================================================
Index: translation/mfile2sci.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/translation/mfile2sci.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
111c111
< write(TMPDIR+'rot90.m',['function B = rot90(A,k)'
---
> write(TMPDIR+'/rot90.m',['function B = rot90(A,k)'
133c133
< mfile2sci(TMPDIR+'rot90.m',TMPDIR)
---
> mfile2sci(TMPDIR+'/rot90.m',TMPDIR)
135c135
< write(%io(2),read(TMPDIR+'rot90.sci',-1,1,'(a)'))
---
> write(%io(2),read(TMPDIR+'/rot90.sci',-1,1,'(a)'))
137c137
< getf(TMPDIR+'rot90.sci')
---
> getf(TMPDIR+'/rot90.sci')
======================================================================
Index: utilities/hex2dec.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/utilities/hex2dec.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
3a4
> .nf
4a6,8
> oct2dec -   converts octal representation of integers to numbers
> base2dec -   converts base b representation of integers to numbers
> .fi
7a12,13
> d=oct2dec(o)
> d=base2dec(s,b)
15c21,35
< : matrix of character strings corresponding to hexadecimal representation
---
> : matrix of character strings corresponding to hexadecimal
> representation
> .TP
> o
> : matrix of character strings corresponding to octal
> representation
> .TP
> s
> : matrix of character strings corresponding to base b
> representation
> .TP
> b
> : integer, the base
> 
> 
17c37,45
< \fVhex2dec(x)\fR returns the  matrix of numbers corresponding to the  hexadecimal representation.
---
> \fVhex2dec(x)\fR returns the  matrix of numbers corresponding to the
> hexadecimal representation.
> .LP
> \fVoct2dec(x)\fR returns the  matrix of numbers corresponding to the
> octal representation.
> .LP
> \fVbase2dec(x,b)\fR returns the  matrix of numbers corresponding to the
> base \fVb\fR representation.
> 
======================================================================
Index: utilities/ilib_build.man
===================================================================
RCS file: /usr/local/cvsroot/scilab/man/utilities/ilib_build.man,v
retrieving revision 1.1
retrieving revision 1.2
diff -r1.1 -r1.2
7c7
< ilib_build(lib_name,table,files,libs [,makename])
---
> ilib_build(lib_name,table,files,libs [,makename,ldflags,cflags,fflags])
26a27,30
> .TP 
> ldflags,cflags,fflags 
> : character strings to provide options for the loader, the C compiler
> and the Fortran compiler. 
