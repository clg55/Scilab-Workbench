<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE MAN SYSTEM "../../manrev.dtd">
<MAN>
  <LANGUAGE>eng</LANGUAGE>
  <TITLE>optim</TITLE>
  <TYPE>Scilab Function</TYPE>
  <DATE>April 1993</DATE>
  <SHORT_DESCRIPTION name="optim"> non-linear optimization routine</SHORT_DESCRIPTION>
  <CALLING_SEQUENCE>
    <CALLING_SEQUENCE_ITEM>[f,xopt]=optim(costf,x0)  </CALLING_SEQUENCE_ITEM>
    <CALLING_SEQUENCE_ITEM>[f,[xopt,[gradopt,[work]]]]=optim(costf,[contr],x0,['algo'],[df0,[mem]],  </CALLING_SEQUENCE_ITEM>
    <CALLING_SEQUENCE_ITEM>     [work],[stop],['in'],[imp=iflag])  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
        <PARAM_NAME>costf</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: external, i.e Scilab function list or string (<VERB>costf</VERB> is the cost function: see below its calling sequence (Scilab or Fortran)). See also external for details about external functions.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>x0</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: real vector (initial value of variable to be minimized).</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>f</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: value of optimal cost (<VERB>f=costf(xopt)</VERB>)</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>xopt</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: best value of <VERB>x</VERB> found.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>contr</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: <VERB>'b',binf,bsup</VERB>  with <VERB>binf</VERB> and <VERB>bsup</VERB> real vectors with same dimension as <VERB>x0</VERB>. <VERB>binf</VERB> and <VERB>bsup</VERB> are lower and upper bounds on <VERB>x</VERB>.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>&quot;algo&quot;  </PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: <VERB>'qn'</VERB> or <VERB>'gc'</VERB> or <VERB>'nd'</VERB> . This string stands for quasi-Newton (default),  conjugate gradient or non-differentiable respectively.  Note that <VERB>'nd'</VERB> does not accept bounds on <VERB>x</VERB> ).</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>df0</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: real scalar. Guessed decreasing of <VERB>f</VERB> at first iteration. (<VERB>df0=1</VERB> is the default value).</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>mem :  </PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>integer, number of variables used to approximate the  Hessian, (<VERB>algo='gc' or 'nd'</VERB>). Default value is around 6.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>stop</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>:  sequence of optional parameters controlling the  convergence of the algorithm. <VERB>             stop=  'ar',nap, [iter [,epsg [,epsf [,epsx]]]]</VERB></SP>
          <PARAM_INDENT>
            <PARAM_ITEM>
              <PARAM_NAME>&quot;ar&quot;  </PARAM_NAME>
              <PARAM_DESCRIPTION>
                <SP>: reserved keyword for stopping rule selection defined as follows:</SP>
              </PARAM_DESCRIPTION>
            </PARAM_ITEM>
            <PARAM_ITEM>
              <PARAM_NAME>nap</PARAM_NAME>
              <PARAM_DESCRIPTION>
                <SP>: maximum number of calls to <VERB>costf</VERB> allowed.</SP>
              </PARAM_DESCRIPTION>
            </PARAM_ITEM>
            <PARAM_ITEM>
              <PARAM_NAME>iter</PARAM_NAME>
              <PARAM_DESCRIPTION>
                <SP>: maximum number of iterations allowed.</SP>
              </PARAM_DESCRIPTION>
            </PARAM_ITEM>
            <PARAM_ITEM>
              <PARAM_NAME>epsg</PARAM_NAME>
              <PARAM_DESCRIPTION>
                <SP>: threshold on gradient norm.</SP>
              </PARAM_DESCRIPTION>
            </PARAM_ITEM>
            <PARAM_ITEM>
              <PARAM_NAME>epsf</PARAM_NAME>
              <PARAM_DESCRIPTION>
                <SP>: threshold controlling decreasing of <VERB>f</VERB></SP>
              </PARAM_DESCRIPTION>
            </PARAM_ITEM>
            <PARAM_ITEM>
              <PARAM_NAME>epsx</PARAM_NAME>
              <PARAM_DESCRIPTION>
                <SP>: threshold controlling variation of <VERB>x</VERB>. This vector (possibly matrix) of same size as <VERB>x0</VERB> can be used to scale <VERB>x</VERB>.</SP>
              </PARAM_DESCRIPTION>
            </PARAM_ITEM>
          </PARAM_INDENT>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>&quot;in&quot;  </PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: reserved  keyword for initialization of parameters used when <VERB>costf</VERB> in given as a Fortran routine (see below).</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>&quot;imp=iflag&quot;  </PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: named argument used to set the trace mode. <VERB>iflag=0</VERB> nothing (execpt errors) is reported, <VERB>iflag=1</VERB> initial and final reports, <VERB>iflag=2</VERB> adds a report per iteration, <VERB>iflag&gt;2</VERB> add reports on linear search. Warning, most of these reports are written on the Scilab standard output.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>gradopt</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>:  gradient of <VERB>costf</VERB> at <VERB>xopt</VERB></SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>work</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: working array for hot restart for quasi-Newton method. This array is automatically initialized by <VERB>optim</VERB> when <VERB>optim</VERB> is invoked. It can be used as input parameter to  speed-up the calculations.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
  <DESCRIPTION>
    <P>
    Non-linear optimization routine for programs without constraints or with bound constraints:</P>
    <VERBATIM>
<![CDATA[
min costf(x) w.r.t x.
   ]]>
    </VERBATIM>
    <P><VERB>costf</VERB> is an &quot;external&quot; i.e function, or list or Fortran routine (see &quot;external&quot;).
    This external must return <VERB>f</VERB> (<VERB>costf(x)</VERB>) and <VERB>g</VERB> (gradient of <VERB>costf</VERB>)
    given <VERB>x</VERB>.</P>
    <P>
    If <VERB>costf</VERB> is a function, the calling sequence for <VERB>costf</VERB> must be:</P>
    <VERBATIM>
<![CDATA[
[f,g,ind]=costf(x,ind).
   ]]>
    </VERBATIM>
    <P>
    Here, <VERB>costf</VERB> is a function which returns <VERB>f</VERB>, value (real number) of
    cost function at <VERB>x</VERB>, and <VERB>g</VERB>, gradient vector of cost function at <VERB>x</VERB>.
    The variable <VERB>ind</VERB> is used by <VERB>optim</VERB> and is described below.</P>
    <P>
    If <VERB>ind=2</VERB> (resp. <VERB>3, 4</VERB>), <VERB>costf</VERB> must provide <VERB>f</VERB> (resp. <VERB>g, f</VERB> and <VERB>g</VERB>).</P>
    <P>
    If <VERB>ind=1</VERB> nothing is computed (used for display purposes only).</P>
    <P>
    On output, <VERB>ind&lt;0</VERB>  means that <VERB>f</VERB> cannot be evaluated at <VERB>x</VERB> and
    <VERB>ind=0</VERB> interrupts the optimization.</P>
    <P>
    If <VERB>costf</VERB> is a character string, it refers to the name of a Fortran routine
    which must be linked to Scilab (see examples in the routines <VERB>foptim.f</VERB> 
    and e.g. <VERB>genros.f</VERB> in the directory SCIDIR/default)</P>
    <P>
    Dynamic link of Fortran routine is also possible (help <VERB>link</VERB>).</P>
    <P>
    Here, the generic calling sequence for the Fortran subroutine is: 
    <VERB>function costf(ind,n,x,f,g,ti,tr,td)</VERB></P>
    <P><VERB>ind</VERB> has the same meaning as above if set to <VERB>0,1,2</VERB> but the 
    values <VERB>ind=10</VERB> and <VERB>ind=11</VERB> are now valid. 
    These values are used for initializations (see below).</P>
    <P><VERB>n</VERB> is the dimension of <VERB>x</VERB>, <VERB>x</VERB> is an <VERB>n</VERB> vector, 
    <VERB>ti,tr,td</VERB> are working arrays.</P>
    <P>
    The Fortran function <VERB>costf</VERB> must return <VERB>f</VERB> and the vector <VERB>g</VERB>,
    given <VERB>x, ind, n, ti, tr, td</VERB>.</P>
    <P>
    If <VERB>costf</VERB> is given as a Fortran routine, it is possible to initialize
    parameters or to send Scilab variables to this routine.</P>
    <P>
    This facility is managed by the parameter <VERB>'in</VERB>.</P>
    <P>
    If the string <VERB>'in'</VERB> is present, initialization is done by Fortran:
    <VERB>optim</VERB> makes two calls to the Fortran function <VERB>costf</VERB>, once with
    <VERB>ind=10</VERB> and once with <VERB>ind=11</VERB>. In this case, for <VERB>ind=10</VERB>,
    <VERB>costf</VERB> must set the dimensions <VERB>nti, ntr, ntd</VERB> of <VERB>ti, tr, td</VERB> 
    in the <VERB>common/nird/nti, ntr, ntd</VERB> and, for <VERB>ind=11</VERB>, <VERB>costf</VERB>
    must initialize the vectors <VERB>ti , tr, td</VERB> (integer vector, real vector,
    double precision vector respectively).</P>
    <P>
    In the calling sequence of <VERB>optim</VERB>, the string <VERB>'in'</VERB> can be 
    replaced by <VERB>'ti', valti ,'td' , valtd</VERB>. Then, the Fortran function
    <VERB>costf(ind, x, f, g, ti, tr, td)</VERB> is evaluated with <VERB>ti=valti</VERB>
    and <VERB>td=valtd</VERB> whatever the value of <VERB>ind</VERB>.
    Thus, the Scilab variables <VERB>valti</VERB> and <VERB>valtd</VERB> (integer vector and
    real vector) are sent to the Fortran function <VERB>costf</VERB>.</P>
    <P>
    It is also possible to save the content of of the working arrays
    <VERB>ti</VERB> and <VERB>td</VERB>. This is possible by adding the strings 'si' and/or 'sd'
    at the ned of the calling sequence of <VERB>optim</VERB>.
    Then, the output variables must be: <VERB>[f,[x,[g],[to]]],[ti],[td]]</VERB>.</P>
  </DESCRIPTION>
  <EXAMPLE>
<![CDATA[
xref=[1;2;3];x0=[1;-1;1]
deff('[f,g,ind]=cost(x,ind)','f=0.5*norm(x-xref)^2,g=x-xref');
[f,xopt]=optim(cost,x0)      //Simplest call
[f,xopt,gopt]=optim(cost,x0,'gc')  // By conjugate gradient
[f,xopt,gopt]=optim(cost,x0,'nd')  //Seen as non differentiable
[f,xopt,gopt]=optim(cost,'b',[-1;0;2],[0.5;1;4],x0) //  Bounds on x
[f,xopt,gopt]=optim(cost,'b',[-1;0;2],[0.5;1;4],x0,'gc') //  Bounds on x
[f,xopt,gopt]=optim(cost,'b',[-1;0;2],[0.5;1;4],x0,'gc','ar',3)
// Here, 3 calls to cost are allowed.
// Now calling the Fortran subroutine "genros" in SCIDIR/default/Ex-optim.f
// See also the link function for dynamically linking an objective function
[f,xopt,gopt]=optim('genros',[1;2;3])    //Rosenbrock's function
   ]]>
  </EXAMPLE>
  <SEE_ALSO>
    <SEE_ALSO_ITEM>
      <LINK>external</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>quapro</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>linpro</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>datafit</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>leastsq</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>numdiff</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>derivative</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>NDcost</LINK>
    </SEE_ALSO_ITEM>
  </SEE_ALSO>
</MAN>
