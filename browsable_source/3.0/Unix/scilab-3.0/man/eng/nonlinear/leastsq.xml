<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE MAN SYSTEM "../../manrev.dtd">
<MAN>
  <LANGUAGE>eng</LANGUAGE>
  <TITLE>leastsq</TITLE>
  <TYPE>Scilab Function</TYPE>
  <DATE>April 1999</DATE>
  <SHORT_DESCRIPTION name="leastsq"> 
    Solves non-linear least squaresproblems  
  </SHORT_DESCRIPTION>
  <CALLING_SEQUENCE>
    <CALLING_SEQUENCE_ITEM>[f,xopt]=leastsq([imp,] fun [,Dfun],x0)  </CALLING_SEQUENCE_ITEM>
    <CALLING_SEQUENCE_ITEM>[f,[xopt,[gradopt]]]=leastsq(fun [,Dfun],[contr],x0,['algo'],[df0,[mem]],  </CALLING_SEQUENCE_ITEM>
    <CALLING_SEQUENCE_ITEM>     ,[stop],['in'])  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
        <PARAM_NAME>imp</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: scalar argument used to set the trace mode. <VERB>imp=0</VERB>
    nothing (execpt errors) is reported, <VERB>imp=1</VERB> initial
    and final reports, <VERB>imp=2</VERB> adds a report per iteration,
    <VERB>imp&gt;2</VERB> add reports on linear search. Warning, most
    of these reports are written on the Scilab standard output.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>fun</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: external, i.e Scilab function or string (<VERB>fun</VERB> is the
    function defining the least square probleme: see below.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>x0</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: real vector (initial value of variable to be minimized).</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>f</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: value of optimal least square value.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>xopt</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: best value of <VERB>x</VERB> found.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>contr</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: <VERB>'b',binf,bsup</VERB>  with <VERB>binf</VERB> and
    <VERB>bsup</VERB> real vectors with same dimension as
    <VERB>x0</VERB>. <VERB>binf</VERB> and <VERB>bsup</VERB> are lower
    and upper bounds on <VERB>x</VERB>.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>algo</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: A string with possible values :<VERB>'qn'</VERB> or
    <VERB>'gc'</VERB> or <VERB>'nd'</VERB> . This
    string stands for quasi-Newton (default),  conjugate gradient or
    non-differentiable respectively.  Note that
    <VERB>'nd'</VERB> does not accept bounds on
    <VERB>x</VERB> ).</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>df0</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: real scalar. Guessed decreasing of <VERB>f</VERB> at first
    iteration. (<VERB>df0=1</VERB> is the default value).</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>mem</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: integer, number of variables used to approximate the  Hessian,
    (<VERB>algo='gc' or 'nd'</VERB>). Default value
    is around 6.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>stop</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>:  sequence of optional parameters controlling the  convergence of
  the algorithm. 
  <VERB>  stop=  'ar',nap, [iter [,epsg   [,epsf [,epsx]]]]</VERB></SP>
          <PARAM_INDENT>
            <PARAM_ITEM>
              <PARAM_NAME>&quot;ar&quot;  </PARAM_NAME>
              <PARAM_DESCRIPTION>
                <SP>: reserved keyword for stopping rule selection defined as follows:</SP>
              </PARAM_DESCRIPTION>
            </PARAM_ITEM>
            <PARAM_ITEM>
              <PARAM_NAME>nap</PARAM_NAME>
              <PARAM_DESCRIPTION>
                <SP>: maximum number of calls to <VERB>fun</VERB> allowed.</SP>
              </PARAM_DESCRIPTION>
            </PARAM_ITEM>
            <PARAM_ITEM>
              <PARAM_NAME>iter</PARAM_NAME>
              <PARAM_DESCRIPTION>
                <SP>: maximum number of iterations allowed.</SP>
              </PARAM_DESCRIPTION>
            </PARAM_ITEM>
            <PARAM_ITEM>
              <PARAM_NAME>epsg</PARAM_NAME>
              <PARAM_DESCRIPTION>
                <SP>: threshold on gradient norm.</SP>
              </PARAM_DESCRIPTION>
            </PARAM_ITEM>
            <PARAM_ITEM>
              <PARAM_NAME>epsf</PARAM_NAME>
              <PARAM_DESCRIPTION>
                <SP>: threshold controlling decreasing of <VERB>f</VERB></SP>
              </PARAM_DESCRIPTION>
            </PARAM_ITEM>
            <PARAM_ITEM>
              <PARAM_NAME>epsx</PARAM_NAME>
              <PARAM_DESCRIPTION>
                <SP>: threshold controlling variation of <VERB>x</VERB>. This vector
        (possibly matrix) of same size as <VERB>x0</VERB> can be used to
        scale <VERB>x</VERB>.</SP>
              </PARAM_DESCRIPTION>
            </PARAM_ITEM>
          </PARAM_INDENT>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>&quot;in&quot;  </PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: reserved  keyword for initialization of parameters used when
  <VERB>fun</VERB> in given as a Fortran routine (see below).</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>gradopt</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>:  gradient of <VERB>fun</VERB> at <VERB>xopt</VERB></SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
  <DESCRIPTION>
    <P>
    Non-linear optimization routine for programs without constraints or with bound constraints: 
   </P>
    <P><VERB>min sum(f(x)).^2</VERB>  w.r.t  <VERB>x</VERB>, 
   Here, <VERB>f</VERB> is a function from R^n to R^m which returns <VERB>f(x)</VERB>, a
    real vector ( value of function at <VERB>x</VERB>). </P>
    <DESCRIPTION_INDENT>
      <DESCRIPTION_ITEM label="fun">
        <SP>gives the definition of the function <VERB>f(x)</VERB>. It
    is an &quot;external&quot; i.e function, or list or C or Fortran
    routine (see &quot;external&quot;).</SP>
        <P>
    This external must return a vector <VERB>y</VERB> such as
    (<VERB>y(j)=f(x)</VERB>) for a given <VERB>x</VERB>.
    </P>
        <DESCRIPTION_INDENT>
          <DESCRIPTION_ITEM label="If">
            <SP><VERB>fun</VERB> is a Scilab function, the calling sequence for <VERB>fun</VERB> must be:
          <VERB>y=fun(x, [optional parameters])</VERB></SP>
          </DESCRIPTION_ITEM>
          <DESCRIPTION_ITEM label="If">
            <SP><VERB>fun</VERB>  is defined by a Fortran or C routine first argument must be a
        list:         <VERB> list(fun_name,m,p1,..pl)</VERB></SP>
            <P><VERB>fun_name</VERB> is then a character string, it refers to the name of the routine
        which must be linked to Scilab. 
        Here, the generic calling sequences are: 
        </P>
            <P>
        In Fortran
       </P>
            <VERBATIM>
<![CDATA[
          subroutine fun(n,m,x,td,y)
          integer n,m
          double precision x(n), td(*), y(m)
         ]]>
            </VERBATIM>
            <P>        In C</P>
            <VERBATIM>
<![CDATA[
          void fun(int *n,int *m, double *x,double *params, double *y)
       ]]>
            </VERBATIM>
            <P><VERB>n</VERB> is the dimension of vector <VERB>x</VERB> ,
        <VERB>m</VERB> is the dimension of vector<VERB>y</VERB>,  
        <VERB>td</VERB> is a vector which contains the parameters
        <VERB>p1,..pl</VERB></P>
          </DESCRIPTION_ITEM>
        </DESCRIPTION_INDENT>
      </DESCRIPTION_ITEM>
      <DESCRIPTION_ITEM label="Dfun">
        <SP>Gives the definition of the function <VERB>df(x)/dx</VERB>. It is
     an &quot;external&quot;.This external must return a matrix
     <VERB>g</VERB> such  as (<VERB>g(i,j)=dfi/dxj</VERB>) for a given
     <VERB>x</VERB>.</SP>
        <DESCRIPTION_INDENT>
          <DESCRIPTION_ITEM label="If">
            <SP><VERB>Dfun</VERB> is a function, the calling sequence for <VERB>fun</VERB> must be:
          <VERB>g=Dfun(x, [optional parameters])</VERB> .</SP>
          </DESCRIPTION_ITEM>
          <DESCRIPTION_ITEM label="If">
            <SP><VERB>Dfun</VERB> is defined by a Fortran or C routine first argument must be a
           list:           <VERB>list(fun_name,m,...)</VERB></SP>
            <P><VERB>fun_name</VERB> is a character string, it refers to the name of the routine
            which must be linked to Scilab. This function has the same calling
            sequence as  <VERB>fun</VERB></P>
          </DESCRIPTION_ITEM>
        </DESCRIPTION_INDENT>
      </DESCRIPTION_ITEM>
    </DESCRIPTION_INDENT>
  </DESCRIPTION>
  <EXAMPLE>
<![CDATA[
a=rand(3,2);b=[1;1;1];x0=[1;-1];
deff('f=fun(x,a,b)','f=a*x-b');
deff('g=dfun(x,a,b)','g=a');

[f,xopt]=leastsq(fun,x0)      //Simplest call
xopt-a\b  //compare with linear algebra solution

[f,xopt]=leastsq(fun,dfun,x0)      //specify gradient

[f,xopt]=leastsq(list(fun,[1 2;3 4],[1;2]),x0)    

deff('f=fun(x,a,b)','f=exp(a*x)-b');
deff('g=dfun(x,a,b)','g=a.*(exp(a*x)*ones(1,size(a,2)))');

[f,xopt]=leastsq(list(fun,[1 2;3 4],[1;2]),x0)  
   ]]>
  </EXAMPLE>
  <SEE_ALSO>
    <SEE_ALSO_ITEM>
      <LINK>external</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>quapro</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>linpro</LINK>
    </SEE_ALSO_ITEM>
  </SEE_ALSO>
</MAN>
