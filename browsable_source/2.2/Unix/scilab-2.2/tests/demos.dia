 
//to Check all the demos
 
clearfun('x_message')
 
clearfun('x_dialog')
 
clearfun('x_mdialog')
 
clearfun('x_choose')
 
clearfun('mode')
 
driver('Pos')
 
 
clearfun('driver')
 
deff('x=driver(x)','x=''Pos''')
 
deff('[]=mode(x)','x=x')
 
deff('[]=halt(  )',' ')
Warning :redefining function: halt                    
 
 
lines(0)
 
clearfun('lines')
 
deff('[x]=lines(x)','x=0 ')
 
getf('SCI/tests/dialogs.sci','c')
 
I=file('open','SCI/tests/demos.dialogs','old')
 I  =
 
    3.  
 
O=file('open','/dev/null','old')
 O  =
 
    4.  
 
%IO=[I,O]
 %IO  =
 
!   3.    4. !
 
lines(0)
 ans  =
 
    0.  
 
getf('SCI/macros/util/getvalue.sci')
Warning :redefining function: getvalue                
 
 
 
mode(-1)
 
oldln=lines()
 oldln  =
 
    0.  
 
lines(0)
 ans  =
 
    0.  
 
 
demolist=[
'Introduction to SCILAB','intro/dem01.dem';
'Graphics I','graphics/dessin.dem';
'Graphics Misc.','graphics/divers.dem';
'Graphics : X primitives','graphics/xdemo.dem';
'Graphics : Animation','anim/anim.dem';
'Graphics : Finite Elements ','fec/fec.dem';
'Inverted pendulum','pendulum/pendule.dem';
'n-pendulum','npend/npend.dem';
'Car parking','flat/flat.dem';
'Wheel simulation ','wheel2/wheel.dem';
'Bike Simulation (1)','bike/bike.dem';
'Bike Simulation (2)','bike/bike2.dem';
'Signal Processing','signal/signal.dem';
'Dialog (Xwindow)','dialog/dialog.dem';
'Fortran translator','transl/demotrad.dem';
'ODE''S','ode/ode.dem';
'Arma','arma/arma.dem';
'Tracking','tracking/track.dem';
'Robust control','robust/rob.dem';
'LMITOOL','lmitool/lmi.dem'];
 
 
while %t then
  num=x_choose(demolist(:,1),'Click to choose a demo');
  if num=0 then
     lines(oldln(1))
     return
  else
     demoex(num)
  end,
end
 
mode(7)
 
//               SCILAB OBJECTS
 
//               1. SCALARS
 
a=1               //constant
 a  =
 
    1.  
 
1==1              //boolean
 ans  =
 
  T  
 
'string'          //character string
 ans  =
 
 string   
 
z=poly(0,'z')     // polynomial with variable 'z' and with one root at zero
 z  =
 
    z   
 
p=1+3*z+4.5*z^2   //polynomial
 p  =
 
                 2  
    1 + 3z + 4.5z   
 
r=z/p             //rational
 r  =
 
          z         
    -------------   
                 2  
    1 + 3z + 4.5z   
 
 
//                2. MATRICES
 
a=[a+1 2 3
     0 0 atan(1)
     5 9 -1]      //constant matrix
 a  =
 
!   2.    2.    3.        !
!   0.    0.    0.7853982 !
!   5.    9.  - 1.        !
 
 
b=[%t,%f]         //boolean matrix
 b  =
 
! T F !
 
 
mc=['this','is';
    'a' ,'matrix']   //matrix of strings
 mc  =
 
!this  is      !
!              !
!a     matrix  !
 
 
mp=[p,1-z;
    1,z*p]        //polynomial matrix
 mp  =
 
!                2                   !
!   1 + 3z + 4.5z     1 - z          !
!                                    !
!                           2      3 !
!   1                 z + 3z + 4.5z  !
 
 
mp=[p 1-z]
 mp  =
 
!                2           !
!   1 + 3z + 4.5z     1 - z  !
 
mp=[mp;1 1+z*p]   //matrix polynomial
 mp  =
 
!                2                       !
!   1 + 3z + 4.5z     1 - z              !
!                                        !
!                               2      3 !
!   1                 1 + z + 3z + 4.5z  !
 
 
f=mp/poly([1+%i 1-%i 1],'z')   //rational matrix
 f  =
 
!                 2                        !
!    1 + 3z + 4.5z        - 1              !
!   ---------------     ---------          !
!              2   3              2        !
! - 2 + 4z - 3z + z     2 - 2z + z         !
!                                          !
!                                 2      3 !
!          1            1 + z + 3z + 4.5z  !
!   ---------------     -----------------  !
!              2   3                2   3  !
! - 2 + 4z - 3z + z    - 2 + 4z - 3z + z   !
 
 
//                 3. LISTS
 
l=list(a,-(1:5), mp,['this','is';'a','list'])   //list
 l  =
 
 
       l>1
 
!   2.    2.    3.        !
!   0.    0.    0.7853982 !
!   5.    9.  - 1.        !
 
       l>2
 
! - 1.  - 2.  - 3.  - 4.  - 5. !
 
       l>3
 
!                2                       !
!   1 + 3z + 4.5z     1 - z              !
!                                        !
!                               2      3 !
!   1                 1 + z + 3z + 4.5z  !
 
       l>4
 
!this  is    !
!            !
!a     list  !
 
b=[1 0;0 1;0 0];c=[1 -1 0];d=0*c*b;x0=[0;0;0];
 
sl=syslin('c',a,b,c,d,x0)    //Linear system in state-space representation.
 sl  =
 
 
       sl(1)   (state-space system:)
 
 lss   
 
       sl(2) = A matrix = 
 
!   2.    2.    3.        !
!   0.    0.    0.7853982 !
!   5.    9.  - 1.        !
 
       sl(3) = B matrix = 
 
!   1.    0. !
!   0.    1. !
!   0.    0. !
 
       sl(4) = C matrix = 
 
!   1.  - 1.    0. !
 
       sl(5) = D matrix = 
 
!   0.    0. !
 
       sl(6) = X0 (initial state) = 
 
!   0. !
!   0. !
!   0. !
 
       sl(7) = Time domain = 
 
 c   
 
slt=ss2tf(sl)                // Transfer matrix
 slt  =
 
!                          2                               2           !
!       - 10.995574 + s + s                     46 + 3s - s            !
!   -----------------------------      -----------------------------   !
!                             2   3                              2     !
!   6.2831853 - 24.068583s - s + s     6.2831853 - 24.068583s - s      !
!         3                                                            !
!      + s                                                             !
 
 
//                  OPERATIONS
 
v=1:5;v*v'                   //constant matrix
 ans  =
 
    55.  
 
mp'*mp+eye                   //polynomial matrix
 ans  =
 
!               2     3        4                 2                     !
!   3 + 6z + 18z + 27z + 20.25z     2 + 3z + 4.5z                      !
!                                                                      !
!                2                        2     3     4     5        6 !
!   2 + 3z + 4.5z                   3 + 8z + 15z + 18z + 27z + 20.25z  !
 
mp1=mp(1,1)+4.5*%i           //complex
 mp1  =
 
real part
 
 
                 2  
    1 + 3z + 4.5z   
imaginary part
 
 
    4.5   
 
fi=c*(z*eye-a)^(-1)*b;       //transfer function evaluation
 
f(:,1)*fi                    //rationals
 ans  =
 
 
    column    1
!                                              2      3      4         !
!         - 10.995574 - 31.986723z - 45.480084z + 7.5z + 4.5z          !
!   -----------------------------------------------------------------  !
!                                      2            3            4     !
! - 12.566371 + 73.269908z - 113.12389z + 72.488936z - 17.068583z      !
!          5   6                                                       !
!      - 4z + z                                                        !
!                                                                      !
!                                            2                         !
!                         - 10.995574 + z + z                          !
!   -----------------------------------------------------------------  !
!                                      2            3            4     !
! - 12.566371 + 73.269908z - 113.12389z + 72.488936z - 17.068583z      !
!          5   6                                                       !
!      - 4z + z                                                        !
 
    column    2
!                                    2       3      4                  !
!                    46 + 141z + 215z + 10.5z - 4.5z                   !
!   -----------------------------------------------------------------  !
!                                      2            3            4     !
! - 12.566371 + 73.269908z - 113.12389z + 72.488936z - 17.068583z      !
!          5   6                                                       !
!      - 4z + z                                                        !
!                                                                      !
!                                         2                            !
!                              46 + 3z - z                             !
!   -----------------------------------------------------------------  !
!                                      2            3            4     !
! - 12.566371 + 73.269908z - 113.12389z + 72.488936z - 17.068583z      !
!          5   6                                                       !
!      - 4z + z                                                        !
 
m=[mp -mp; mp' mp+eye]       //usual Matlab syntax for polynomials
 m  =
 
 
        columns    1 to   3
 
!                2                                       2 !
!   1 + 3z + 4.5z     1 - z               - 1 - 3z - 4.5z  !
!                                                          !
!                               2      3                   !
!   1                 1 + z + 3z + 4.5z   - 1              !
!                                                          !
!                2                                       2 !
!   1 + 3z + 4.5z     1                     2 + 3z + 4.5z  !
!                                                          !
!                               2      3                   !
!   1 - z             1 + z + 3z + 4.5z     1              !
 
         column    4
! - 1 + z              !
!                      !
!             2      3 !
! - 1 - z - 3z - 4.5z  !
!                      !
!   1 - z              !
!                      !
!             2      3 !
!   2 + z + 3z + 4.5z  !
 
[fi, fi(:,1)]                //0... or rationals
 ans  =
 
 
    columns    1 to    2
 
!                          2                               2           !
!       - 10.995574 + z + z                     46 + 3z - z            !
!   -----------------------------      -----------------------------   !
!                             2   3                              2     !
!   6.2831853 - 24.068583z - z + z     6.2831853 - 24.068583z - z      !
!         3                                                            !
!      + z                                                             !
 
    column    3
!                          2        !
!       - 10.995574 + z + z         !
!   -----------------------------   !
!                             2   3 !
!   6.2831853 - 24.068583z - z + z  !
 
f=syslin('c',f);
 
num=f(2);den=f(3);           //operation on transfer matrix
 
 
//                  SOME NUMERICAL PRIMITIVES
 
inv(a)                       //Inverse
 ans  =
 
!   1.125  - 4.6154933  - 0.25 !
! - 0.625    2.705634     0.25 !
!   0.       1.2732395    0.   !
 
inv(mp)                      //Inverse
 ans  =
 
!                    2      3                                            !
!        - 1 - z - 3z - 4.5z                         1 - z               !
!   -------------------------------     -------------------------------  !
!             2     3     4        5              2     3     4        !
! - 5z - 10.5z - 18z - 27z - 20.25z   - 5z - 10.5z - 18z - 27z         !
!              5                                                         !
!      - 20.25z                                                          !
!                                                                        !
!                                                             2          !
!                  1                           - 1 - 3z - 4.5z           !
!   -------------------------------     -------------------------------  !
!             2     3     4        5              2     3     4        !
! - 5z - 10.5z - 18z - 27z - 20.25z   - 5z - 10.5z - 18z - 27z         !
!              5                                                         !
!      - 20.25z                                                          !
 
inv(sl*sl')                  //Product of two linear systems and inverse
 ans  =
 
 
       ans(1)   (state-space system:)
 
 lss   
 
       ans(2) = A matrix = 
 
!   5.9830447  - 2.7428339    7.3183626  - 4.2885178 !
!   2.6071355    6.0712325  - 7.7859471  - 5.4755708 !
!   0.         - 1.998D-15  - 4.9854125  - 0.7866233 !
!   0.           3.220D-15    0.5793044  - 5.0688648 !
 
       ans(3) = B matrix = 
 
! - 12.503402 !
! - 6.1225032 !
!   2.1610821 !
! - 2.2230824 !
 
       ans(4) = C matrix = 
 
! - 0.9983022    4.0965198  - 7.074889    0.1816573 !
 
       ans(5) = D matrix = 
 
                                 2  
    2.4292037 - 9.021D-17s + 0.5s   
 
       ans(6) = X0 (initial state) = 
 
!   0. !
!   0. !
!   0. !
!   0. !
 
       ans(7) = Time domain = 
 
 c   
 
w=ss2tf(ans)                 //Transfer function representation
 w  =
 
                                       2            3            4      
    19.739209 - 151.22737s + 283.36517s + 30.351769s - 23.568583s       
          5      6                                                      
       - s + 0.5s                                                       
    ------------------------------------------------------------------  
                                                  2    3   4            
               1118.4513 + 127.00443s - 51.995574s - 2s + s             
 
inv(ss2tf(sl)*ss2tf(sl'))    //Product of two transfer functions and inverse
 ans  =
 
                                       2            3            4      
    39.478418 - 302.45474s + 566.73034s + 60.703538s - 47.137167s       
           5   6                                                        
       - 2s + s                                                         
    ------------------------------------------------------------------  
                                                 2    3    4            
              2236.9027 + 254.00885s - 103.99115s - 4s + 2s             
 
clean(w-ans)
 ans  =
 
    0   
    -   
    1   
 
n=contr(a,b)                 //Controllability
 n  =
 
    3.  
 
k=ppol(a,b,[-1-%i -1+%i -1])        //Pole placement
 k  =
 
!   0.1832061  - 0.3358779    1.740458  !
!   2.7463953    3.8167939    1.7650419 !
 
poly(a-b*k,'z')-poly([-1-%i -1+%i -1],'z')    //Check...
 ans  =
 
                          2  
  - 2.154D-14 + 2.665D-15z   
 
 
s=sin(0:0.1:5*%pi);
 
ss=fft(s(1:128),-1);        //FFT
 
xbasc();
 
plot2d3("enn",1,abs(ss)');      //simple plot
 
 
x=lyap(a,diag([1 2 3]),'cont')   //Lyapunov equation
 x  =
 
! - 1.4958251  - 4.3299851    0.6983300 !
! - 4.3299851  - 0.3504060    1.07333   !
!   0.6983300    1.07333      1.4379815 !
 
 
 
//              ON LINE DEFINITION OF MACRO
 
deff('[x]=fact(n)','if n=0 then x=1,else x=n*fact(n-1),end')
 
10+fact(5)
 ans  =
 
    130.  
 
//                    OPTIMIZATION
 
deff('[f,g,ind]=rosenbro(x,ind)', 'a=x(2)-x(1)^2 , b=1-x(2) ,...
f=100.*a^2 + b^2 , g(1)=-400.*x(1)*a , g(2)=200.*a -2.*b ');
 
comp(rosenbro);[f,x,g]=optim(rosenbro,[2;2],'qn')
 norm of projected gradient lower than   0.0000000D+00
 
 g  =
 
!   0. !
!   0. !
 x  =
 
!   1. !
!   1. !
 f  =
 
    0.  
 
 
//                   SIMULATION
 
a=rand(3,3)
 a  =
 
!   0.3616361    0.4826472    0.5015342 !
!   0.2922267    0.3321719    0.4368588 !
!   0.5664249    0.5935095    0.2693125 !
 
e=exp(a)
 e  =
 
!   1.8016766    0.9861359    0.9295708 !
!   0.6462788    1.7366226    0.7731203 !
!   1.0024892    1.1047133    1.7455217 !
 
deff('[ydot]=f(t,y)','ydot=a*y');comp(f)
 
e(:,1)-ode([1;0;0],0,1,f)
 ans  =
 
! - 6.303D-08 !
! - 5.028D-08 !
! - 6.558D-08 !
 
 
//                  SYSTEM DEFINITION
 
s=poly(0,'s')
 s  =
 
    s   
 
h=[1/s,1/(s+1);1/s/(s+1),1/(s+2)/(s+2)]
 h  =
 
!   1           1         !
!   -         -----       !
!   s         1 + s       !
!                         !
!     1           1       !
!   -----     ---------   !
!        2              2 !
!   s + s     4 + 4s + s  !
 
w=tf2ss(h);
 
ss2tf(w)
 ans  =
 
!         1             1             !
!   -------------     -----           !
! - 3.768D-15 + s     1 + s           !
!                                     !
!     1               1 + 1.548D-15s  !
!   -----             --------------  !
!        2                        2   !
!   s + s               4 + 4s + s    !
 
h1=clean(ans)
 h1  =
 
!   1           1         !
!   -         -----       !
!   s         1 + s       !
!                         !
!     1           1       !
!   -----     ---------   !
!        2              2 !
!   s + s     4 + 4s + s  !
 
 
//             EXAMPLE: SECOND ORDER SYSTEM ANALYSIS
 
sl=syslin('c',1/(s*s+0.2*s+1))
 sl  =
 
         1         
    -----------    
                2  
    1 + 0.2s + s   
 
instants=0:0.05:20;
 
//             step response:
 
y=csim('step',instants,sl);
 
xbasc();plot2d(instants',y')
 
//             Delayed step response
 
deff('[in]=u(t)','if t<3 then in=0;else in=1;end');
 
comp(u);
 
y1=csim(u,instants,sl);plot2d(instants',y1');
 
 
//             Impulse response;
 
yi=csim('imp',instants,sl);xbasc();plot2d(instants',yi');
 
yi1=csim('step',instants,s*sl);plot2d(instants',yi1');
 
 
//              Discretization
 
dt=0.05;
 
sld=dscr(tf2ss(sl),0.05);
 
 
//               Step response
 
u=ones(instants);
 
yyy=flts(u,sld);
 
xbasc();plot(instants,yyy)
 
 
//              Impulse response
 
u=0*ones(instants);u(1)=1/dt;
 
yy=flts(u,sld);
 
xbasc();plot(instants,yy)
 
 
//            system interconnexion
 
w1=[w,w];
 
clean(ss2tf(w1))
 ans  =
 
!   1           1            1           1         !
!   -         -----          -         -----       !
!   s         1 + s          s         1 + s       !
!                                                  !
!     1           1            1           1       !
!   -----     ---------      -----     ---------   !
!        2              2         2              2 !
!   s + s     4 + 4s + s     s + s     4 + 4s + s  !
 
w2=[w;w];
 
clean(ss2tf(w2))
 ans  =
 
!   1           1         !
!   -         -----       !
!   s         1 + s       !
!                         !
!     1           1       !
!   -----     ---------   !
!        2              2 !
!   s + s     4 + 4s + s  !
!                         !
!   1           1         !
!   -         -----       !
!   s         1 + s       !
!                         !
!     1           1       !
!   -----     ---------   !
!        2              2 !
!   s + s     4 + 4s + s  !
 
 
//               change of variable
 
z=poly(0,'z');
 
horner(h,(1-z)/(1+z))  //bilinear transform
 ans  =
 
!             2              2 !
! - 7 - 8z - z     1 + 2z + z  !
!   ----------     ----------  !
!             2              2 !
! - 5 + 4z + z   - 5 + 4z + z  !
!                              !
!             2              2 !
! - 7 - 8z - z     1 + 2z + z  !
!   ----------     ----------  !
!             2              2 !
! - 5 + 4z + z   - 5 + 4z + z  !
 
 
//                 PRIMITIVES
 
H=[1.    1.    1.    0.;
   2.  - 1.    0.    1;
   1.    0.    1.    1.;
   0.    1.    2.  - 1];
 
 
ww=spec(H)
 ww  =
 
!   2.7320508 !
! - 2.7320508 !
!   0.7320508 !
! - 0.7320508 !
 
 
//             STABLE SUBSPACES
 
[X,d]=schur(H,'cont');
 
X'*H*X
 ans  =
 
! - 2.7320508  - 1.110D-15    0.           1.        !
!   0.         - 0.7320508  - 1.         - 7.772D-16 !
!   7.216D-16    0.           2.7320508    0.        !
!   0.         - 6.106D-16    0.           0.7320508 !
 
 
[X,d]=schur(H,'disc');
 
X'*H*X
 ans  =
 
!   0.7320508    0.           7.772D-16    1.        !
!   0.         - 0.7320508  - 1.           8.604D-16 !
!   0.           0.           2.7320508  - 1.166D-15 !
!   7.772D-16    1.110D-15  - 1.277D-15  - 2.7320508 !
 
 
//Selection of user-defined eigenvalues (# 3 and 4 here);
 
deff('[flg]=sel(x)','flg=0,ev=x(2)/x(3),if abs(ev-ww(3))<0.0001|abs(ev-ww(4))<0.00001 then flg=1,end')
 
[X,d]=schur(H,sel)
 d  =
 
    2.  
 X  =
 
! - 0.5705632  - 0.2430494  - 0.6640233  - 0.4176813 !
! - 0.4176813    0.6640233  - 0.2430494    0.5705632 !
!   0.5705632  - 0.2430494  - 0.6640233    0.4176813 !
!   0.4176813    0.6640233  - 0.2430494  - 0.5705632 !
 
 
X'*H*X
 ans  =
 
!   0.7320508    0.           7.772D-16    1.        !
!   0.         - 0.7320508  - 1.           8.604D-16 !
!   0.           0.           2.7320508  - 1.166D-15 !
!   7.772D-16    1.110D-15  - 1.277D-15  - 2.7320508 !
 
 
//               With matrix pencil
 
[X,d]=gschur(H,eye(H),sel)
 d  =
 
    2.  
 X  =
 
!   0.5705632    0.2430494    0.6640233    0.4176813 !
!   0.4176813  - 0.6640233    0.2430494  - 0.5705632 !
! - 0.5705632    0.2430494    0.6640233  - 0.4176813 !
! - 0.4176813  - 0.6640233    0.2430494    0.5705632 !
 
X'*H*X
 ans  =
 
!   0.7320508    0.           9.576D-16    1.        !
!   0.         - 0.7320508  - 1.           0.        !
!   8.882D-16    0.           2.7320508    0.        !
!   0.           0.           0.         - 2.7320508 !
 
 
//            block diagonalization
 
[ab,x,bs]=bdiag(H);
 
 
inv(x)*H*x
 ans  =
 
!   2.7320508    1.610D-15    0.           0.        !
! - 3.664D-15  - 2.7320508    0.           6.661D-16 !
!   0.           0.           0.7320508  - 7.910D-16 !
!   0.           0.           0.         - 0.7320508 !
 
 
//                     Matrix pencils
 
E=rand(3,2)*rand(2,3);
 
A=rand(3,2)*rand(2,3);
 
s=poly(0,'s');
 
 
w=det(s*D-A)   //determinant
 w  =
 
                           2  
  - 0.0801176s + 0.0423727s   
 
[al,be]=gspec(A,E);
 
al./(be+%eps*ones(be))
 ans  =
 
!   1.687D+15 !
!   1.8907826 !
! - 7.445D-17 !
 
roots(w)
 ans  =
 
!   0         !
!   1.8907826 !
 
[Ns,d]=coffg(s*D-A);    //inverse of polynomial matrix;
 
clean(Ns/d*(s*D-A))
 ans  =
 
!   1     0     0  !
!   -     -     -  !
!   1     1     1  !
!                  !
!   0     1     0  !
!   -     -     -  !
!   1     1     1  !
!                  !
!   0     0     1  !
!   -     -     -  !
!   1     1     1  !
 
[Q,M,i1]=pencan(E,A);   // Canonical form;
    rank A^k    rcond
        2.      0.354D+00
    rank A^k    rcond
        2.      0.547D+00
 
M*E*Q
 ans  =
 
!   1.           4.718D-16    2.776D-16 !
!   1.318D-15    1.           0.        !
!   2.725D-16    0.           0.        !
 
M*A*Q
 ans  =
 
!   1.8609512    0.4018602  - 4.441D-16 !
!   0.1381447    0.0298314    0.        !
!   0.           0.           1.        !
 
 
//           PAUSD-RESUME
 
write(%io(2),'pause command...');
pause command...
 
write(%io(2),'TO CONTINUE...');
TO CONTINUE...
 
write(%io(2),'ENTER ''resume (or return) or click on resume!!''');
ENTER 'resume (or return) or click on resume!!'
 
//pause;
 
 
//           CALLING EXTERNAL ROUTINE
 
foo=['      subroutine foo(a,b,c)';
     '      c=a+b';
     '      end'  ];
 
unix_s('rm -f foo.f')
 
write('foo.f',foo);
 
unix_s('make foo.o')     //Compiling...(needs fortran compiler)
 
//..................WARNING.......................
 
//NEXT COMMAND LINE WILL DO THE LINK OF THE ROUTINE foo WITH SCILAB
 
//THIS COMMAND MAY FAIL FOR SystemV COMPILED VERSIONS OF SCILAB
 
//BECAUSE LINK NEEDS THE LIBRARIES (SEE THE HELP OF "LINK" COMMAND)
 
link('foo.o','foo')    //Linking to Scilab
 
//5+7 by fortran
 
fort('foo',5,1,'r',7,2,'r','out',[1,1],3,'r')
 ans  =
 
    12.  
 
 
 
mode(-1)
 
oldln=lines()
 oldln  =
 
    0.  
 
lines(0)
 ans  =
 
    0.  
 
 
deff('[]=xdemo(info,str)',['x_message([info;str]);xbasc();';
                           'write(%io(2),str)';
                           'execstr(str)']);
 
xset("default");
 
 
 
 
nn=prod(size(str_l))
 nn  =
 
    32.  
 
while %t then
  num=x_choose(info_l,'Choose a demo');
  if num=0 then
     lines(oldln(1))
     return
  else
     xdemo(" ",str_l(num));
  end,
end
t=(0:0.1:6*%pi);
plot2d(t',sin(t)');
xtitle('plot2d and xgrid ','t','sin(t)');
halt();xgrid([10,10],2);
plot2d1('enl',1,(1:10:10000)');
xtitle('plot2d1 log scale','t','y  log scale');
n=32-1;t=(0:n)/n;
u=sin(80*%pi*t)+sin(100*%pi*t);
plot2d3('enn',1,abs(fft(u,-1))'/n);
xtitle('plot2d3 (vbar plot)','t','f(t)');
rand('normal');
v=(1:20)+(1:20).*rand(1,20);
plot2d1('enn',1,v');
plot2d1('enn',1,(1:20)',[-2,2],'100','estimated');
xtitle('plot2d1 ',' ',' ');
histplot()
rand('normal');
histplot([-6:0.2:6],rand(1,2000),[-1,1],'011',' ',
[-6,0,6,1.1],[2,12,2,11]);
titre= 'macro histplot : Histogram plot';
xtitle(titre,'Classes','N(C)/Nmax');
fplot2d();
xtitle('fplot2d : f given by external ','x ','f(x) ');
deff('[y]=f(x)','y=sin(x)+cos(x)');
fplot2d(0:0.1:%pi,f);
param3d();
xtitle('param3d : parametric curves in R3',' ',' ');
 Demo of param3d
  t=0:0.1:5*%pi;  param3d(sin(t),cos(t),t/10,35,45,'X@Y@Z',[2,4]);
t=-50*%pi:0.1:50*%pi;
x=t.*sin(t);y=t.*cos(t);z=t.*abs(t)/(50*%pi);
param3d(x,y,z,45,60);
title=['param3d : parametric curves in R3',
' (t.sin(t),t.cos(t),t.|t|/50.%pi)'];
xtitle(title,' ',' ');
plot3d();
title=['plot3d : z=sin(x)*cos(y)'];
xtitle(title,' ',' ');
 Demo of plot3d
t=-%pi:0.3:%pi;plot3d(t,t,sin(t)'*cos(t),35,45,'X@Y@Z',[2,2,4]);
fplot3d();
title=['fplot3d : z=f(x,y), f external'];
xtitle(title,' ',' ');
deff('[z]=surf(x,y)','z=sin(x)*cos(y)');
t=-%pi:0.3:%pi;
fplot3d(t,t,surf,35,45,"X@Y@Z");
plot3d1();
title=['plot3d1 : z=sin(x)*cos(y)'];
xtitle(title,' ',' ');
 Demo of plot3d1
t=-%pi:0.3:%pi;plot3d1(t,t,sin(t)'*cos(t),35,45,'X@Y@Z',[2,2,4]);
fplot3d1();
title=['fplot3d : z=f(x,y), f external'];
xtitle(title,' ',' ');
deff('[z]=surf(x,y)','z=sin(x)*cos(y)');
t=-%pi:0.3:%pi;
fplot3d1(t,t,surf,35,45,"X@Y@Z");
contour();
title=['contour '];
xtitle(title,' ',' ');
 Demo of contour
  contour(1:5,1:10,rand(5,10),5);
fcontour();
title=['fcontour '];
xtitle(title,' ',' ');
deff('[z]=surf(x,y)','z=x**2+y**2');
fcontour(-1:0.1:1,-1:0.1:1,surf,10);
champ();
title=['champ '];
xtitle(title,' ',' ');
 Demo of champ
  champ(rand(10,10),rand(10,10),1.0,[0,0,10,10]);
fchamp();
title=['fchamp '];
xtitle(title,' ',' ');
deff('[xdot] = derpol(t,x)',['xd1 = x(2)';
'xd2 = -x(1) + (1 - x(1)**2)*x(2)';
'xdot = [ xd1 ; xd2 ]']);
fchamp(derpol,0,-1:0.1:1,-1:0.1:1,1);
grayplot();
title=['grayplot '];
xtitle(title,' ',' ');
 Demo of grayplot
t=-%pi:0.1:%pi;m=sin(t)'*cos(t);grayplot(t,t,m);
fgrayplot();
title=['fgrayplot '];
xtitle(title,' ',' ');
deff('[z]=surf(x,y)','z=x**2+y**2');
fgrayplot(-1:0.1:1,-1:0.1:1,surf);
errbar();
title=['errbar '];
xtitle(title,' ',' ');
x=0:0.1:2*%pi;
y=[sin(x);cos(x)]';x=[x;x]'
plot2d(x,y);
errbar(x,y,0.05*ones(x),0.03*ones(x));
chart();
zgrid();
r=(%pi):-0.01:0;x=r.*cos(10*r);y=r.*sin(10*r);
deff('[z]=surf(x,y)','z=sin(x)*cos(y)');
t=%pi*(-10:10)/10;
fplot3d(t,t,surf,35,45,'X@Y@Z',[2,2,3]);
        z=sin(x).*cos(y);
write(%io(2),"Adding 2d graphics on 3d graphic');
z=sin(x).*cos(y);
[x1,y1]=geom3d(x,y,z);
xpoly(x1,y1,'lines');
[x1,y1]=geom3d([0,0],[0,0],[5,0]);
xsegs(x1,y1);
xstring(x1(1),y1(1)," The point (0,0,0)');
title=['plot3d and use of xgeom '];
xtitle(title,' ',' ');
Adding 2d graphics on 3d graphic
r=(%pi):-0.01:0;x=r.*cos(10*r);y=r.*sin(10*r);
deff('[z]=surf(x,y)','z=sin(x)*cos(y)');
t=%pi*(-10:10)/10;
fplot3d(t,t,surf,35,45,'X@Y@Z',[-1,2,3]);
        z=sin(x).*cos(y);
write(%io(2),"Adding 2d graphics on 3d graphic');
z=sin(x).*cos(y);
[x1,y1]=geom3d(x,y,z);
xpoly(x1,y1,'lines');
[x1,y1]=geom3d([0,0],[0,0],[5,0]);
xsegs(x1,y1);
xstring(x1(1),y1(1)," The point (0,0,0)');
title=['plot3d and use of xgeom '];
xtitle(title,' ',' ');
Adding 2d graphics on 3d graphic
t=%pi*(-10:10)/10;
deff('[z]=surf(x,y)','z=sin(x)*cos(y)');
rect=[-%pi,%pi,-%pi,%pi,-5,1];
z=feval(t,t,surf);
contour(t,t,z,10,35,45,'X@Y@Z',[1,1,0],rect,-5);
plot3d(t,t,z,35,45,'X@Y@Z',[2,1,3],rect);
title=['plot3d and contour '];
xtitle(title,' ',' ');
t=%pi*(-10:10)/10;
deff('[z]=surf(x,y)','z=sin(x)*cos(y)');
rect=[-%pi,%pi,-%pi,%pi,-1,1];
z=feval(t,t,surf);
plot3d(t,t,z,35,45,'X@Y@Z',[-1,1,3],rect);
contour(t,t,z,10,35,45,'X@Y@Z',[0,1,0],rect);
title=['plot3d and contour '];
xtitle(title,' ',' ');
t=%pi*(-10:10)/10;
deff('[z]=surf(x,y)','z=sin(x)*cos(y)');
rect=[-%pi,%pi,-%pi,%pi,-1,1];
z=feval(t,t,surf);
plot3d(t,t,z,35,45,'X@Y@Z',[-20,1,3],rect);
xset('alufunction',0);
contour(t,t,z,10,35,45,'X@Y@Z',[0,1,0],rect);
title=['plot3d and contour X11 only'];
xtitle(title,' ',' ');
xset('default');
plot2d();gr_menu(sd_1,1,1);
title=['plot2d and gr_menu '];
xtitle(title,' ',' ');
 Demo of plot2d
  x=0:0.1:2*%pi,  plot2d([x;x;x]',[sin(x);sin(2*x);sin(3*x)]',[-1,-2,3],'111','L1@L2@L3',[0,-2,2*%pi,2]);
plot3d();gr_menu(sd_2,1,1);
title=['plot3d and gr_menu '];
xtitle(title,' ',' ');
 Demo of plot3d
t=-%pi:0.3:%pi;plot3d(t,t,sin(t)'*cos(t),35,45,'X@Y@Z',[2,2,4]);
xset("font',2,0);xsetech([0,0,0.5,0.5]);plot3d();
xsetech([0.5,0,0.5,0.5]);plot2d();
xsetech([0.5,0.5,0.5,0.5]);grayplot();
xsetech([0,0.5,0.5,0.5]);histplot();
xsetech([0,0,1,1]);
xset("default');
 Demo of plot3d
t=-%pi:0.3:%pi;plot3d(t,t,sin(t)'*cos(t),35,45,'X@Y@Z',[2,2,4]);
 Demo of plot2d
  x=0:0.1:2*%pi,  plot2d([x;x;x]',[sin(x);sin(2*x);sin(3*x)]',[-1,-2,3],'111','L1@L2@L3',[0,-2,2*%pi,2]);
 Demo of grayplot
t=-%pi:0.1:%pi;m=sin(t)'*cos(t);grayplot(t,t,m);
rand('normal');
histplot([-6:0.2:6],rand(1,2000),[-1,1],'011',' ',
[-6,0,6,1.1],[2,12,2,11]);
titre= 'macro histplot : Histogram plot';
xtitle(titre,'Classes','N(C)/Nmax');
xyz=['x=r*cos(alp).*cos(tet)+orig(1)*ones(tet)';
     'y=r*cos(alp).*sin(tet)+orig(2)*ones(tet)';
     'z=r*sin(alp)+orig(3)*ones(tet)'];
deff('[x,y,z]=sph(alp,tet)',xyz);
r=1;orig=[0 0 0];
[x1,y1,z1]=eval3dp(sph,[-%pi:0.2:%pi %pi],[0:0.2:%pi %pi]);
r=1/2;orig=[-1.5 0 0];
[x2,y2,z2]=eval3dp(sph,[-%pi:0.2:%pi %pi],[0:0.2:%pi %pi]);
[n1,m1]=size(x1);[n2,m2]=size(x2);
flags=list([2*ones(1,m1) 4*ones(1,m2)],1,4);
fac3d([x1 x2],[y1 y2],[z1 z2],35,45,'X@Y@Z',flags);
 ans  =
 
    0.  
 
mode(-1)
 
oldln=lines()
 oldln  =
 
    0.  
 
lines(0)
 ans  =
 
    0.  
 
 
deff('[]=xdemo(info,str)',['x_message([info;str]);xbasc();';
                           'execstr(str)']);
 
xset("default");
 
 
 
 
nn=prod(size(str_l))
 nn  =
 
    4.  
 
while %t then
  num=x_choose(string(1:nn)','Choose a demo');
  if num=0 then
     lines(oldln(1))
     return
  else
     xdemo(" ",str_l(num));
  end,
end
 ans  =
 
    0.  
 
mode(-1)
 
getf('SCI/demos/graphics/xdemo.bas');
 
oldln=lines()
 oldln  =
 
    0.  
 
lines(0)
 ans  =
 
    0.  
 
deff('[]=demoex(num)',['select num,';
     'case 1 then xdemo1()';
     'case 2 then xdemo2()';
     'case 3 then xdemo3()';
     'case 4 then xdemo4()';'end']);
 
 
demolist=[
'Graphics X11 1','xdemo1()';
'Graphics X11 2','xdemo2()';
'Graphics X11 3','xdemo3()';
'Graphics X11 4','xdemo4()']
 demolist  =
 
!Graphics X11 1  xdemo1()  !
!                          !
!Graphics X11 2  xdemo2()  !
!                          !
!Graphics X11 3  xdemo3()  !
!                          !
!Graphics X11 4  xdemo4()  !
 
 
while %t then
  num=x_choose(demolist(:,1),'Choose a demo');
  if num=0 then
     lines(oldln(1))
     return
  else
     demoex(num)
  end,
end
 Demo of plot3d
t=-%pi:0.3:%pi;plot3d(t,t,sin(t)'*cos(t),35,45,'X@Y@Z',[2,2,4]);
 Demo of plot2d
  x=0:0.1:2*%pi,  plot2d([x;x;x]',[sin(x);sin(2*x);sin(3*x)]',[-1,-2,3],'111','L1@L2@L3',[0,-2,2*%pi,2]);
 ans  =
 
    0.  
 
mode(-1)
 
oldln=lines()
 oldln  =
 
    0.  
 
lines(0)
 ans  =
 
    0.  
 
 
demolist=[
'Graphics : Fec ','fec/fec.ex1';
'Graphics : Fec ','fec/fec.ex2'];
 
 
while %t then
  num=x_choose(demolist(:,1),'Click to choose a demo');
  if num=0 then
     lines(oldln(1))
     return
  else
     demoex(num)
  end,
end
 
// A small example of MESH Creation
 
// and visualisation of a linear on triangles function
 
getf('SCI/demos/fec/macros.sci')
 
xset("use color",0);
 
flag1=x_choose(['Yes';'No'],'Have you a color display');
 
if flag1=1;xset("use color",1);end
 
N=20;
 
n=1:N;
 
x=cos(n*2*%pi/N);
 
y=sin(n*2*%pi/N);
 
noeuds=N
 noeuds  =
 
    20.  
 
noeul=[(1:(N))',x',y',0*ones(N,1)];
 
noeul=[noeul;(N+1),0,0,0];
 
trianl=[]
 trianl  =
 
     []
 
for i=1:(N-1),trianl=[trianl;i,i,i+1,N+1,0];end
 
trianl=[trianl;N,N,1,N+1,0];
 
triang=N;
 
rect=[-1.2,-1.2,1.2,1.2]
 rect  =
 
! - 1.2  - 1.2    1.2    1.2 !
 
fec(noeul(:,2),noeul(:,3),trianl,(1:N+1)',"030"," ",rect);
 
//because of isoview
 
[rect1,rect]=xgetech();
 
meshvisu(rect)
 
halt();
 
xbasc()
 
 
 
 
 
 
 
// A small example of MESH Creation
 
// and visualisation of a linear on triangles function
 
getf('SCI/demos/fec/macros.sci')
 
xset("use color",0);
 
flag1=x_choose(['Yes';'No'],'Have you a color display');
 
if flag1=1;xset("use color",1);end
 
// An more complex example from NSCK2E  (Inria)
 
// With a Mesh of amdba type
 
path='SCI/demos/fec/';
 
amdbaR(path+'MESH')
 
meshvisu()
 
halt()
 
xbasc()
 
xset("use color",1)
 
emc2C(1,6,path+'MESH.VAL')
 
halt()
 
xbasc()
 
xset("use color",1)
 
emc2C(1,6,path+'MESH.VAL',[-2,-2,2,2])
 
halt()
 
xbasc()
 
 ans  =
 
    0.  
 
mode(0)
 
xselect();xbasc();
 
//
 
getf('SCI/demos/pendulum/macros.sci','c')
 
//
 
x_message('the cart')
 
// ----------------
 
//
 
 xselect();
 
 dpnd()
 
//
 
// equations
 
//----------
 
//state =[x x' theta theta']
 
//
 
 mb=0.1;mc=1;l=0.3;m=4*mc+mb;//constants
 
//
 
x_message('open loop simulation');
 
//
 
 y0=[0;0;0.1;0];
 
// y=ode(y0,0,0.03*(1:180),ivpd);
 
 y=read('SCI/demos/pendulum/yy',4,180,'(e12.6)');
 
 xbasc();
 
 anim(y(1,:),y(3,:),1);
 
//
 
x_message('linearization')
 
//
 
 x0=[0;0;0;0];u0=0;
 
 [f,g,h,j]=lin(pendu,x0,u0);
 
 pe=syslin('c',f,g,h,j);ssprint(pe)
 
    | 0  1  0          0 |    | 0         |    
.   | 0  0 -0.7178049  0 |    | 0.9756098 |    
x = | 0  0  0          1 |x + | 0         |u   
    | 0  0  52.639024  0 |    |-4.8780488 |    
 
    | 1  0  0  0 |    | 0 |    
y = | 0  0  1  0 |x + | 0 |u   
 
//
 
x_message('checking the result');
 
//
 
 f1=[0 1        0             0
    0 0    -3*mb*9.81/m         0
    0 0        0             1
    0 0  6*(mb+mc)*9.81/(m*l)   0];
 
 g1=[0 ; 4/m ; 0 ; -6/(m*l)];
 
 h1=[1 0 0 0
     0 0 1 0];
 
 norm(f-f1,1)+norm(g-g1,1)+norm(h-h1,1)+norm(j,1)
 ans  =
 
    1.113D-14  
 
 
x_message('analysis');
 
//---------
 
//unstable system !
 
//
 
 spec(f)
 ans  =
 
! - 7.2552756              !
!   7.2552756              !
! - 6.232D-17 + 7.911D-09i !
! - 6.232D-17 - 7.911D-09i !
 
//
 
//controlability
 
//
 
 n=contr(f,g)
 n  =
 
    4.  
 
//
 
//observability
 
//
 
 m1=contr(f',h(1,:)')
 m1  =
 
    4.  
 
//
 
 [m2,t]=contr(f',h(2,:)')
 t  =
 
!   0.    0.    1.    0. !
!   0.    0.    0.  - 1. !
!   1.    0.    0.    0. !
!   0.  - 1.    0.    0. !
 m2  =
 
    2.  
 
 
//
 
x_message('synthesis of a stabilizing controller');
 
//-------------------------------------------------
 
//
 
//pole placement technique
 
//only x and theta are observed  : contruction of an observer
 
//to estimate the state : z'=(f-k*h)*z+k*y+g*u
 
//
 
 to=0.1;  //
 
 k=ppol(f',h',-ones(4,1)/to)'  //observer gain
 k  =
 
!   20.     0.        !
!   100.  - 0.7178049 !
!   0.      20.       !
!   0.      152.63902 !
 
//
 
//verification
 
//
 
// norm( poly(f-k*h,'z')-poly(-ones(4,1)/to,'z'))
 
//
 
 kr=ppol(f,g,-ones(4,1)/to)  //compensator gain
 kr  =
 
! - 208.97044  - 83.588175  - 175.58509  - 24.917635 !
 
 
//
 
x_message('linear system  pendulum-observer-compensator')
 
//---------------------------------------------
 
//
 
//state: [x x-z]
 
//
 
 ft=[f-g*kr            -g*kr
      0*f               f-k*h]
 ft  =
 
 
        columns    1 to   5
 
 
!   0.          1.           0.           0.           0.       !
!   203.8736    81.549439    170.58472    24.309888    203.8736 !
!   0.          0.           0.           1.           0.       !
! - 1019.368  - 407.7472   - 803.8736   - 121.54944  - 1019.368 !
!   0.          0.           0.           0.         - 20.      !
!   0.          0.           0.           0.         - 100.     !
!   0.          0.           0.           0.           0.       !
!   0.          0.           0.           0.           0.       !
 
        columns    6 to   8
 
 
!   0.           0.           0.        !
!   81.549439    171.30252    24.309888 !
!   0.           0.           0.        !
! - 407.7472   - 856.51262  - 121.54944 !
!   1.           0.           0.        !
!   0.           0.           0.        !
!   0.         - 20.          1.        !
!   0.         -100.          0.        !
 
 gt=[g;0*g];
 
 ht=[h,0*h];
 
 pr=syslin('c',ft,gt,ht);
 
 
// closed loop dynamics:
 
 spec(pr(2))
 ans  =
 
! - 10.003567              !
! - 9.9999985 + 0.0035660i !
! - 9.9999985 - 0.0035660i !
! - 9.9964354              !
! - 10.                    !
! - 9.9999999              !
! -10. + 3.072D-07i        !
! -10. - 3.072D-07i        !
 
//transfer matrix representation
 
 hr=clean(ss2tf(pr),1.d-10)
 hr  =
 
!                            2     !
!    - 47.853659 + 0.9756098s      !
!   ----------------------------   !
!                      2     3   4 !
!  10000 + 4000s + 600s + 40s + s  !
!                                  !
!                      2           !
!          - 4.8780488s            !
!   ----------------------------   !
!                      2     3   4 !
!  10000 + 4000s + 600s + 40s + s  !
 
 
 
 //frequency analysis
 
 // black(pr,0.01,100,['position','theta'])
 
 g_margin(pr(1,1))
 ans  =
 
    48.789038  
 
 
 
//
 
x_message('sampled system')
 
//---------------
 
//
 
 t=to/5;
 
 prd=dscr(pr,t);
 
 spec(prd(2))
 ans  =
 
!   0.8186797              !
!   0.8187308 + 0.0000511i !
!   0.8187308 - 0.0000511i !
!   0.8187818              !
!   0.8180104              !
!   0.8187308              !
!   0.8181316 + 0.0396356i !
!   0.8181316 - 0.0396356i !
 
 
//
 
x_message('impulse response')
 
//-----------------
 
//
 
 x0=[0;0;0;0;0;0;0;0];
 
 u(1,180)=0;u(1,1)=1;
 
 y=flts(u,prd,x0);
 
[xxr,yyr]=xgetech();
 
[xxf]=xget("font");
 
 xset("wdim",850,650);
 
 xbasc();
 
 xset("font",2,0);
 
 xsetech([0,0,0.5,0.5]);
 
 plot2d1("enn",1,y(1,:)');xtitle(' ','t',' position');
 
 xsetech([0.5,0,0.5,0.5]);
 
 plot2d1("enn",1,y(2,:)');xtitle(' ','t',' theta');
 
 xsetech([0,0.5,1.0,0.5]);
 
 anim(100*y(1,:),100*y(2,:),1),
 
 xsetech(xxr);
 
 xset("font",xxf(1),xxf(2));
 
//
 
x_message('compensation of the non linear system');
 
//--------------------------------------
 
//
 
//simulation
 
//
 
 t0=0;t1=t*(1:125);
 
 x0=[0 0 0.4 0   0 0 0 0]';   //
 
 yd=ode(x0,t0,t1,regu);
 
//
 
x_message('non linear simulation')
 
[xxr,yyr]=xgetech();
 
[xxf]=xget("font");
 
 xbasc();
 
 xset("font",2,0);
 
 xsetech([0,0,0.5,0.5]);
 
 plot2d(t1',(kr*yd(5:8,:))');xtitle(' ','time','control');
 
 xsetech([0.5,0,0.5,0.5]);
 
 plot2d([t1;t1]',yd([3,7],:)',[-1,-2],"121",'theta@theta estimated');
 
 xsetech([0,0.5,1.0,0.5]);
 
 anim(yd(1,:),yd(3,:),1)
 
 xsetech(xxr);
 
 xset("font",xxf(1),xxf(2));
 
 xbasc();
 
 
 
mode(0);
 
xbasc();
 
getf('SCI/demos/flat/fcts.sci','c')
 
getf("SCI/demos/flat/car.sci','c')
 
//x_message(['Click OK to load data ';'please be patient']);
 
demolist=['Car  ';
          'Two trailers truck ';];
 
go_on=%t;
 
while go_on then
  num=x_choose(demolist(:,1),'Choose a vehicle');
  if num=0 then go_on=%f;
  else
     select num
     case 1 then
     ystr=[ 'x_0'; 'y_0'; 'theta (direction) ' ; 'phi (steering wheel)'];
     xstart=evstr(x_mdialog(['Choose initial state'],...
                 ystr,string([0;4;%pi/3;-%pi/6])));
     xbasc();
     mvcr(xstart(1),xstart(2),xstart(3),xstart(4));
     case 2 then
     ystr=[ 'x2';'y2';'theta2 ' ;'theta12';'theta01'; 'phi'];
     xstart=evstr(x_mdialog(['Choose initial state'],...
                 ystr,string([-2;3;%pi/6;0;0;1])));
     xbasc();
     mvcr2T(xstart(1),xstart(2),xstart(3),xstart(4),xstart(5),xstart(6));
     end;
  end,
end;
 
 
 
path="SCI/demos/wheel2";
 
mode(-1);
 
getf(path+'/show.sci','c');
 
xbasc();
 
flag1=x_choose(['Reading a precomputed trajectory';
 'Simulation with ode (needs f77 and link. may fail, see help link)'],...
'Simulation or Visualisation ? (click below)');
 
 
select flag1,
 case 2 then host("cd $"+path+"; make ");
mode(0);
	if ~c_link('wheel') then link('/tmp/wheel.o ','wheel');end
	if ~c_link('wheelg') then link('/tmp/wheelg.o ','wheelg');end
	wheelg=wheelgf;
	tmin=0.0;tmax=15;nn=300;
	times=(0:(nn-1));
	times=tmax*times/(nn-1) +tmin*((nn-1)*ones(times)-times);
	//               INITIAL CONDITIONS
	x0=[0;                 	//theta
  		%pi/2+0.1;   	//phi
    		0;              //psi
    		5.0;        	//Dtheta
    		0.0;          	//Dphi
   		4.0;         	//Dpsi
    		0;           	//x
    		0];           	//y
	//               SIMULATION
	x=ode(x0,tmin,times,'wheel');
	xselect();
	xbasc();
	show(x)
	ystr=[ 'phi';'theta';'psi';'Dpsi';'Dtheta';'Dpsi';'x';'y'];
        flag=2;
	while flag=2, [n1,n2]=size(x);
  		flag=x_choose(['Stop';'Go on'],'Choose');
                if flag=2,x0=evstr(x_mdialog(['Initial conditions'],...
                      ystr,string(x(:,n2))));
  		x=ode(x0,tmin,times,'wheel');
  		xbasc();show(x);
		end;
	end
 case 1 then // A precomputed value for
	     //x0=[0;%pi/2+0.1;0;5.0;0.0;4.0;0;0];
	x=read(path+'/x.wrt',8,301);
	wheelg=wheelgs;
	show(x);
end
 
 
 
 
path="SCI/demos/wheel2";
 
mode(-1);
 
getf(path+'/show.sci','c');
 
xbasc();
 
flag1=x_choose(['Reading a precomputed trajectory';
 'Simulation with ode (needs f77 and link. may fail, see help link)'],...
'Simulation or Visualisation ? (click below)');
 
 
select flag1,
 case 2 then host("cd $"+path+"; make ");
mode(0);
	if ~c_link('wheel') then link('/tmp/wheel.o ','wheel');end
	if ~c_link('wheelg') then link('/tmp/wheelg.o ','wheelg');end
	wheelg=wheelgf;
	tmin=0.0;tmax=15;nn=300;
	times=(0:(nn-1));
	times=tmax*times/(nn-1) +tmin*((nn-1)*ones(times)-times);
	//               INITIAL CONDITIONS
	x0=[0;                 	//theta
  		%pi/2+0.1;   	//phi
    		0;              //psi
    		5.0;        	//Dtheta
    		0.0;          	//Dphi
   		4.0;         	//Dpsi
    		0;           	//x
    		0];           	//y
	//               SIMULATION
	x=ode(x0,tmin,times,'wheel');
	xselect();
	xbasc();
	show(x)
	ystr=[ 'phi';'theta';'psi';'Dpsi';'Dtheta';'Dpsi';'x';'y'];
        flag=2;
	while flag=2, [n1,n2]=size(x);
  		flag=x_choose(['Stop';'Go on'],'Choose');
                if flag=2,x0=evstr(x_mdialog(['Initial conditions'],...
                      ystr,string(x(:,n2))));
  		x=ode(x0,tmin,times,'wheel');
  		xbasc();show(x);
		end;
	end
 case 1 then // A precomputed value for
	     //x0=[0;%pi/2+0.1;0;5.0;0.0;4.0;0;0];
	x=read(path+'/x.wrt',8,301);
	wheelg=wheelgs;
	show(x);
end
 
 
 
 
// This is just a graphic demo of the bike
 
mode(0);
 
xbasc();
 
path='SCI/demos/bike/';
 
x_message(['Click OK to load data ';'please be patient']);
 
 
x=read(path+'data/'+'x1.dat',46,368,"(e24.18)");
 
 
getf(path+'macros/'+'velo1.sci','c');
 
getf(path+'macros/'+'velo2.sci','c');
 
getf(path+'macros/'+'velo3.sci','c');
 
getf(path+'macros/'+'velo4.sci','c');
 
getf(path+'macros/'+'velo4p.sci','c');
 
getf(path+'macros/'+'velo5.sci','c');
 
getf(path+'macros/'+'velod.sci','c');
 
getf(path+'macros/'+'velodp.sci','c');
 
getf(path+'macros/'+'show.sci','c');
 
demolist=['bike-1: xpoly (full wheels)';
            'bike-2: param3d';
            'bike-3';
            'bike-4: xpoly + xgeom';
            'bike-4p: xpoly + xgeom + obstacles';
            'bike-5'];
 
go_on=%t;
 
while go_on then
  num=x_choose(demolist(:,1),'Choose a bike');
  if num=0 then go_on=%f;
  else
     select num
     case 1 then xbasc();show(x(:,300:368),1,1,velo1)
     case 2 then xbasc();show(x(:,300:368),1,1,velo2)
     case 3 then xbasc();show(x(:,300:368),1,1,velo3)
     case 4 then xbasc();show(x(:,300:368),1,1,velo4)
     case 5 then xbasc();show(x(:,300:368),1,1,velo4p)
     case 6 then xbasc();show(x(:,300:368),1,1,velo5)
     end;
  end,
end
 
 
 
 
mode(0);
 
path='SCI/demos/bike/';
 
xbasc();
 
x_message(['Click OK to load data ';'please be patient']);
 
 
getf(path+'macros/'+'velo1.sci','c');
 
getf(path+'macros/'+'velod.sci','c');
 
getf(path+'macros/'+'velodp.sci','c');
 
getf(path+'macros/'+'show.sci','c');
 
 
x=read(path+'data/'+'xdemo.dat',46,401,"(e24.18)");
 
show(x(:,1:340),1.6,1.47,velo1)
 
 
 
 
//function signal()
 
mode(0)
 
xbasc();
 
getf('SCI/demos/signal/spect.dem');
 
getf('SCI/demos/signal/remezfilt.dem');
 
demolist=['Spectral Estimation ';
          'IIR filter design ';
          'Minimax FIR filter design'];
 
while %t then
  num=x_choose(demolist(:,1),'Choose a topic');
  if num=0 then
     break;
  else
     select num
     case 1 then
       spectdem();
     case 2 then
       ystr=[ 'type (lp, hp, bp, sb) ';
              'order (integer)';
              'design (butt, cheb1, cheb2 , ellip)' ;
              'cut-off frequencies (2-vector in [0, 0.5])';
              'error values  0 delta(1),delta(2) 1 '];
       w=x_mdialog('Choose filter type and parameters',...
                 ystr,['bp';'3';'ellip';'0.15 0.25';'0.08 0.035']);
       hz=iir(evstr(w(2)),w(1),w(3),evstr(w(4)),evstr(w(5)));
       [hzm,fr]=frmag(hz,256);
       xselect();xbasc();
       plot2d(fr',hzm')
       xtitle('Discrete IIR filter '+'( '+ w(3)+' ) ',' ',' ');
     case 3 then
       xbasc();xselect();
       remezfilt();
     end;
  end,
end;
 
 
 
 
 
 
mode(-1)
 
getf('SCI/demos/transl/printspecs.sci','c')
 
deff('[]=message(txt)','write(%io(2),txt)')
 
//[num]=x_choose(tochoose,comment)
 
n=x_choose(['Clauses, loops and operations';
          'Matrix concatenation';
          'Concatenations and inversions';
          'Call of simple primitives';
          'Operation with complex numbers';
          'Matrix divisions ';
          ],'Which macro is to be translated ?')
 n  =
 
    1.  
 
if n==0 then return,end
 
nam='t'+string(n)
 nam  =
 
 t1   
 
select n,
case 1 then,
deff('[x]=t1(a,b,n)',[
'z=n+m+n,'
'c(1,1)=z,'
'c(2,1)=z+1,'
'c(1,2)=2,'
'c(2,2)=0,'
'if n=1 then,'
' x=a+b+a,'
'else,'
' x=a+b-a''+b,'
'end,'
'y=a(3,z+1)-x(z,5),'
'x=2*x*x*2.21,'
'sel=1:5,'
't=a*b,'
'for k=1:n,'
' z1=z*a(k+1,k)+3,'
'end,'
't(sel,5)=a(2:4,7),'
'x=[a b;-b'' a'']'])
//
lt1=list();
lt1(1)=list('1','m','m');
lt1(2)=list('1','m','m');
lt1(3)=list('0','1','1');
printspecs(t1,lt1)
 
Now translation is made...
 
comp(t1);
txt=mac2for(macr2lst(t1),lt1);
message(txt)
       subroutine t1(a,b,n,x,m,work,iwork)
c!
c automatic translation
c
c!     calling sequence
c      ----------------
c
c      a : double precision variableof size m,m
c      b : double precision variableof size m,m
c      n : integer variable 
c      x : double precision variableof size m+m,m+m
c      m : integer variable 
c      work  : working array :
c              max(m*m,m*m+m*m+m*m)+m*m
c      iwork : working array :
c              3
c
c      dimension of local variables 
c      -----------------------------
c        t : size (m,m), implemented in work(iwt)
c!
       double precision a(m,m),b(m,m),x(m+m,m+m),y,z1,24(m,m),work(*)
       integer n,m,z,c(2,2),sel(5),k,iwork(*)
c
c      adress of local variables
       iwt = 1
c
       iw0 = iwt+m*m
       iiw0 = 1
c
       z = n+m+n
       c(1,1)=z
       c(2,1)=z+1
       c(1,2)=2
       c(2,2)=0
       if(n.eq.1) then
c
          iw1 = iw0+m*m
          call dadd(m*m,a,1,b,1,work(iw1),1))
          call dadd(m*m,work(iw1),1,a,1,x,1))
       else
c
          iw1 = iw0+m*m
          call dadd(m*m,a,1,b,1,work(iw1),1))
          iw2 = iw1+m*m
          call mtran(a,m,work(iw2),m,m,m)
          iw3 = iw2+m*m
          call ddif(m*m,work(iw1),1,work(iw2),1,work(iw3),1)
          call dadd(m*m,work(iw3),1,b,1,x,1))
       endif
c
       y = a(3,z+1)-x(z,5)
       iw1 = iw0+m*m
       call dcopy(m*m,x,1,work(iw1),1)
       call dscal(m*m,2D0,work(iw1),1)
       iw2 = iw1+m*m
       call dmmul(work(iw1),m,x,m,work(iw2),m,m,m,m)
       call dcopy(m*m,work(iw2),1,x,1)
       call dscal(m*m,2.21,x,1)
       call ivimp(1,5,1,sel)
       call dmmul(a,m,b,m,work(iwt),m,m,m,m)
       do 20     k = 1,n
c
          z1 = dble(z)*a(k+1,k)+3
20    continue
c
       iiw1 = iiw0+3
       call ivimp(2,4,1,iwork(iiw1))
       iw1 = iw0+3
       call dmext(a,m,m,iwork(iiw1),3,7,1,work(iw1))
       call dmins(work(iwt),m,m,sel,5,5,1,work(iw1),3)
       iw1 = iw0+m*m
       call mtran(b,m,work(iw1),m,m,m)
       iw1 = iw0+m*m
       call mtran(b,m,work(iw1),m,m,m)
       call dscal(m*m,-1.0d0,work(iw1),1)
       call mtran(a,m,work(iw1),m,m,m)
       call dmcopy(a,m,x(1,1),m+m,m,m)
       call dmcopy(b,m,x(1,m+1),m+m,m,m)
       call dmcopy(work(iw1),m,x(m+1,1),m+m,m,m)
       call dmcopy(work(iw1),m,x(m+1,m+1),m+m,m,m)
       return
c
       end
case 2 then,
deff('[x]=t2(a,b,c,d)',[
'z=[a b b],'
'y=[a;c;c],'
'x=[a b;c d]*3.5'])
lt2=list();
lt2(1)=list('1','m1','n1');
lt2(2)=list('1','m1','n2');
lt2(3)=list('1','m2','n1');
lt2(4)=list('1','m2','n2');
printspecs(t2,lt2)
comp(t2);
txt=mac2for(macr2lst(t2),lt2);
message(txt)
case 3 then,
deff('[x]=t3(a,b,c,d)','x=[a;c]/[a b;c d]*3.5')
lt3=list();
lt3(1)=list('1','m1','n1');
lt3(2)=list('1','m1','n2');
lt3(3)=list('1','m2','n1');
lt3(4)=list('1','m2','n2');
printspecs(t3,lt3)
comp(t3);
txt=mac2for(macr2lst(t3),lt3);
message(txt)
case 4 then,
deff('[x]=t4(a,n)',[
'[lhs,rhs]=argn(0),'
'[m,n]=size(a),'
'if m=n then error(''incorrect dimensions ''),end,'
'x=sin(a),'
'u=norm(x),'
'if u=%eps then x=x/u,end,'])
lt4=list();
lt4(1)=list('1','m1','n1');
printspecs(t4,lt4)
comp(t4);
txt=mac2for(macr2lst(t4),lt4);
message(txt)
case 5 then,
deff('[x]=t5(a,b)','x=a+%i*b')
lt5=list();
lt5(1)=list('1','m1','n1',0);
lt5(2)=list('1','m1','n1',0);
printspecs(t5,lt5)
comp(t5);
txt=mac2for(macr2lst(t5),lt5);
message(txt);
case 6 then,
deff('[x]=t(a,b)',[
'c=b*b,'
'x=(a/b)/2+2/c,'])
lt=list();
lt(1)=list('1','na','ma');
lt(2)=list('1','ma','ma');
printspecs(t,lt)
comp(t);
txt=mac2for(macr2lst(t),lt);
message(txt)
end
 
 
 
 
 
 
 
mode(-1)
 
getf('SCI/demos/transl/printspecs.sci','c')
 
deff('[]=message(txt)','write(%io(2),txt)')
 
//[num]=x_choose(tochoose,comment)
 
n=x_choose(['Clauses, loops and operations';
          'Matrix concatenation';
          'Concatenations and inversions';
          'Call of simple primitives';
          'Operation with complex numbers';
          'Matrix divisions ';
          ],'Which macro is to be translated ?')
 n  =
 
    2.  
 
if n==0 then return,end
 
nam='t'+string(n)
 nam  =
 
 t2   
 
select n,
case 1 then,
deff('[x]=t1(a,b,n)',[
'z=n+m+n,'
'c(1,1)=z,'
'c(2,1)=z+1,'
'c(1,2)=2,'
'c(2,2)=0,'
'if n=1 then,'
' x=a+b+a,'
'else,'
' x=a+b-a''+b,'
'end,'
'y=a(3,z+1)-x(z,5),'
'x=2*x*x*2.21,'
'sel=1:5,'
't=a*b,'
'for k=1:n,'
' z1=z*a(k+1,k)+3,'
'end,'
't(sel,5)=a(2:4,7),'
'x=[a b;-b'' a'']'])
//
lt1=list();
lt1(1)=list('1','m','m');
lt1(2)=list('1','m','m');
lt1(3)=list('0','1','1');
printspecs(t1,lt1)
comp(t1);
txt=mac2for(macr2lst(t1),lt1);
message(txt)
case 2 then,
deff('[x]=t2(a,b,c,d)',[
'z=[a b b],'
'y=[a;c;c],'
'x=[a b;c d]*3.5'])
lt2=list();
lt2(1)=list('1','m1','n1');
lt2(2)=list('1','m1','n2');
lt2(3)=list('1','m2','n1');
lt2(4)=list('1','m2','n2');
printspecs(t2,lt2)
 
Now translation is made...
 
comp(t2);
txt=mac2for(macr2lst(t2),lt2);
message(txt)
       subroutine t2(a,b,c,d,x,m1,n1,n2,m2,work)
c!
c automatic translation
c
c!     calling sequence
c      ----------------
c
c      a : double precision variableof size m1,n1
c      b : double precision variableof size m1,n2
c      c : double precision variableof size m2,n1
c      d : double precision variableof size m2,n2
c      x : double precision variableof size m1+m2,n1+n2
c      m1 : integer variable 
c      n1 : integer variable 
c      n2 : integer variable 
c      m2 : integer variable 
c      work  : working array :
c              (m1+m2)*(n1+n2)+(m1+m1+m1)*n1+(m1+m2+m2)*n1
c
c      dimension of local variables 
c      -----------------------------
c        z : size (m1+m1+m1,n1), implemented in work(iwz)
c        y : size (m1+m2+m2,n1), implemented in work(iwy)
c!
       double precision a(m1,n1),b(m1,n2),c(m2,n1),d(m2,n2),x(m1+m2,n1+n
     & 2),work(*)
       integer m1,n1,n2,m2
c
c      adress of local variables
       iwz = 1
       iwy = iwz+(m1+m1+m1)*n1
c
       iw0 = iwy+(m1+m2+m2)*n1
c
       call dmcopy(a,n1,work(iwz+1),m1+m1+m1,n1,m1)
       call dmcopy(b,n2,work(iwz+m1+1),m1+m1+m1,n2,m1)
       call dmcopy(b,n2,work(iwz+m1+m1+1),m1+m1+m1,n2,m1)
       call dmcopy(a,n1,work(iwy+1),m1+m2+m2,n1,m1)
       call dmcopy(c,n1,work(iwy+m1+1),m1+m2+m2,n1,m2)
       call dmcopy(c,n1,work(iwy+m2+m1+1),m1+m2+m2,n1,m2)
       iw1 = iw0+(m1+m2)*(n1+n2)
       call dmcopy(a,n1,work(iw1+1),m1+m2,n1,m1)
       call dmcopy(b,n2,work(iw1+n1*(m1+m2)+1),m1+m2,n2,m1)
       call dmcopy(c,n1,work(iw1+m1+1),m1+m2,n1,m2)
       call dmcopy(d,n2,work(iw1+n1*(m1+m2)+m1+1),m1+m2,n2,m2)
       call dcopy((m1+m2)*(n1+n2),work(iw1),1,x,1)
       call dscal((m1+m2)*(n1+n2),3.5,x,1)
       return
c
       end
case 3 then,
deff('[x]=t3(a,b,c,d)','x=[a;c]/[a b;c d]*3.5')
lt3=list();
lt3(1)=list('1','m1','n1');
lt3(2)=list('1','m1','n2');
lt3(3)=list('1','m2','n1');
lt3(4)=list('1','m2','n2');
printspecs(t3,lt3)
comp(t3);
txt=mac2for(macr2lst(t3),lt3);
message(txt)
case 4 then,
deff('[x]=t4(a,n)',[
'[lhs,rhs]=argn(0),'
'[m,n]=size(a),'
'if m=n then error(''incorrect dimensions ''),end,'
'x=sin(a),'
'u=norm(x),'
'if u=%eps then x=x/u,end,'])
lt4=list();
lt4(1)=list('1','m1','n1');
printspecs(t4,lt4)
comp(t4);
txt=mac2for(macr2lst(t4),lt4);
message(txt)
case 5 then,
deff('[x]=t5(a,b)','x=a+%i*b')
lt5=list();
lt5(1)=list('1','m1','n1',0);
lt5(2)=list('1','m1','n1',0);
printspecs(t5,lt5)
comp(t5);
txt=mac2for(macr2lst(t5),lt5);
message(txt);
case 6 then,
deff('[x]=t(a,b)',[
'c=b*b,'
'x=(a/b)/2+2/c,'])
lt=list();
lt(1)=list('1','na','ma');
lt(2)=list('1','ma','ma');
printspecs(t,lt)
comp(t);
txt=mac2for(macr2lst(t),lt);
message(txt)
end
 
 
 
 
 
 
 
mode(-1)
 
getf('SCI/demos/transl/printspecs.sci','c')
 
deff('[]=message(txt)','write(%io(2),txt)')
 
//[num]=x_choose(tochoose,comment)
 
n=x_choose(['Clauses, loops and operations';
          'Matrix concatenation';
          'Concatenations and inversions';
          'Call of simple primitives';
          'Operation with complex numbers';
          'Matrix divisions ';
          ],'Which macro is to be translated ?')
 n  =
 
    3.  
 
if n==0 then return,end
 
nam='t'+string(n)
 nam  =
 
 t3   
 
select n,
case 1 then,
deff('[x]=t1(a,b,n)',[
'z=n+m+n,'
'c(1,1)=z,'
'c(2,1)=z+1,'
'c(1,2)=2,'
'c(2,2)=0,'
'if n=1 then,'
' x=a+b+a,'
'else,'
' x=a+b-a''+b,'
'end,'
'y=a(3,z+1)-x(z,5),'
'x=2*x*x*2.21,'
'sel=1:5,'
't=a*b,'
'for k=1:n,'
' z1=z*a(k+1,k)+3,'
'end,'
't(sel,5)=a(2:4,7),'
'x=[a b;-b'' a'']'])
//
lt1=list();
lt1(1)=list('1','m','m');
lt1(2)=list('1','m','m');
lt1(3)=list('0','1','1');
printspecs(t1,lt1)
comp(t1);
txt=mac2for(macr2lst(t1),lt1);
message(txt)
case 2 then,
deff('[x]=t2(a,b,c,d)',[
'z=[a b b],'
'y=[a;c;c],'
'x=[a b;c d]*3.5'])
lt2=list();
lt2(1)=list('1','m1','n1');
lt2(2)=list('1','m1','n2');
lt2(3)=list('1','m2','n1');
lt2(4)=list('1','m2','n2');
printspecs(t2,lt2)
comp(t2);
txt=mac2for(macr2lst(t2),lt2);
message(txt)
case 3 then,
deff('[x]=t3(a,b,c,d)','x=[a;c]/[a b;c d]*3.5')
lt3=list();
lt3(1)=list('1','m1','n1');
lt3(2)=list('1','m1','n2');
lt3(3)=list('1','m2','n1');
lt3(4)=list('1','m2','n2');
printspecs(t3,lt3)
 
Now translation is made...
 
comp(t3);
txt=mac2for(macr2lst(t3),lt3);
message(txt)
       subroutine t3(a,b,c,d,x,m1,n1,n2,m2,work,iwork,ierr)
c!
c automatic translation
c
c!     calling sequence
c      ----------------
c
c      a : double precision variableof size m1,n1
c      b : double precision variableof size m1,n2
c      c : double precision variableof size m2,n1
c      d : double precision variableof size m2,n2
c      x : double precision variableof size m1+m2,n1
c      m1 : integer variable 
c      n1 : integer variable 
c      n2 : integer variable 
c      m2 : integer variable 
c      work  : working array :
c              (m1+m2)*n1+(m1+m2)*(n1+n2)+(m1+m2)*(n1+n2)+(m1+m2)*(m1+m2
c              )+m1+m2
c      iwork : working array :
c              m1+m2
c      ierr : error 
c             0 :  correct run
c             1 : singular work(iw1) matrix
c!
       double precision a(m1,n1),b(m1,n2),c(m2,n1),d(m2,n2),x(m1+m2,n1),
     & work(*)
       integer m1,n1,n2,m2,iwork(*)
c
       iw0 = 1
       iiw0 = 1
c
       iw0 = iw+(m1+m2)*n1-1
       call dmcopy(a,n1,work(iw0+1),m1+m2,n1,m1)
       call dmcopy(c,n1,work(iw0+m1+1),m1+m2,n1,m2)
       iw1 = iw0+(m1+m2)*(n1+n2)
       call dmcopy(a,n1,work(iw1+1),m1+m2,n1,m1)
       call dmcopy(b,n2,work(iw1+n1*(m1+m2)+1),m1+m2,n2,m1)
       call dmcopy(c,n1,work(iw1+m1+1),m1+m2,n1,m2)
       call dmcopy(d,n2,work(iw1+n1*(m1+m2)+m1+1),m1+m2,n2,m2)
       iw2 = iw1+(m1+m2)*(n1+n2)
       iw3 = iw2+(m1+m2)*(m1+m2)
       iw4 = iw3+m1+m2
       call dcopy((m1+m2)*(n1+n2),work(iw1),1,work(iw3),1)
       call dgefa(work(iw3),m1+m2,n1+n2,iwork(iiw0),ierr)
       if(ierr.ne.0) then
          ierr=1
          return
       endif
       call dgesl(work(iw3),m1+m2,n1+n2,iwork(iiw0),work(iw2),0)
       call dcopy((m1+m2)*n1,work(iw2),1,x,1)
       call dscal((m1+m2)*n1,3.5,x,1)
       return
c
       end
case 4 then,
deff('[x]=t4(a,n)',[
'[lhs,rhs]=argn(0),'
'[m,n]=size(a),'
'if m=n then error(''incorrect dimensions ''),end,'
'x=sin(a),'
'u=norm(x),'
'if u=%eps then x=x/u,end,'])
lt4=list();
lt4(1)=list('1','m1','n1');
printspecs(t4,lt4)
comp(t4);
txt=mac2for(macr2lst(t4),lt4);
message(txt)
case 5 then,
deff('[x]=t5(a,b)','x=a+%i*b')
lt5=list();
lt5(1)=list('1','m1','n1',0);
lt5(2)=list('1','m1','n1',0);
printspecs(t5,lt5)
comp(t5);
txt=mac2for(macr2lst(t5),lt5);
message(txt);
case 6 then,
deff('[x]=t(a,b)',[
'c=b*b,'
'x=(a/b)/2+2/c,'])
lt=list();
lt(1)=list('1','na','ma');
lt(2)=list('1','ma','ma');
printspecs(t,lt)
comp(t);
txt=mac2for(macr2lst(t),lt);
message(txt)
end
 
 
 
 
 
 
 
mode(-1)
 
getf('SCI/demos/transl/printspecs.sci','c')
 
deff('[]=message(txt)','write(%io(2),txt)')
 
//[num]=x_choose(tochoose,comment)
 
n=x_choose(['Clauses, loops and operations';
          'Matrix concatenation';
          'Concatenations and inversions';
          'Call of simple primitives';
          'Operation with complex numbers';
          'Matrix divisions ';
          ],'Which macro is to be translated ?')
 n  =
 
    4.  
 
if n==0 then return,end
 
nam='t'+string(n)
 nam  =
 
 t4   
 
select n,
case 1 then,
deff('[x]=t1(a,b,n)',[
'z=n+m+n,'
'c(1,1)=z,'
'c(2,1)=z+1,'
'c(1,2)=2,'
'c(2,2)=0,'
'if n=1 then,'
' x=a+b+a,'
'else,'
' x=a+b-a''+b,'
'end,'
'y=a(3,z+1)-x(z,5),'
'x=2*x*x*2.21,'
'sel=1:5,'
't=a*b,'
'for k=1:n,'
' z1=z*a(k+1,k)+3,'
'end,'
't(sel,5)=a(2:4,7),'
'x=[a b;-b'' a'']'])
//
lt1=list();
lt1(1)=list('1','m','m');
lt1(2)=list('1','m','m');
lt1(3)=list('0','1','1');
printspecs(t1,lt1)
comp(t1);
txt=mac2for(macr2lst(t1),lt1);
message(txt)
case 2 then,
deff('[x]=t2(a,b,c,d)',[
'z=[a b b],'
'y=[a;c;c],'
'x=[a b;c d]*3.5'])
lt2=list();
lt2(1)=list('1','m1','n1');
lt2(2)=list('1','m1','n2');
lt2(3)=list('1','m2','n1');
lt2(4)=list('1','m2','n2');
printspecs(t2,lt2)
comp(t2);
txt=mac2for(macr2lst(t2),lt2);
message(txt)
case 3 then,
deff('[x]=t3(a,b,c,d)','x=[a;c]/[a b;c d]*3.5')
lt3=list();
lt3(1)=list('1','m1','n1');
lt3(2)=list('1','m1','n2');
lt3(3)=list('1','m2','n1');
lt3(4)=list('1','m2','n2');
printspecs(t3,lt3)
comp(t3);
txt=mac2for(macr2lst(t3),lt3);
message(txt)
case 4 then,
deff('[x]=t4(a,n)',[
'[lhs,rhs]=argn(0),'
'[m,n]=size(a),'
'if m=n then error(''incorrect dimensions ''),end,'
'x=sin(a),'
'u=norm(x),'
'if u=%eps then x=x/u,end,'])
lt4=list();
lt4(1)=list('1','m1','n1');
printspecs(t4,lt4)
 
Now translation is made...
 
comp(t4);
txt=mac2for(macr2lst(t4),lt4);
message(txt)
       subroutine t4(a,x,m1,n1,work,ierr)
c!
c automatic translation
c
c!     calling sequence
c      ----------------
c
c      a : double precision variableof size m1,n1
c      x : double precision variableof size m1,n1
c      m1 : integer variable 
c      n1 : integer variable 
c      work  : working array :
c              min(m1+1,n1)+n1+m1
c      ierr : error 
c             0 :  correct run
c             1 : incorrect dimensions 
c             2 : echec du calcul de la norme
c!
       double precision a(m1,n1),x(m1,n1),u,%eps,d1mach,work(*)
       integer m1,n1,rhs,lhs,n,m
c
       iw0 = 1
       %eps = d1mach(4)
c
c
       rhs = 1
       lhs = 1
       n = m1
       m = n1
       if(m.eq.n) then
          ierr=1
          return
       endif
c
       do 30 ilb30 = 0,n1-1
          do 20 ilb20 = 0,m1-1
             a(ilb20,ilb30) = sin(a(ilb20,ilb30))
20     continue
30     continue
       iw1 = iw0+min(m1+1,n1)
       iw2 = iw1+n1
       iw3 = iw2+m1
       call dsvdc(x,m1,m1,n1,work(iw1),work(iw2),work,m1,work,n1,work(iw
     & 3),00,ierr)
       if(ierr.ne.0) then
          ierr=2
          return
       endif
       u = work(iw1)
       if(u.eq.%eps) then
          call dscal(m1*n1,1.0d0/u,x,1)
       endif
c
       return
c
       end
case 5 then,
deff('[x]=t5(a,b)','x=a+%i*b')
lt5=list();
lt5(1)=list('1','m1','n1',0);
lt5(2)=list('1','m1','n1',0);
printspecs(t5,lt5)
comp(t5);
txt=mac2for(macr2lst(t5),lt5);
message(txt);
case 6 then,
deff('[x]=t(a,b)',[
'c=b*b,'
'x=(a/b)/2+2/c,'])
lt=list();
lt(1)=list('1','na','ma');
lt(2)=list('1','ma','ma');
printspecs(t,lt)
comp(t);
txt=mac2for(macr2lst(t),lt);
message(txt)
end
 
 
 
 
 
 
 
mode(-1)
 
getf('SCI/demos/transl/printspecs.sci','c')
 
deff('[]=message(txt)','write(%io(2),txt)')
 
//[num]=x_choose(tochoose,comment)
 
n=x_choose(['Clauses, loops and operations';
          'Matrix concatenation';
          'Concatenations and inversions';
          'Call of simple primitives';
          'Operation with complex numbers';
          'Matrix divisions ';
          ],'Which macro is to be translated ?')
 n  =
 
    5.  
 
if n==0 then return,end
 
nam='t'+string(n)
 nam  =
 
 t5   
 
select n,
case 1 then,
deff('[x]=t1(a,b,n)',[
'z=n+m+n,'
'c(1,1)=z,'
'c(2,1)=z+1,'
'c(1,2)=2,'
'c(2,2)=0,'
'if n=1 then,'
' x=a+b+a,'
'else,'
' x=a+b-a''+b,'
'end,'
'y=a(3,z+1)-x(z,5),'
'x=2*x*x*2.21,'
'sel=1:5,'
't=a*b,'
'for k=1:n,'
' z1=z*a(k+1,k)+3,'
'end,'
't(sel,5)=a(2:4,7),'
'x=[a b;-b'' a'']'])
//
lt1=list();
lt1(1)=list('1','m','m');
lt1(2)=list('1','m','m');
lt1(3)=list('0','1','1');
printspecs(t1,lt1)
comp(t1);
txt=mac2for(macr2lst(t1),lt1);
message(txt)
case 2 then,
deff('[x]=t2(a,b,c,d)',[
'z=[a b b],'
'y=[a;c;c],'
'x=[a b;c d]*3.5'])
lt2=list();
lt2(1)=list('1','m1','n1');
lt2(2)=list('1','m1','n2');
lt2(3)=list('1','m2','n1');
lt2(4)=list('1','m2','n2');
printspecs(t2,lt2)
comp(t2);
txt=mac2for(macr2lst(t2),lt2);
message(txt)
case 3 then,
deff('[x]=t3(a,b,c,d)','x=[a;c]/[a b;c d]*3.5')
lt3=list();
lt3(1)=list('1','m1','n1');
lt3(2)=list('1','m1','n2');
lt3(3)=list('1','m2','n1');
lt3(4)=list('1','m2','n2');
printspecs(t3,lt3)
comp(t3);
txt=mac2for(macr2lst(t3),lt3);
message(txt)
case 4 then,
deff('[x]=t4(a,n)',[
'[lhs,rhs]=argn(0),'
'[m,n]=size(a),'
'if m=n then error(''incorrect dimensions ''),end,'
'x=sin(a),'
'u=norm(x),'
'if u=%eps then x=x/u,end,'])
lt4=list();
lt4(1)=list('1','m1','n1');
printspecs(t4,lt4)
comp(t4);
txt=mac2for(macr2lst(t4),lt4);
message(txt)
case 5 then,
deff('[x]=t5(a,b)','x=a+%i*b')
lt5=list();
lt5(1)=list('1','m1','n1',0);
lt5(2)=list('1','m1','n1',0);
printspecs(t5,lt5)
 
Now translation is made...
 
comp(t5);
txt=mac2for(macr2lst(t5),lt5);
message(txt);
       subroutine t5(a,b,x_r,x_i,m1,n1)
c!
c automatic translation
c
c!     calling sequence
c      ----------------
c
c      a : double precision variableof size m1,n1
c      b : double precision variableof size m1,n1
c      x(_r,_i) : double precision variableof size m1,n1
c      m1 : integer variable 
c      n1 : integer variable 
c      work  : working array :
c              m1*n1+m1*n1
c!
       double precision a(m1,n1),b(m1,n1),x_r(m1,n1),x_i(m1,n1),work(*)
       integer m1,n1
c
       iw0 = 1
c
       iw1 = iw0+m1*n1
       call dcopy(m1*n1,b,1,work(iw0),1)
       call dcopy(m1*n1,b,1,work(iw1),1)
       call dscal(m1*n1,0.0d0,work(iw0),1)
       call dscal(m1*n1,1.0d0,work(iw1),1)
       call dadd(m1*n1,a,1,work(iw0),1,x_r,1)
       call dcopy(m1*n1,work(iw1),1,x_i,1)
       return
c
       end
case 6 then,
deff('[x]=t(a,b)',[
'c=b*b,'
'x=(a/b)/2+2/c,'])
lt=list();
lt(1)=list('1','na','ma');
lt(2)=list('1','ma','ma');
printspecs(t,lt)
comp(t);
txt=mac2for(macr2lst(t),lt);
message(txt)
end
 
 
 
 
 
 
 
mode(5)
 
//1- Simple Example
 
 xbasc();
 
 deff('[xd]=lin(t,x,a)','xd=a*x')
Warning :redefining function: lin                     
 
 
 a=[1 1;0 2];
 
 ea=ode(eye(2,2),0,1,list(lin,a)),exp(a)
 ea  =
 
!   2.7182818    4.6707744 !
!   0.           7.3890563 !
 ans  =
 
!   2.7182818    4.6707743 !
!   0.           7.3890561 !
 
 
 t=0:0.1:3;
 
 ee=ode(1,0,t,list(lin,1));plot2d1("onn",t',ee',-(1:2),"121",'x1@x2');
 
 xtitle('dx=a*x','t',' ')
 
 halt();xbasc();
 
 
//2- chemical process (stiff)
 
mode(-1)
 
titlepage(['Integration of ODE:';...
        'dy1/dt=-0.04*y1 + 1d4*y2*y3';...
        'dy3/dt= 3d7*y2*y2';...
        'dy2/dt= -dy1/dt - dy3/dt';...
        'finding points such that';...
        'y1=1.e-4 or y3=1.e-2'])
 
 
 rect=[1.d-5,-0.1,1d11,1.1];
 
 deff('[yd]=chem(t,y)',[
                         'yd(1)=-0.04*y(1) + 1d4*y(2)*y(3);';
                         'yd(3)= 3d7*y(2)*y(2);';
                         'yd(2)= -yd(1) - yd(3);'])
 
 
 comp(chem)
 
 mode(1)
 
 t=[1.d-5:0.02:.4 0.41:.1:4 40 400 4000 40000 4d5 4d6 4d7 4d8 4d9 4d10];
 
 rtol=1.d-4;atol=[1.d-6;1.d-10;1.d-6];
 
 y=ode([1;0;0],0,t,rtol,atol,chem);
 
 halt();xbasc();
 
 plot2d1("oln",t',(diag([1 10000 1])*y)',-(1:3),"111",' y1@10000 y2@y3',rect)
 
 halt();
 
 nt=prod(size(t));
 
 deff('[y]=surf(t,x)','y=[x(1)-1.e-4;x(3)-1.e-2]')
 
 comp(surf)
 
 [y,rd,w,iw]=ode('root',[1;0;0],0,t,rtol,atol,chem,2,surf);rd
 rd  =
 
!   0.2640459    2. !
 
 while rd<>[] then0..
  [nw,ny]=size(y);
  k=find(rd(1)>t(1:nt-1)&rd(1)<t(2:nt));..
  write(%io(2),[rd(1);y(:,ny)]','(''t='',e10.3,'' y='',3(e10.3,'',''))')
  plot2d1("oln",rd(1)',(diag([1 10000 1])*y(:,ny))',[3,3,3],"000");
  //mplot([rd(1);rd(1);rd(1)],diag([1 10000 1])*y(:,ny));..
  [y,rd,w,iw]=ode('root',[1;0;0],rd(1),t(k+1:nt),rtol,atol,chem,2,surf,w,iw);..
 end
t= 0.264D+00 y= 0.990D+00, 0.347D-04, 0.100D-01,
t= 0.207D+08 y= 0.100D-03, 0.400D-09, 0.100D+01,
 
halt();xbasc();
 
//implicit
 
mode(-1)
 
//
 
titlepage(['Implicit ODE:';...
          ' ';...
        'dy1/dt=-0.04*y1 + 1d4*y2*y3';...
        'dy2/dt=0.04*y1 - 1d4*y2*y3-3d7*y2*y2';...
        '  1   = y1+y2+y3'])
 
 
 deff('[r]=chemres(t,y,yd)',[
                         'r(1)=-0.04*y(1)+1d4*y(2)*y(3)-yd(1);';
                         'r(2)=0.04*y(1)-1d4*y(2)*y(3)-3d7*y(2)*y(2)-yd(2);'
                         'r(3)=y(1)+y(2)+y(3)-1;'])
 
 
 
 deff('[p]=chemad(t,y,p)','p=p+diag([1 1 0])')
 
 
 deff('[p]=chemjac(t,y,yd)',['p=[-0.04, 1.d4*y(3)        ,1.d4*y(2);';
                            '    0.04,-1d4*y(3)-6d7*y(2),-1d4*y(2);';
                            '    1 ,    1,                  1       ]'])
 
 
write(6,' macro g(t,y)-a(t,y)*ydot')
 macro g(t,y)-a(t,y)*ydot
 
write(6,[' ';' macro  x=a(t,y)+p'])
 
 macro  x=a(t,y)+p
 
write(6,[' ';'jacobian'])
 
jacobian
 
comp(chemres);comp(chemad);comp(chemjac)
 
mode(1)
 
y0=[1;0;0];
 
yd0=[-0.04;0.04;0];
 
t=[1.d-5:0.02:.4 0.41:.1:4 40 400 4000 40000 4d5 4d6 4d7 4d8 4d9 4d10];
 
rtol = 1d-4;atol=[1.d-6;1.d-10;1.d-6];
 
y=impl(y0,yd0,0,t,rtol,atol,chemres,chemad,chemjac);
 
 halt();xbasc();
 
plot2d1("oln",t',(diag([1 10000 1])*y)',-(1:3),"111",'y1@10000 y2@y3',rect)
 
 
mode(-1)
 
 halt();xbasc();
 
 
titlepage('lorenz ode ');
 
 
deff('[ydot]=lorenz(t,y)',...
"x=y(1);...
a=[-10,10,0;28,-1,-x;0,x,-8/3];...
ydot=a*y")
 
deff('[j]=jacobian(t,y)',...
"x=y(1);yy=y(2);z=y(3);...
j=[-10,10,0;28-z,-1,-x;-yy,x,-8/3]")
 
comp(lorenz);comp(jacobian);
 
y0=[-3;-6;12];t0=0;step=0.01;t1=10;
 
instants=t0:step:t1;
 
y=ode(y0,t0,instants,lorenz,jacobian);
 
xbasc(0);param3d(y(1,:),y(2,:),y(3,:))
 
 
 
 
mode(7)
 
//
 
// An example of arma simulation and identification
 
// form ( K.J. Astrom)
 
// The armax process with the following characteristics
 
//    a=[1,-2.851,2.717,-0.865]
 
//    b=[0,1,1,1]
 
//    d=[1,0.7,0.2]
 
// is simulated with an input u of a pseudo random binary type
 
//
 
// We use the simulated trajectory zd
 
// as an input to the armax identification macro
 
// The noise in the armax is coloured so we can expect armax
 
// to give a biaised estimator
 
 
a=[1,-2.851,2.717,-0.865]
 a  =
 
!   1.  - 2.851    2.717  - 0.865 !
 
b=[0,1,1,1]
 b  =
 
!   0.    1.    1.    1. !
 
d=[1,0.7,0.2]
 d  =
 
!   1.    0.7    0.2 !
 
ar=armac(a,b,d,1,1,1);
 
write(%io(2),"Simulation of an ARMAX process:");
Simulation of an ARMAX process:
 
armap(ar);
 
  A(z^-1)y=B(z^-1)u + D(z^-1) e(t)
  
  A(s)= | 1 |s**0  + |-2.851 |s**1  + | 2.717 |s**2  + 
 
           |-0.865 |s**3    
 
  B(s)= | 0 |s**0  + | 1 |s**1  + | 1 |s**2  + | 1 |s**3    
 
 
  D(s)= | 1 |s**0  + | 0.7 |s**1  + | 0.2 |s**2    
 
 
  e(t)=Sig*w(t); w(t) 1-dim white noise
 
  Sig=  | 1 |
 
 
// The input
 
u=-prbs_a(300,1,int([2.5,5,10,17.5,20,22,27,35]*100/12));
 
// simulation with noise
 
zd=narsimul(a,b,d,1.0,u);
 
// simulation without noise
 
z=narsimul(a,b,d,0.0,u);
 
xselect();xbasc();
 
plot2d2("enn",1,zd',[-1,1],"121","Simulated output");
 
plot2d2("enn",1,1000*u',[-1,4],"100","Input [scaled]");
 
halt();
 
write(%io(2),"Identification ARX (least square):");
Identification ARX (least square):
 
[la,lb,sig,resid]=armax(3,3,zd,u,1,1);
 
  A(z^-1)y=B(z^-1)u + D(z^-1) e(t)
  
  A(s)= | 1 |s**0  + |-2.8565475 |s**1  + | 2.7289401 |s**2  + 
 
           |-0.8714191 |s**3    
 
  B(s)= | 0 |s**0  + | 1.1231644 |s**1  + | 1.1039988 |s**2  + 
 
           | 0.7300523 |s**3    
 
  D(s)= | 1 |s**0    
 
  e(t)=Sig*w(t); w(t) 1-dim white noise
 
  Sig=  | 1.2137965 |
 
  Standard deviation of the estimator a :
     0.00000 0.00649 0.01279 0.00635
  Standard deviation of the estimator b :
     0.00000 0.19922 0.27556 0.22419
 
 
// A bidimensional version of the preceding example
 
 
a=[1,-2.851,2.717,-0.865].*.eye(2,2);
 
b=[0,1,1,1].*.[1;1];
 
d=[1,0.7,0.2].*.eye(2,2);
 
sig=eye(2,2);
 
ar=armac(a,b,d,2,1,sig);
 
write(%io(2),"Simulation of an ARMAX process:");
Simulation of an ARMAX process:
 
armap(ar);
 
  A(z^-1)y=B(z^-1)u + D(z^-1) e(t)
  
        | 1  0 |        |-2.851  0     |        | 2.717  0     |        
  A(s)= | 0  1 |s**0  + | 0     -2.851 |s**1  + | 0      2.717 |s**2  + 
 
           |-0.865  0     |        
           | 0     -0.865 |s**3    
 
        | 0 |        | 1 |        | 1 |        | 1 |        
  B(s)= | 0 |s**0  + | 1 |s**1  + | 1 |s**2  + | 1 |s**3    
 
 
        | 1  0 |        | 0.7  0   |        | 0.2  0   |        
  D(s)= | 0  1 |s**0  + | 0    0.7 |s**1  + | 0    0.2 |s**2    
 
 
  e(t)=Sig*w(t); w(t) 2-dim white noise
 
        | 1  0 |
  Sig=  | 0  1 |
 
 
u=-prbs_a(300,1,int([2.5,5,10,17.5,20,22,27,35]*100/12));
 
zd=narsimul(a,b,d,sig,u);
 
z=narsimul(a,b,d,0.0*sig,u);
 
write(%io(2),"Identification ARX (least square):");
Identification ARX (least square):
 
 
[la,lb,sig,resid]=armax(3,3,zd,u,1,1);
 
  A(z^-1)y=B(z^-1)u + D(z^-1) e(t)
  
        | 1  0 |        |-2.865996   0.0019273 |        
  A(s)= | 0  1 |s**0  + | 0.0611174 -2.8947926 |s**1  + 
 
           | 2.7515607 -0.0084053 |        |-0.8842529  0.0060458 |        
           |-0.1260875  2.8100575 |s**2  + | 0.0659146 -0.9150453 |s**3    
 
 
        | 0 |        | 1.2397816 |        | 0.8883811 |        
  B(s)= | 0 |s**0  + | 1.2098573 |s**1  + | 1.1006642 |s**2  + 
 
           | 0.6475448 |        
           | 1.0741868 |s**3    
 
        | 1  0 |        
  D(s)= | 0  1 |s**0    
 
  e(t)=Sig*w(t); w(t) 2-dim white noise
 
        | 1.0793777 -0.0442748 |
  Sig=  |-0.0442748  1.1175016 |
 
 
 
// Spectral power estimation
 
// ( form Sawaragi et all)
 
 
m=18
 m  =
 
    18.  
 
a=[1,-1.3136,1.4401,-1.0919,+0.83527]
 a  =
 
!   1.  - 1.3136    1.4401  - 1.0919    0.83527 !
 
b=[0.0,0.13137,0.023543,0.10775,0.03516]
 b  =
 
!   0.    0.13137    0.023543    0.10775    0.03516 !
 
rand('normal');
 
u=rand(1,1000);
 
z=arsimul(a,b,[0],0,u);
 
//----Using macro mese
 
[sm,fr]=mese(z,m);
 
//----The theorical result
 
deff('[gx]=gxx(z)',['gx=(abs( a* exp(-%i*2*%pi*z*(0:4))'')**2)';...
      'gx=abs( b* exp(-%i*2*%pi*z*(0:4))'')**2/gx']);
 
res=[];
 
for x=fr,res=[ res, gxx(x)];end;
 
//----using armax estimation of order  (4,4)
 
// it's a bit tricky because we are not supposed to know the order
 
//
 
[la,lb,sig,resid]=armax(4,4,z,u);
 
  A(z^-1)y=B(z^-1)u + D(z^-1) e(t)
  
  A(s)= | 1 |s**0  + |-1.3136 |s**1  + | 1.4401 |s**2  + 
 
           |-1.0919 |s**3  + | 0.83527 |s**4    
 
  B(s)= | 0 |s**0  + | 0.13137 |s**1  + | 0.023543 |s**2  + 
 
           | 0.10775 |s**3  + | 0.03516 |s**4    
 
  D(s)= | 1 |s**0    
 
  e(t)=Sig*w(t); w(t) 1-dim white noise
 
  Sig=  | 0 |
 
  Standard deviation of the estimator a :
     0.00000 0.00000 0.00000 0.00000 0.00000
  Standard deviation of the estimator b :
     0.00000 0.00000 0.00000 0.00000 0.00000
 
a=la(1);
 
b=lb(1);
 
res1=[];
 
for x=fr,res1=[ res1, gxx(x)];end;
 
//
 
leg="log(p) :using macro mese @ theoriqal value@log(p) : arma identifcation"
 leg  =
 
 log(p) :using macro mese @ theoriqal value@log(p) : arma identifcation 
 
xbasc();
 
xtitle('Spectral power','frequency','spectral estimate')
 
plot2d([fr;fr;fr]',[20*log(sm/sm(1))/log(10);...
  20*log(res/res(1))/log(10);...
  20*log(res1/res1(1))/log(10)]',...
 [-2,-1,1],"111",leg, [0,-70,0.5,60]);
 
 
 
//rand('seed',0)
 
rand('normal')
 
nx=5;
 
ny=1;
 
nu=3;
 
Plant=ssrand(ny,nu,nx);
 
J=rand(Plant(5));Plant(5)=0*J;
 
[F,G,H,J]=Plant(2:5);
 
nw=4;
 
nuu=2;
 
A=rand(nw,nw);
 
st=maxi(real(spec(A)));A=A-st*eye(A);
 
B=rand(nw,nuu);
 
C=2*rand(ny,nw);
 
D=0*rand(C*B);
 
xx0=0*ones(nw,1);
 
Model=syslin('c',A,B,C,D,xx0);
 
// Input to Model (t is a vector), nuu components
 
deff('[ut]=uu(t)','ut=[sin(3*t);cos(0.5*t)]');comp(uu);
 
// Signal to track
 
dt=0.05;tmax=60;
 
instants=0:dt:tmax;
 
totrack=flts(uu(instants),dscr(Model,dt));    //Signal
 
xbasc();
 
//plot2d(instants',totrack');
 
[L,M,T]=gfrancis(Plant,Model);
 
 
//    Stabilizing the plant
 
K=-ppol(F,G,-0.3*ones(1,nx));
 
 
//[K,L,M,err]=deskre(Plant,Model,-0.3,-0.5,100);T=0*T;
 
// Bigsyst= closed loop system: um --> [yplant;ymodel].
 
// full state gain is [K, L - K*T] * (xplant, xmodel) + M * umodel
 
BigA=[F+G*K,G*(L-K*T);
      0*ones(nw,nx),A];
 
BigC=[H+J*K,J*(L-K*T);
      0*ones(ny,nx),C];
 
BigB=[G*M;
       B];
 
BigD=[J*M;
       D];
 
 
x0=ones(nx,1);
 
BigX0=[x0;xx0];
 
Bigsyst=dscr(syslin('c',BigA,BigB,BigC,BigD,BigX0),dt);
 
 
 
z=flts(uu(instants),Bigsyst);
 
//plot2d(instants',z(1,:)',-1,'000');
 
xbasc(0);xset("window",0);
 
plot2d([instants',instants'],[totrack(1,:)',z(1,:)']);xtitle('tracking');
 
//xbasc(1);driver("Rec");xset("window",1);//xselect();
 
//plot2d(totrack(1,:)',z(1,:)');
 
clear uu z bigsyst bigx0  x0 gfrancis bigd bigb bigc biga k l
 
clear instants tmax dt  model plant a nuu nw f g h j
 
clear totrack m t d c b st nx nu ny xx0
 
 
 
s=poly(0,'s');
 
 
//MAC-FARLANE PROBLEM for G=1/s^3;
 
 
[P,r]=macglov(1/s^3);
 
clean(P)
 ans  =
 
!              2   3       !
!   1 + 2s + 2s + s     1  !
!   ---------------     -  !
!           3            3 !
!          s            s  !
!                          !
!   0                   1  !
!   -                   -  !
!   1                   1  !
!                          !
!              2   3       !
!   1 + 2s + 2s + s     1  !
!   ---------------     -  !
!           3            3 !
!          s            s  !
 
 
//Optimal controller K:
 
 
halt()
 
[K,ro]=h_inf(P,r,0,1,30);
P22 is stabilizable
P22 is detectable
           Try gama =       1.4142135624
          Too small (Hx) ,test =0.3000000000D+01
           Try gama =       2.0000000000
          Too small (Hx) ,test =0.1561317478D+01
           Try gama =       2.8284271247
          Too small (Hx) ,test =0.1358235746D+01
           Try gama =       4.0000000000
          Too small (Hx) ,test =0.2025811008D+01
           Try gama =       5.6568542495
          Too small (Hx) ,test =0.1652582559D+02
           Try gama =       8.0000000000
          OK , test =   -0.5000000000
           Try gama =       6.5319726474
          OK , test =   -0.5000000000
           Try gama =       6.0474315681
          OK , test =   -0.5000000000
           Try gama =       5.8423739467
          Too small (Hx) ,test =0.6024216750D+02
           Try gama =       5.9422508217
          OK , test =   -0.5000000000
           Try gama =       5.8916775545
          Too small (Hx) ,test =0.1963518206D+03
           Try gama =       5.9168020931
          OK , test =   -0.5000000000
           Try gama =       5.9041997314
          Too small (Hx) ,test =0.4584923361D+03
           Try gama =       5.9104908357
          Too small (Hx) ,test =0.1389308567D+04
           Try gama =       5.9136439385
          OK , test =   -0.5000000000
           Try gama =       5.9120667565
          Too small (Hx) ,test =0.2825644145D+04
           Try gama =       5.9128551898
          Too small (Hx) ,test =0.5852169247D+04
           Try gama =       5.9132495247
          Too small (Hx) ,test =0.1260345742D+05
           Try gama =       5.9134467218
          Too small (Hx) ,test =0.2978736536D+05
           Try gama =       5.9135453277
          Too small (Hx) ,test =0.9359836328D+05
           Try gama =       5.9135946325
          OK , test =   -0.5000000000
           Try gama =       5.9135699799
          Too small (Hx) ,test =0.2015325836D+06
           Try gama =       5.9135823062
          Too small (Hx) ,test =0.4759704424D+06
           Try gama =       5.9135884693
          Too small (Hx) ,test =0.1491507395D+07
           Try gama =       5.9135915509
          OK , test =   -0.5000000000
           Try gama =       5.9135900101
          Too small (Hx) ,test =0.3196572484D+07
           Try gama =       5.9135907805
          Too small (Hx) ,test =0.7461505790D+07
           Try gama =       5.9135911657
          Too small (Hx) ,test =0.2241435846D+08
           Try gama =       5.9135913583
          OK , test =   -0.5000000000
           Try gama =       5.9135912620
          Too small (Hx) ,test =0.4491855581D+08
 
 
K    //Optimal controller , ro = gamaopt^-2;
 K  =
 
                               2  
  - 1 - 3.4142136s - 5.8284271s   
    ---------------------------   
                              2   
    5.8284271 + 3.4142136s + s    
 
 
gamaopt=1/sqrt(ro)
 gamaopt  =
 
    5.9135914  
 
 
// Check internal stability:
 
 
halt()
 
 
Tzw=lft(tf2ss(P),tf2ss(K));
 
 
[Acl,Bcl,Ccl,Dcl]=abcd(Tzw); spec(Acl)
 ans  =
 
! - 1.                     !
! - 0.5 + 0.8660254i       !
! - 0.5 - 0.8660254i       !
! - 0.7071068 + 0.7071068i !
! - 0.7071068 - 0.7071068i !
 
 
//Optimal gain:
 
 
halt()
 
 
ga=h_norm(Tzw)
 ga  =
 
    5.9135914  
 
 
//Compare with gamaopt
 
 
ga-gamaopt
 ans  =
 
    5.914D-08  
 
 
//Compare with theory
 
 
halt()
 
 
[N,M]=lcf(tf2ss(1/s^3)); //Left coprime factorization of G.
 
 
nk=hankelsv([N,M]);
 
 
ro-( 1-nk(1) )
 ans  =
 
  - 3.717D-12  
 
 
 
getf(SCI+'/demos/lmitool/lmidem.sci','c');
 
mode(0);
 
x_message(['      ';
'LMITOOL is a Scilab package for LMI optimization';
      '           ';
'It can solve the following problem';
      '                 ';
      '   minimize  f(X1,...,XM)  ';
      'subject to the LME constraints: ';
      '   Gi(X1,...,XM)=0,  i=1,2,...,p,';
      'and the LMI constraints:  ';
      '   Hj(X1,...,XM)>=0,  j=1,2,...,q.';
      '              ';
      'where';
'X1,...,XM are unknown real matrices';
'f is the objective function, a linear scalar function of the entries of the X''s,';
'Gi''s are affine matrix functions of the entries of the X''s,';
'Hj''s are affine symmetric matrix functions of the entries of the X''s.';
      '            ';
'For a detailed description and examples consult: ';
      '          ''LMITOOL: a Package for LMI Optimization in Scilab, User''s Guide'' ';
      '          ';
      '          ';
'LMITOOL uses Semidefinite Programming package SP developed by L. Vandenberghe and S. Boyd.'])
 
 
 
%demo_=x_choose(['H-infinity gain';'Output Feedback';'Sylvester equation'],...
['This is a sample of LMI problems that LMITOOL can solve';
'Select a problem (other examples are given in demos/lmitool directory)']);
 
select %demo_
case 0
  error('LMI demo STOPS!');
case 1
   lmidem(SCI+'/demos/lmitool/normopt.sci');
   getf(SCI+'/demos/lmitool/normopt.sci','c');
   x_message(['Let''s try a simple example with 3 states';...
              'Edit below A,B,C,D matrices']);
   [ok,A,B,C,D]=getvalue('Enter A, B, C, D matrices',['A';'B';'C';'D'],...
   list('mat',[3,3],'mat',[3,2],'mat',[2,3],'mat',[2,2]),...
   ['[0,1,0;2,3,1;-1,-2,0]','[1,0;-2,1;0,1]','[1,2,0;0,1,-2]','[0,0;0,0]']);
   if ok then
   [X,gopt]=normopt(A,B,C,D);
 
 Construction of canonical representation   
 
 Basis Construction   
 
      FEASIBILITY PHASE.   
 
 Target value reached   
 
 feasible solution found   
 
       OPTIMIZATION PHASE.   
 
 optimal solution found   
   disp(gopt, 'optimal gama found is:')
 
 optimal gama found is:   
 
    6.7678289  
   disp(gopt-h_norm(syslin('c',A,B,C,D)),...
        'check: gopt-h_norm(syslin(''c'',A,B,C,D)=')
Warning : system is not stable ! 
 
 check: gopt-h_norm(syslin('c',A,B,C,D)=   
 
  - 6.768D-08  
      else
   error('LMI demo STOPS!');
end
case 2
   lmidem(SCI+'/demos/lmitool/of.sci');
   getf(SCI+'/demos/lmitool/of.sci','c');
   x_message(['Let''s try a simple example with 3 states';...
   'Enter A,B,C matrices']);
   [ok,A,B,C]=getvalue('Edit below A, B, C matrices',['A';'B';'C'],...
   list('mat',[3,3],'mat',[3,2],'mat',[2,3]),...
   ['[0,1,0;2,3,1;-1,-2,0]','[1,0;-2,1;0,1]','[1,2,0;0,1,-2]']);
   if ok then
   [P,Q]=of(A,B,C);
   disp(P,Q);
      else
   error('LMI demo STOPS!');
   end
case 3
   lmidem(SCI+'/demos/lmitool/sylvester.sci');
   getf(SCI+'/demos/lmitool/sylvester.sci','c');
   x_message(['Let''s try a simple example with 3 states';...
   'Enter A,B,C matrices']);
   [ok,A,B,C]=getvalue('Edit below A, B, C matrices',['A';'B';'C'],...
   list('mat',[3,3],'mat',[2,2],'mat',[3,2]),...
   ['[0,1,0;2,3,1;-1,-2,0]','[1,0;-2,1]','[1,2;0,1;1,-2]']);
   [X]=sylvester(A,B,C,'c');
   disp(X, 'X found is:')
   disp(A*X+X*B-C ,'Check: A*X+X*B-C =')
end
 
 
getf(SCI+'/demos/lmitool/lmidem.sci','c');
 
mode(0);
 
x_message(['      ';
'LMITOOL is a Scilab package for LMI optimization';
      '           ';
'It can solve the following problem';
      '                 ';
      '   minimize  f(X1,...,XM)  ';
      'subject to the LME constraints: ';
      '   Gi(X1,...,XM)=0,  i=1,2,...,p,';
      'and the LMI constraints:  ';
      '   Hj(X1,...,XM)>=0,  j=1,2,...,q.';
      '              ';
      'where';
'X1,...,XM are unknown real matrices';
'f is the objective function, a linear scalar function of the entries of the X''s,';
'Gi''s are affine matrix functions of the entries of the X''s,';
'Hj''s are affine symmetric matrix functions of the entries of the X''s.';
      '            ';
'For a detailed description and examples consult: ';
      '          ''LMITOOL: a Package for LMI Optimization in Scilab, User''s Guide'' ';
      '          ';
      '          ';
'LMITOOL uses Semidefinite Programming package SP developed by L. Vandenberghe and S. Boyd.'])
 
 
 
%demo_=x_choose(['H-infinity gain';'Output Feedback';'Sylvester equation'],...
['This is a sample of LMI problems that LMITOOL can solve';
'Select a problem (other examples are given in demos/lmitool directory)']);
 
select %demo_
case 0
  error('LMI demo STOPS!');
case 1
   lmidem(SCI+'/demos/lmitool/normopt.sci');
   getf(SCI+'/demos/lmitool/normopt.sci','c');
   x_message(['Let''s try a simple example with 3 states';...
              'Edit below A,B,C,D matrices']);
   [ok,A,B,C,D]=getvalue('Enter A, B, C, D matrices',['A';'B';'C';'D'],...
   list('mat',[3,3],'mat',[3,2],'mat',[2,3],'mat',[2,2]),...
   ['[0,1,0;2,3,1;-1,-2,0]','[1,0;-2,1;0,1]','[1,2,0;0,1,-2]','[0,0;0,0]']);
   if ok then
   [X,gopt]=normopt(A,B,C,D);
   disp(gopt, 'optimal gama found is:')
   disp(gopt-h_norm(syslin('c',A,B,C,D)),...
        'check: gopt-h_norm(syslin(''c'',A,B,C,D)=')
      else
   error('LMI demo STOPS!');
end
case 2
   lmidem(SCI+'/demos/lmitool/of.sci');
   getf(SCI+'/demos/lmitool/of.sci','c');
   x_message(['Let''s try a simple example with 3 states';...
   'Enter A,B,C matrices']);
   [ok,A,B,C]=getvalue('Edit below A, B, C matrices',['A';'B';'C'],...
   list('mat',[3,3],'mat',[3,2],'mat',[2,3]),...
   ['[0,1,0;2,3,1;-1,-2,0]','[1,0;-2,1;0,1]','[1,2,0;0,1,-2]']);
   if ok then
   [P,Q]=of(A,B,C);
 
 Construction of canonical representation   
 
 Basis Construction   
 
      FEASIBILITY PHASE.   
 
 Target value reached   
 
 feasible solution found   
 
       OPTIMIZATION PHASE.   
 
 optimal solution found   
   disp(P,Q);
 
!   1.0251242  - 0.7135499  - 0.3606374 !
! - 0.7135499    1.2950105    0.6655355 !
! - 0.3606374    0.6655355    1.5585759 !
 
!   1.5824578    0.8759924  - 0.0078987 !
!   0.8759924    1.4742173  - 0.4268180 !
! - 0.0078987  - 0.4268180    0.8220415 !
      else
   error('LMI demo STOPS!');
   end
case 3
   lmidem(SCI+'/demos/lmitool/sylvester.sci');
   getf(SCI+'/demos/lmitool/sylvester.sci','c');
   x_message(['Let''s try a simple example with 3 states';...
   'Enter A,B,C matrices']);
   [ok,A,B,C]=getvalue('Edit below A, B, C matrices',['A';'B';'C'],...
   list('mat',[3,3],'mat',[2,2],'mat',[3,2]),...
   ['[0,1,0;2,3,1;-1,-2,0]','[1,0;-2,1]','[1,2;0,1;1,-2]']);
   [X]=sylvester(A,B,C,'c');
   disp(X, 'X found is:')
   disp(A*X+X*B-C ,'Check: A*X+X*B-C =')
end
 
 
getf(SCI+'/demos/lmitool/lmidem.sci','c');
 
mode(0);
 
x_message(['      ';
'LMITOOL is a Scilab package for LMI optimization';
      '           ';
'It can solve the following problem';
      '                 ';
      '   minimize  f(X1,...,XM)  ';
      'subject to the LME constraints: ';
      '   Gi(X1,...,XM)=0,  i=1,2,...,p,';
      'and the LMI constraints:  ';
      '   Hj(X1,...,XM)>=0,  j=1,2,...,q.';
      '              ';
      'where';
'X1,...,XM are unknown real matrices';
'f is the objective function, a linear scalar function of the entries of the X''s,';
'Gi''s are affine matrix functions of the entries of the X''s,';
'Hj''s are affine symmetric matrix functions of the entries of the X''s.';
      '            ';
'For a detailed description and examples consult: ';
      '          ''LMITOOL: a Package for LMI Optimization in Scilab, User''s Guide'' ';
      '          ';
      '          ';
'LMITOOL uses Semidefinite Programming package SP developed by L. Vandenberghe and S. Boyd.'])
 
 
 
%demo_=x_choose(['H-infinity gain';'Output Feedback';'Sylvester equation'],...
['This is a sample of LMI problems that LMITOOL can solve';
'Select a problem (other examples are given in demos/lmitool directory)']);
 
select %demo_
case 0
  error('LMI demo STOPS!');
case 1
   lmidem(SCI+'/demos/lmitool/normopt.sci');
   getf(SCI+'/demos/lmitool/normopt.sci','c');
   x_message(['Let''s try a simple example with 3 states';...
              'Edit below A,B,C,D matrices']);
   [ok,A,B,C,D]=getvalue('Enter A, B, C, D matrices',['A';'B';'C';'D'],...
   list('mat',[3,3],'mat',[3,2],'mat',[2,3],'mat',[2,2]),...
   ['[0,1,0;2,3,1;-1,-2,0]','[1,0;-2,1;0,1]','[1,2,0;0,1,-2]','[0,0;0,0]']);
   if ok then
   [X,gopt]=normopt(A,B,C,D);
   disp(gopt, 'optimal gama found is:')
   disp(gopt-h_norm(syslin('c',A,B,C,D)),...
        'check: gopt-h_norm(syslin(''c'',A,B,C,D)=')
      else
   error('LMI demo STOPS!');
end
case 2
   lmidem(SCI+'/demos/lmitool/of.sci');
   getf(SCI+'/demos/lmitool/of.sci','c');
   x_message(['Let''s try a simple example with 3 states';...
   'Enter A,B,C matrices']);
   [ok,A,B,C]=getvalue('Edit below A, B, C matrices',['A';'B';'C'],...
   list('mat',[3,3],'mat',[3,2],'mat',[2,3]),...
   ['[0,1,0;2,3,1;-1,-2,0]','[1,0;-2,1;0,1]','[1,2,0;0,1,-2]']);
   if ok then
   [P,Q]=of(A,B,C);
   disp(P,Q);
      else
   error('LMI demo STOPS!');
   end
case 3
   lmidem(SCI+'/demos/lmitool/sylvester.sci');
   getf(SCI+'/demos/lmitool/sylvester.sci','c');
   x_message(['Let''s try a simple example with 3 states';...
   'Enter A,B,C matrices']);
   [ok,A,B,C]=getvalue('Edit below A, B, C matrices',['A';'B';'C'],...
   list('mat',[3,3],'mat',[2,2],'mat',[3,2]),...
   ['[0,1,0;2,3,1;-1,-2,0]','[1,0;-2,1]','[1,2;0,1;1,-2]']);
   [X]=sylvester(A,B,C,'c');
 
 Construction of canonical representation   
 
 Basis Construction   
 
 recomputing initial guess   
 
     
 
  Objective constant.   
   disp(X, 'X found is:')
 
 X found is:   
 
!   14.333333    3. !
! - 7.3333333  - 1. !
! - 1.3333333  - 1. !
   disp(A*X+X*B-C ,'Check: A*X+X*B-C =')
 
 Check: A*X+X*B-C =   
 
   1.0D-14 *
 
! - 0.0888178    0. !
! - 0.2664535    0. !
!   0.           0. !
end
 
 
 
tt=0:0.05:10;
 
//tt=0:0.1:1;
 
 
path="SCI/demos/npend";
 
mode(-1);
 
getf(path+'/macros.sci','c');
 
getf(path+'/dessin.sci','c');
 
xbasc();
 
flag1=x_choose(['Read a precomputed trajectory';
        'Simulation with ode (needs f77 and link. may fail. see help link)'],...
         'Simulation or Visualisation ? (click below)');
 
 
select flag1,
 case 2 then host("cd $"+path+"; make ");
	if ~c_link('npend') then link('/tmp/npend.o','npend');end
	if ~c_link('ener')  then link('/tmp/ener.o','ener');end
	if ~c_link('np')  then link('/tmp/np.o','np');end
	n=np();
	r=1*ones(1,n);m=1*ones(1,n);j=1*ones(1,n);g=9.81;
	y0=0*ones(2*n,1);
	yt=ode(y0,0,tt,'npend');
	xselect();
	xbasc();
	chaina(yt);
	flag=2 ;
	y=[]; for i=1:n;y=[y;'theta'+string(i)];end
	yd=[]; for i=1:n;yd=[yd;'thetad'+string(i)];end
	ystr=[y;yd];
	while flag=2, [n1,n2]=size(yt);
  		flag=x_choose(['Stop';'Go on'],'Choose');
                if flag=2,y0=evstr(x_mdialog(['Initial point '],ystr,...
    			string(yt(:,n2))));
  		yt=ode(y0,0,tt,'npend');
  		met=x_choose(['With last point trajectory';'Without'],...
			'Graphic Option');
		xbasc();
  		if met=1; chainb(yt);else;chaina(yt);end
		end
	end
 case 1 then // A precomputed value for
	     //x0=[0;%pi/2+0.1;0;5.0;0.0;4.0;0;0];
	n=10;
	r=1*ones(1,n);m=1*ones(1,n);j=1*ones(1,n);g=9.81;
	y0=0*ones(2*n,1);
	yt=read(path+'/yt.wrt',20,201);
	chaina(yt);
end
 
 
 
tt=0:0.05:10;
 
//tt=0:0.1:1;
 
 
path="SCI/demos/npend";
 
mode(-1);
 
getf(path+'/macros.sci','c');
 
getf(path+'/dessin.sci','c');
 
xbasc();
 
flag1=x_choose(['Read a precomputed trajectory';
        'Simulation with ode (needs f77 and link. may fail. see help link)'],...
         'Simulation or Visualisation ? (click below)');
 
 
select flag1,
 case 2 then host("cd $"+path+"; make ");
	if ~c_link('npend') then link('/tmp/npend.o','npend');end
	if ~c_link('ener')  then link('/tmp/ener.o','ener');end
	if ~c_link('np')  then link('/tmp/np.o','np');end
	n=np();
	r=1*ones(1,n);m=1*ones(1,n);j=1*ones(1,n);g=9.81;
	y0=0*ones(2*n,1);
	yt=ode(y0,0,tt,'npend');
	xselect();
	xbasc();
	chaina(yt);
	flag=2 ;
	y=[]; for i=1:n;y=[y;'theta'+string(i)];end
	yd=[]; for i=1:n;yd=[yd;'thetad'+string(i)];end
	ystr=[y;yd];
	while flag=2, [n1,n2]=size(yt);
  		flag=x_choose(['Stop';'Go on'],'Choose');
                if flag=2,y0=evstr(x_mdialog(['Initial point '],ystr,...
    			string(yt(:,n2))));
  		yt=ode(y0,0,tt,'npend');
  		met=x_choose(['With last point trajectory';'Without'],...
			'Graphic Option');
		xbasc();
  		if met=1; chainb(yt);else;chaina(yt);end
		end
	end
 case 1 then // A precomputed value for
	     //x0=[0;%pi/2+0.1;0;5.0;0.0;4.0;0;0];
	n=10;
	r=1*ones(1,n);m=1*ones(1,n);j=1*ones(1,n);g=9.81;
	y0=0*ones(2*n,1);
	yt=read(path+'/yt.wrt',20,201);
	chaina(yt);
end
 
 
mode(0);
 
xbasc();
 
 
xset("use color",0);
 
flag1=x_choose(['Yes';'No'],'Have you a color display');
 
if flag1=1;xset("use color",1);end
 
 
path='SCI/demos/anim/';
 
 
demolist=['Exemple 1';
	'Exemple 2';
	'Exemple 3';
	'Exemple 4';
	'Exemple 5'
	'Exemple 6'];
 
go_on=%t;
 
while go_on then
  num=x_choose(demolist(:,1),'Choose a demo');
  if num=0 then go_on=%f;
  else
  end,
end
 Demo of plot3d1
t=-%pi:0.3:%pi;plot3d1(t,t,sin(t)'*cos(t),35,45,'X@Y@Z',[2,2,4]);
 sp  =
 
    1.  
 sp  =
 
    1.  
 Demo of plot3d
t=-%pi:0.3:%pi;plot3d(t,t,sin(t)'*cos(t),35,45,'X@Y@Z',[2,2,4]);
 
 
 
 ans  =
 
    0.  
 
file('close',I)
 
file('close',O)
 
 
