<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?>
<!DOCTYPE MAN SYSTEM "../../manrev.dtd">
<MAN>
  <LANGUAGE>eng</LANGUAGE>
  <TITLE>link</TITLE>
  <TYPE>Scilab Function</TYPE>
  <DATE>April 1993</DATE>
  <SHORT_DESCRIPTION name="link"> dynamic link</SHORT_DESCRIPTION>
  <CALLING_SEQUENCE>
    <CALLING_SEQUENCE_ITEM>link(files, sub-name)  </CALLING_SEQUENCE_ITEM>
    <CALLING_SEQUENCE_ITEM>link(files, sub-name, flag)  </CALLING_SEQUENCE_ITEM>
    <CALLING_SEQUENCE_ITEM>lst=link('show')  </CALLING_SEQUENCE_ITEM>
    <CALLING_SEQUENCE_ITEM>// Link extensions for machines using ``dlopen''   </CALLING_SEQUENCE_ITEM>
    <CALLING_SEQUENCE_ITEM>// (sun-solaris/linux-elf/alpha/hppa)  </CALLING_SEQUENCE_ITEM>
    <CALLING_SEQUENCE_ITEM>x=link(files [, sub-names,flag]);  </CALLING_SEQUENCE_ITEM>
    <CALLING_SEQUENCE_ITEM>link(x , sub-names [, flag]);  </CALLING_SEQUENCE_ITEM>
    <CALLING_SEQUENCE_ITEM>ulink(x)  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>
  <PARAM>
    <PARAM_INDENT>
      <PARAM_ITEM>
        <PARAM_NAME>files</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: a character string or a vector of character strings. <VERB>ld</VERB> files used to define the new entry point (compiled routines, user libraries, system libraries,..)</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>sub-name</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: a character string. Name of the entry point in <VERB>files</VERB> to be linked.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>sub-names</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: a character string or a vector of character strings . Name of the entry points in <VERB>files</VERB> to be linked.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>x</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: an integer which gives the id of a shared library linked into Scilab with a previous call to <VERB>link</VERB>.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>flag</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: character string <VERB>'f'</VERB> or <VERB>'c'</VERB> for Fortran (default) or C code.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
      <PARAM_ITEM>
        <PARAM_NAME>names</PARAM_NAME>
        <PARAM_DESCRIPTION>
          <SP>: a vector of character string. Names of dynamically linked entry points.</SP>
        </PARAM_DESCRIPTION>
      </PARAM_ITEM>
    </PARAM_INDENT>
  </PARAM>
  <DESCRIPTION>
    <P><VERB>link</VERB> is a dynamic link facility: this command allows to add new compiled
    Fortran or C routines to Scilab executable code.
    Linked routines can be called interactively by the function <VERB>fort</VERB>.
    Linked routines can also be used as &quot;external&quot; for e.g. 
    non linear problem solvers (<VERB>ode</VERB>, <VERB>optim</VERB>, <VERB>intg</VERB>, 
    <VERB>dassl</VERB>...). Here are some examples:
  </P>
    <P>
    The command <VERB>link('foo.o','foo','f')</VERB> links the Fortran 
    object file <VERB>foo.o</VERB> with the entry point <VERB>foo</VERB>.
  </P>
    <P>
    The command <VERB>link('foo.o','foo','c')</VERB> links the C
    object file <VERB>foo.o</VERB> with the entry point <VERB>foo</VERB>.
  </P>
    <P>
    The command <VERB>link('SCIDIR/libs/calelm.a','dcopy')</VERB> links the 
    Fortran routine <VERB>dcopy</VERB> in the library <VERB>calelm.a</VERB>.
  </P>
    <P>
    A routine can be linked several times and can be unlinked with
    <VERB>ulink</VERB>. Note that, on some architectures (the ones on which
    <VERB>ulink</VERB> exists) when a routine is linked several times, all 
    the version are kept inside Scilab. 
  </P>
    <P>
    Used with no arguments, <VERB>link()</VERB> returns the current linked routines.
  </P>
    <P>
    If Scilab is compiled with static link (this is the default for
    SystemV machines) you may have to include the system libraries in the 
    &quot;link&quot; command.
  </P>
    <P>
    For example, if <VERB>foo.o</VERB> defines the object code of a routine named 
    <VERB>foo</VERB>, you will use <VERB>link</VERB> in one the following way: 
  </P>
    <VERBATIM>
<![CDATA[
link('foo.o','foo').
link('foo.o -lm -lc','foo','c').
link('foo.o -lfor -lm -lc','foo').
link('foo.o -lftn -lm -lc','foo').
link('foo.o -L/opt/SUNWspro/SC3.0/lib/lib77 -lm -lc','foo')
   ]]>
    </VERBATIM>
    <P>
    If Scilab compiled with the &quot;shared&quot; option, the first example can be used
    even if a warning for unresolved references is issued.
  </P>
    <P>
    (Experienced) users may also <VERB>link</VERB> a new Scilab interface routine 
    to add a set of new functions. 
    See <VERB>Intersci</VERB> documentation for interface generation and
    <VERB>addinter</VERB> function.
  </P>
  <P> To be able to link routines in a system independent way, it is convenient
      to use the ilib_for_link utility function.
  </P>
  </DESCRIPTION>
  <SECTION label="Remarks">
    <ITEMIZE>
      <ITEM label="IBM:">
        <SP>For IBM-RS6000 only one program can be dynamically linked.</SP>
      </ITEM>
      <ITEM label="dlopen:">
        <SP>For machines using dlopen functionality extended command can be
	  used. a call to <VERB>link</VERB> returns an integer which gives the
	  id of the shared  library which is loaded into Scilab. This number
	  can then be used as the first argument of the link function in order
	  to link additional  function from the linked shared library. The
	  shared library is  removed with the <VERB>ulink</VERB> command.  for
	  example to link functions <VERB>f</VERB> and <VERB>g</VERB> form
	  binary file  <VERB>test.o</VERB> the two following command can be
	  used :</SP>
        <VERBATIM>
<![CDATA[
link('test.o',['f','g'])
   ]]>
        </VERBATIM>
        <P>
    or
  </P>
        <VERBATIM>
<![CDATA[
x=link('test.o','f');
link(x,'g');
   ]]>
        </VERBATIM>
        <P>
    But 
  </P>
        <VERBATIM>
<![CDATA[
link('test.o','f');
link('test.o','g');
   ]]>
        </VERBATIM>
        <P>
    will also work but <VERB>f</VERB> and <VERB>g</VERB> will be loaded from two different shared libraries and won't be able to share data.  
  </P>
      </ITEM>
      <ITEM label="show:">
        <SP>The command <VERB>lst=link('show')</VERB> will report information about  linked shared libraries and linked functions. The return value of the function <VERB>lst</VERB> is <VERB>1</VERB> or <VERB>0</VERB>.  If the return value is <VERB>1</VERB> then the extended calling sequence  described as <VERB>Link extensions for machines using ``dlopen'' </VERB> are  accepted.</SP>
      </ITEM>
      <ITEM label="unlink :">
        <SP>(dlopen version) If the function <VERB>f</VERB> is changed and one wants to link  the new version, it is necessary to use unlink to get rid of  previous loaded versions of the function <VERB>f</VERB></SP>
        <VERBATIM>
<![CDATA[
x=link('test.o','f');
// if I need to reload a new definition of f a call to unlink
// is necessary.
ulink(x);
link('test.o','f');
   ]]>
        </VERBATIM>
      </ITEM>
      <ITEM label="scilab symbols:">
        <SP>In order to load a symbol from the Scilab code on can use</SP>
        <VERBATIM>
<![CDATA[
link("Scilab",['Scilab-entry-point'])
   ]]>
        </VERBATIM>
        <P>
    This does not work on all architectures. On some machines, on can  link a Scilab internal function after a first call to link ( with  a default binary file )</P>
        <VERBATIM>
<![CDATA[
link("test.o",['Scilab-entry-point'])
   ]]>
        </VERBATIM>
        <P>
    Note that with <VERB>dld</VERB> (Linux machine aout) you can use an empty string</P>
        <VERBATIM>
<![CDATA[
link(" ",['Scilab-entry-point'])
   ]]>
        </VERBATIM>
      </ITEM>
    </ITEMIZE>
  </SECTION>
  <EXAMPLE>
<![CDATA[
    //Example of the use of ilib_for_link with  a simple C code
    f1=['#include <math.h>'
        'void fooc(c,a,b,m,n)'
         'double a[],*b,c[];'
         'int *m,*n;'
         '{'
         '   int i;'
         '   for ( i =0 ; i < (*m)*(*n) ; i++) '
         '     c[i] = sin(a[i]) + *b; '
         '}'];

    mputl(f1,'fooc.c')

    //creating the shared library (a gateway, a Makefile and a loader are 
    //generated the code is compileda nd a shared library built.
    ilib_for_link('fooc','fooc.o',[],"c") 
    
    // display the loader.sce file which calls <VERB>link</VERB>
    mprintf('%s\n',mgetl('loader.sce')) 
    // load the shared library 
    exec loader.sce
    ]]>
  </EXAMPLE>

  <SEE_ALSO>
    <SEE_ALSO_ITEM>
      <LINK>call</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>c_link</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>addinter</LINK>
    </SEE_ALSO_ITEM>
    <SEE_ALSO_ITEM>
      <LINK>ilib_for_link</LINK>
    </SEE_ALSO_ITEM>

  </SEE_ALSO>
</MAN>
