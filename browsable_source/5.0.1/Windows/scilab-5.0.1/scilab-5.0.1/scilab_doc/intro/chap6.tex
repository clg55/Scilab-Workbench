\chapter{Interfacing C or Fortran programs}

Scilab can be easily interfaced with Fortran or C programs. 
This is useful to have faster code or to use specific numerical
code for, e.g., the simulation or optimization of
user defined systems, or specific Lapack or {\tt netlib} modules. 
In fact, interfacing numerical code appears necessary in most
nontrivial applications. For
interfacing C or Fortran programs, it is of course necessary to link
these programs with Scilab. This can be done by a dynamic
(incremental) link or by creating a new executable code for Scilab.
For executing a C or Fortran program linked with Scilab, its
input parameters must be given specific values transferred from Scilab
and its output
parameters must be transformed into Scilab variables.
It is also possible that a linked program is automatically executed
by a high-level primitive: for instance the {\tt ode} function
can integrate the differential equation $\dot{x} = f(t,x)$ with a
rhs function $f$ defined as a C or Fortran program which is
dynamically linked to Scilab (see \ref{refexternals}).


The simplest way to call external programs is to use the  
{\tt link}\index{link@{\tt link}} primitive
(which dynamically links the user's program with Scilab)
and then to interactively call
the linked routine by {\tt call}\index{call@{\tt call}} primitive
which transmits Scilab variables (matrices or strings) to the linked program
and transforms back the output parameters into Scilab variables. 
Note that all the parameters of the routine called by the {\tt call} 
primitive must be pointers. In particular Fortran routines can be called
using the {\tt call} primitive.

Note that ode/dae solvers and non linear optimization primitives
can be directly used with C or Fortran user-defined programs
dynamically linked (see \ref{dynamiclink}). . 

An other way to add C or Fortran code to Scilab is by 
building an interface program. The interface program can be written by
the user following the examples given in the directories
{\tt routines/examples/interface-*}. The simplest way to build an
interface program is to copy/paste one of the examples given there and to
adapt the code to your problem.

Examples of Matlab-like mexfunction interfaces are given in the 
directory {\tt routines/examples/mexfiles}.

The interface program can also be generated by the tool {\tt
intersci}. {\tt Intersci} builds the interface
program from a {\tt .desc} file which describes both the C or 
Fortran program(s) to be used and the name and parameters of
the corresponding Scilab function(s). 

\section{Using dynamic link}
Several simple examples of dynamic link are  given in the directory
{\tt examples/link-examples}. In this section, we briefly describe 
how to call a dynamically linked program. 
\subsection{Dynamic link}
\label{dynamiclink}
The command {\tt link('path/pgm.o','pgm',flag)}
links the compiled program {\tt pgm} to Scilab.
Here {\tt pgm.o} is an object file located in the {\tt path}
directory and {\tt pgm} is an entry point (program name) in the 
file {\tt pgm.o} (An object file can have several entry points: to link 
them, use a vector of character strings such as \verb!['pgm1','pgm2']!).

{\tt flag} should be set to {\tt 'C'} for a C-coded program
and to {\tt 'F'} for a Fortran subroutine. ({\tt 'F'} is
the default flag and can be omitted).

If the link operation is OK, scilab returns an integer {\tt n} associated
with this linked program. To undo the link enter {\tt ulink(n)}.

The command \verb!c_link('pgm')! returns true if {\tt pgm} is
currently linked to Scilab and false if not.

\noindent
Here is a example, with the Fortran BLAS {\tt daxpy} subroutine 
used in Scilab:
\begin{verbatim}

-->n=link(SCI+'/routines/blas/daxpy.o','daxpy')
linking files /usr/local/lib/scilab-2.4/routines/calelm/daxpy.o
to create a shared executable.
Linking daxpy (in fact daxpy_)
Link done
 n  =
 
    0.  
 -->c_link('daxpy')
 ans  =
 
  T  
-->ulink(n)
 
-->c_link('daxpy')
 ans  =
 
  F  
\end{verbatim}

For more details, enter {\tt help link}. The {\tt link} primitive can load
a set of object files and/or a static library and/or a dynamic library.

\subsection{Calling a dynamically linked program}

The {\tt call} function can be used to call a dynamically linked
program. Consider for example the {\tt daxpy} Fortran routine. It performs 
the simple vector operation {\tt y=y+a*x} or, to be more specific, 
\begin{verbatim}
y(1)=y(1)+a*x(1), y(1+incy)=y(1+incy)+a*x(1+incx),...
y(1+n*incy)=y(1+n*incy)+a*x(1+n*incx)
\end{verbatim} 
where {\tt y} and {\tt x} are two real vectors.
The calling sequence for {\tt daxpy} is as follows:
\begin{verbatim}
      subroutine daxpy(n,a,x,incx,y,incy)
\end{verbatim}
The parameters of a Fortran program are pointers. The C code for the 
same function would be :
\begin{verbatim}
void daxpy(int *n,double *a,double *x,int *incx,double *y,int *incy)
\end{verbatim}
To call {\tt daxpy} from Scilab we must use a syntax as follows: 
\begin{verbatim}
[y1,y2,y3,...]=call('daxpy', inputs description, ...
                    'out', outputs description)
\end{verbatim}
\noindent
Here {\tt inputs description} is a set of parameters
 
{\tt x1,p1,t1}, {\tt x2,p2,t2}, {\tt x3,p3,t3} ... 

\noindent
where {\tt xi} is the Scilab variable (real vector or matrix) sent to 
{\tt daxpy},
{\tt pi} is the position number of this variable in the calling
sequence of {\tt daxpy} and {\tt ti} is the type of {\tt xi} in {\tt daxpy}
({\tt t='i'  t='r'  t='d' t='c'} stands for integer, real,  double, char
 respectively).

\noindent
{\tt outputs description} is a set of parameters
 
{\tt [r1,c1],p1,t1}, {\tt [r2,c2],p2,t2}, {\tt [r3,c3],p3,t3},..

\noindent
which describes each output variable. {\tt [ri,ci]} is the
1 x 2 integer vector giving the number of rows and columns of the
ith output variable {\tt yi}. The position, {\tt pi}, and the type, {\tt ti},
are as for input variables (they can be omitted if a variable is both input and
output). 

We see that the arguments of {\tt call}  divided into four groups.
The first argument {\tt 'daxpy'} is the name of the called subroutine.
The argument {\tt 'out'} divides the remaining arguments into two 
groups.  The group of arguments between {\tt 'daxpy'} and {\tt 'out'}
is the list of input arguments, their positions in the call to {\tt daxpy},
and their data type.  The group of arguments at the right of {\tt 'out'}
are the dimensions of the output variables, their positions in the calling
sequence of {\tt daxpy}, and their data type.
The possible data types are real, integer, double and character which
are indicated, respectively, by the strings {\tt 'r'}, {\tt 'i'}, {\tt 'd'}
and {\tt 'c'}.  
Here we calculate {\tt y=y+a*x} by a call to {\tt daxpy} (assuming
that the {\tt link} command has been done).
We have six input variables 
{\tt x1=n, x2=a, x3=x, x4=incx, x5=y, x6=incy}.
Variables {\tt x1, x4} and {\tt x6} are integers and variables
{\tt x2, x3, x5} are double. There is one output variable {\tt y1=y}
at position {\tt p1=5}. To simplify, we assume here that {\tt x} and
{\tt y} have the same length and we take {\tt incx=incy=1}.
\begin{verbatim}
-->a=3;
 
-->x=[1,2,3,4];y=[1,1,1,1];
 
-->incx=1;incy=1;

-->n=length(x);  //n=4

-->y=call('daxpy',...
        n,1,'i',...
        a,2,'d',...
        x,3,'d',...
        incx,4,'i',...
        y,5,'d',...
        incy,6,'i',...
'out',...
        [1,n],5,'d');

 y  =
 
!   4.    7.    10.    13. !
\end{verbatim}
(Since {\tt y} is both input and output parameter, we could also use
the simplified syntax 
{\tt call(...,'out',5)} instead of {\tt call(...,'out'[1,n],5,'d')}). 

The same example with the C function {\tt daxpy} (from CBLAS):
\begin{verbatim}
int daxpy(int *n, double *da, double *dx, int *incx, double *dy, int *incy)
...
\end{verbatim}

\begin{verbatim}
-->link('daxpy.o','daxpy','C')
linking files daxpy.o  to create a shared executable
Linking daxpy (in fact daxpy)
Link done
 ans  =
 
    1.  

-->y=call('daxpy',...
        n,1,'i',...
        a,2,'d',...
        x,3,'d',...
        incx,4,'i',...
        y,5,'d',...
        incy,6,'i',...
'out',...
        [1,n],5,'d');
 
-->y
 y  =
 
!   4.    7.    10.    13. !
\end{verbatim}

The routines which are linked to Scilab can also access internal 
Scilab variables: see the examples in given in the {\tt examples/links}
directory. 

\subsection{Building a dynamic library}
The simple link of an object file as illustrated above may not work on some
platforms. In this case, it is neccesary to build a (possibly dynamic) library 
containing a set of programs and to link the library with Scilab.
Examples are given the directory {\tt SCIDIR/example/link-examples-so}
which are built to run in both a Linux/Unix (.so or .sl library) or 
Windows environment (.dll library). The library is constructed by a specific
Scilab function {\verb!ilib_for_link!} (which make use of libtool for Unix/
Linux libraries). 
Enter \verb!-->exec ext1c.sce! at the Scilab prompt, in this directory to
see the simplest C example. The script file {\tt ext1c.sce} contains a call
to  {\verb!ilib_for_link!} with appropriate parameters (files to be compiled,
others libraries required, etc). The library is built using the environment
parameters known by Scilab (compiler, linker etc). In addition a Scilab script 
with generic name {\tt loader.sce} is created in the current directory.
This script contains contains the code necessary to link the library with
Scilab. Typically, it is a call to the {\tt link} primitive, with an 
appropriate entry point (usually the name of the linked function).
Note that the script file performs two tasks: building of the library
and link of the library with the running Scilab. The first task is 
generally performed once while the second should be made in every Scilab 
session which needs linking the library.

\section{Interface programs}

\subsection{Building an interface program}
Many examples of interface programs are given in the 
directories/subdirectories {\tt SCIDIR/examples/interface-*}. 

The interface programs use a set of C or Fortran routines which
are given in {\tt SCIDIR/routines/stack-c.h} and known by Scilab
when this file is included in the interface program.

The simplest way to learn how to build an interface program is to 
look at the examples provided in the directory {\tt interface-tutorial}.

Note that a unique interface program can be used to interface an 
arbitrary (but less that $99$) number of functions.

\subsection{Example}
\label{interface}
Let us consider an example given in {\tt examples/interface-tutorial}.

We have the following C function \verb!matmul! which performs 
a matrix multiplication. Only the calling sequence is important.
\scriptsize
\begin{verbatim}
/*Matrix multiplication C=A*B, (A,B,C stored columnwise) */

#define A(i,k) a[i + k*n]
#define B(k,j) b[k + j*m]
#define C(i,j) c[i + j*n]

void matmul(a,n,m,b,l,c)
double a[],b[],c[];
int n,m,l;
{
int i,j,k; double s;
for( i=0 ; i < n; i++)
   {
     for( j=0; j < l; j++)
        {
        s = 0.;
        for( k=0; k< m; k++)
           {
	    s += A(i,k)*B(k,j);
           }
         C(i,j) = s;
         }
   }
}
\end{verbatim}
\normalsize

We want to have a new Scilab function (also called \verb!matmul!)
which is such that the Scilab command 
\begin{verbatim}
-->C=matmul(A,B)
\end{verbatim}
returns in \verb!C! the matrix product \verb!A*B! computed
by the above C function. Here \verb!A, B! and \verb!C! are standard
numeric Scilab matrices. Thus, the Scilab matrices \verb!A! and \verb!B! 
should be sent to the C function \verb!matmul! and the matrix 
\verb!C! should be created, filled, and sent back to Scilab.

To create the Scilab function \verb!matmul!, we have to write 
a gateway function (an interface function).
A gateway function is a C function which must include the header file
{\tt stack-c.h}. Fortran gatways include the file {\tt stack.h}.
These files are located in the SCIDIR/routines directory.

The following C gateway function called
\verb!intmatmul! is an example of interface for the matrix multiplication
program {\tt matmul}. See the file \newline
\verb!SCIDIR/examples/interface-tutorial/intmatmul.c!.

\scriptsize
\begin{verbatim}
#include "stack-c.h"

int intmatmul(fname) 
     char *fname;
{
  int l1, m1, n1, l2, m2, n2, l3;
  int minlhs=1, maxlhs=1, minrhs=2, maxrhs=2;

  /* Check number of inputs (Rhs=2) and outputs (Lhs=1) */
  CheckRhs(minrhs,maxrhs) ; CheckLhs(minlhs,maxlhs) ;

  /* Get A (#1) and B (#2) as double ("d") */
  GetRhsVar(1, "d", &m1, &n1, &l1); 
  GetRhsVar(2, "d", &m2, &n2, &l2); 

  /* Check dimensions    */
if (!(n1==m2)) {Scierror(999,"%s: Uncompatible dimensions\r\n",fname);
                 return 0;}

  /* Create C (#3) as double ("d") with m1 rows and n1 columns */
  CreateVar(3, "d", &m1, &n2, &l3);   

  /* Call the multiplication function matmul
     inputs:stk(l1)->A, stk(l2)->B  output:stk(l3)->C    */
  matmul(stk(l1), m1, n1, stk(l2), n2, stk(l3));

  /*  Return C (3)  */
  LhsVar(1) = 3;
  return 0;
}
\end{verbatim}
\normalsize

Let us now explain each step of the gateway function \verb!intmatmul!.
The gateway function must include the file \verb!SCIDIR/routines/stack-c.h!.
This is the first line of the file. 
The name of the routine is \verb!intmatmul!
and it admits one input parameter which is \verb!fname!. 
\verb!fname! must be declared as \verb!char *!. The name of the gateway
routine (here \verb!intmatmul!) is arbitrary but the parameter 
\verb!fname! is compulsory.
The gateway routine then includes the declarations of the C variables used.
In the gateway function \verb!intmatmul! the Scilab matrices 
\verb!A!, \verb!B! and \verb!C! are referred to as numbers,
respectively \verb!1!, \verb!2! and \verb!3!. 

The line 
\begin{verbatim}
CheckRhs(minrhs,maxrhs); CheckLhs(minlhs,maxlhs);
\end{verbatim}
is to check that the Scilab function \verb!matmul! is called with
a correct number of RHS and LHS parameters. For instance, typing 
\verb!-->matmul(A)! will give an error message made by \verb!CheckRhs!.
The function \verb!CheckRhs! just compares the C variable \verb!Rhs!
(transmitted in the include file \verb!stack-c.h!) with the bounds
\verb!minrhs! and \verb!maxrhs!.

\noindent
The next step is to deal with the Scilab variables \verb!A!, \verb!B! 
and \verb!C!. In a gateway function, all the Scilab variables
are referred to as integer numbers. Here, the Scilab matrices 
\verb!A!, \verb!B! and \verb!C! are 
respectively numbered \verb!1!, \verb!2! and \verb!3!. 
Each input variable of the newly created Scilab function
\verb!matmul! (i.e. \verb!A! and \verb!B!)
should be processed by a call to \verb!GetRhsVar!.
The first two parameters of  \verb!GetRhsVar! are inputs and the last
three parameters are outputs.
The line 
\begin{verbatim}
GetRhsVar(1, "d", &m1, &n1, &l1); 
\end{verbatim}
means that we process the RHS variable numbered \verb!1! (i.e. \verb!A!).
The first parameter of \verb!GetRhsVar! (here \verb!1!) refers to the
first parameter (here \verb!A!) of the Scilab function \verb!matmul!.
This variable is a Scilab numeric matrix which should be seen ("d") as a 
\verb!double! C array, since the C routine \verb!matmul! is
expecting a \verb!double! array. The second parameter of \verb!GetRhsVar!
(here \verb!"d"!) refers to the type (double, int, char etc) of the variable.
From the call to \verb!GetRhsVar! we know that \verb!A! has
\verb!m1! rows and \verb!n1! columns. 


\noindent
The line
\begin{verbatim}
if (n1 !=m2 ) 
     {Scierror(999,"%s: Uncompatible dimensions\r\n",fname);
                 return 0;}
\end{verbatim}
\normalsize
is to make a return to Scilab if the matrices \verb!A! and \verb!B! 
passed to \verb!matmul! have uncompatible dimensions. The number
of columns of \verb!A! should be equal to the number of rows of \verb!B!.

\noindent
The next step is to create the output variable \verb!C!. This is done by
\begin{verbatim}
CreateVar(3, "d", &m1, &n2, &l3);
\end{verbatim}
Here we create a variable numbered \verb!3! (\verb!1! was for \verb!A!
and \verb!2! was for \verb!B!). It is an array of double (\verb!"d"!).
It has \verb!m1! rows and \verb!n2! columns. 
The calling sequence of \verb!CreateVar! is the same as the calling sequence
of \verb!GetRhsVar!, but the four first parameters of \verb!CreateVar! 
are inputs. 

The next step is the call to \verb!matmul!. Remember the calling sequence~:
\begin{verbatim}
void matmul(a,n,m,b,l,c)
double a[],b[],c[]; int n,m,l;
\end{verbatim}
\noindent
We must send to this function (double) pointers to the numeric
data in \verb!A!, \verb!B! and \verb!C!.
This is done by~:
\begin{verbatim}
  matmul(stk(l1), m1, n1, stk(l2), n2, stk(l3));
\end{verbatim}
Here \verb!stk(l1)! is a double pointer to the content of the \verb!A!
matrix. The entries of the \verb!A! matrix are stored columnwise
in \verb!stk(l1)[0]!, \verb!stk(l1)[1]! etc.
Similarly, after the call to the C function \verb!matmul! the (double) numbers
\verb!stk(l3)[0]!, \verb!stk(l3)[1]! are the values of the 
matrix product \verb!A*B! stored columnwise as computed by
\verb!matmul!.
The last parameter of the functions \verb!GetRhsVar! and \verb!CreateVar!
is an output parameter which allow to access the data through a 
pointer (here the double pointers \verb!stk(l1)!, \verb!stk(l2)! and
\verb!stk(l3)!.

The final step is to return the result, i.e. the \verb!C! matrix to Scilab.
This is done by
\begin{verbatim}
  LhsVar(1) = 3;
\end{verbatim}
\noindent This statement means that the first LHS variable of 
the Scilab function \verb!matmul! is the variable numbered \verb!3!.

Once the gateway routine is written, it should be compiled, linked
with Scilab and a script file should be executed in Scilab
for loading the new function.

It is possible to build a static or a dynamic library.  The static library
corresponding the the example just described here is built in the directory
\verb!SCIDIR/examples/interface-tutorial! and the dynamic library is built 
into the directory \verb!SCIDIR/examples/interface-tutorial-so!.
\subsubsection{Static library}
In the directory \verb!SCIDIR/examples/interface-tutorial! just 
enter the \verb!make! command in an Unix platform or in the Windows
environment with the Visual C++ environment enter \verb!nmake /f Makefile.mak!.
This command produces the following file \verb!tutorial_gateway.c! which is
a C function produced by the Makefile~:

\scriptsize
\begin{verbatim}
#include "mex.h" 
extern Gatefunc intview;
extern Gatefunc intmatmul;
 
static GenericTable Tab[]={
{(Myinterfun)sci_gateway, intview,"error msg"},
{(Myinterfun)sci_gateway, intmatmul,"error msg"},
         };

int C2F(tutorial_gateway)()
{  Rhs = Max(0, Rhs);
(*(Tab[Fin-1].f))(Tab[Fin-1].name,Tab[Fin-1].F);
  return 0;
}
\end{verbatim}
\normalsize
\noindent
This function is essentially the table of C functions which 
are dynamically linked wih Scilab.

The following file \verb!tutorial.sce! is also produced by the Makefile~:
\scriptsize
\begin{verbatim}
scilab_functions =[...
"view";
"matmul";
           ];
auxiliary="";
files=G_make(["tutorial_gateway.o","tutorial.a", auxiliary],"void(Win)");
addinter(files,"tutorial_gateway",scilab_functions);
\end{verbatim}
\normalsize

The Scilab function \verb!addinter! makes the correspondance between the
C gateway functions (such as \verb!intmatmul!) and their names as Scilab
functions.

To load the newly created function \verb!matmul!, one has to execute this
script and then the function \verb!matmul! can be called into Scilab 
\begin{verbatim}
-->exec tutorial.sce

-->A=rand(2,3);B=rand(3,3);C=matmul(A,B);   //C=A*B
\end{verbatim}

Summing up, to build an static interface, the user has to write 
a gateway function such as \verb!intmatmul!. Then he has to edit 
the Makefile in
\verb!SCIDIR/examples/interface-tutorial! (or a copy of it) and to put there
the name of his gateway function(s) (e.g. \verb!intmatmul.o!) in the 
target \verb!CINTERFACE! and the name of the corresponding Scilab
function (e.g. \verb!matmul!) in the target \verb!CFUNCTIONS!
with the same ordering. Typing \verb!make! produces the static library
and a script file (here \verb!tutorial.sce!) which should be 
executed each time the newly created function(s) are needed. Of course,
it is possible to perform this operation automatically 
when Scilab is launched by creating a startup file \verb!.scilab! identical
to \verb!tutorial.sce!.

\subsubsection{Dynamic library}
The directory \verb!SCIDIR/examples/interface-tutorial-so! contains the 
material necessary to create a dynamic library (or a dll in the Windows environment) that can be dynamically linked with Scilab. 
This directory contains the following file called \verb!builder.sce!~:
\scriptsize
\begin{verbatim}
// This is the builder.sce 
// must be run from this directory 

ilib_name  = "libtutorial"           // interface library name 
files = ["intview.o","intmatmul.o"]  // objects files 
                                     // 
libs  = []                           // other libs needed for linking
table = [ "view", "intview";         // table of (scilab_name,interface-name)
          "matmul","intmatmul"];     //

// do not modify below 
// ----------------------------------------------
ilib_build(ilib_name,table,files,libs)
\end{verbatim}
\normalsize
The user should edit this file, which is a Scilab script, and 
in particular the variables \verb!files! (a row vector of strings)
anf \verb!table! a two column matrix of strings. 
\verb!files! should contain the names of all the object files 
(gateway functions and C functions called). 
Each row of \verb!table! is a pair of two strings: the first is the
name of the Scilab function, and the second the name of the 
gateway function. Here we have two functions \verb!view! which has
\verb!intview! as gateway and \verb!matmul! which has \verb!intmatmul!
as gateway. This is the example given above.
After the file \verb!builder.sce! has been edited, it should be 
executed in Scilab by the command
\begin{verbatim}
-->exec builder.sce
\end{verbatim}
Scilab then generates the file \verb!loader.sce!~:
\begin{verbatim}
// generated by builder.sce
libtutorial_path=get_file_path('loader.sce');
functions=[ 'view';
            'matmul';
];
addinter(libtutorial_path+'/libtutorial.so','libtutorial',functions);
\end{verbatim}
This file should be executed in Scilab to load the newly created function 
\verb!matmul!
\begin{verbatim}
-->exec loader.sce

-->A=rand(2,3);B=rand(3,3);C=matmul(A,B);   //C=A*B
\end{verbatim}
Summing up, to build a dynamic interface the user has to write a
gateway function (such as \verb!intmatmul!), then he has to edit
the file \verb!builder.sce! (or a copy of it) to enter
the name of the Scilab function and the necessary C functions, 
then he has to execute the script \verb!builder.sce!. This
produce the dynamic library and the script \verb!loader.sce!.
Then each time he needs the newly created function(s), he has to 
execute the script \verb!loader.sce!. 

\subsection{Functions used for building an interface}
The functions used to build an interface are Fortran subroutines when 
the interface is written in Fortran and are coded as C macros 
when the interface is coded in C. 
An interface (gateway) routine is a standard C function or Fortran 
program which include the file {\tt SCIDIR/routines/stack-c.h} 
(C coded gateway)  or  {\tt SCIDIR/routines/stack.h} (Fortran coded gateway).

The C functions which can be used in an interface program are available
as soon as {\tt SCIDIR/routines/stack-c.h} is included in the source code.

The main functions are the following:

\begin{itemize}
\item{
\begin{verbatim}
CheckRhs(minrhs, maxrhs)
CheckLhs(minlhs, maxlhs)
\end{verbatim}
Function \verb!CheckRhs! is used to check that the Scilab function is called
with \\
{\verb! minrhs <= Rhs <= maxrhs!}. 
Function \verb!CheckLhs! is used to check that the expected return
values are in the range 
{\verb! minlhs <= Lhs <= maxlhs!}. (Usually one has {\tt minlhs=1}
since a Scilab function can be always be called with less lhs
arguments than expected).
}
\item{
\begin{verbatim}
GetRhsVar(k,ct,&mk,&nk,&lk)
\end{verbatim}
Note that \verb!k! (integer) and \verb!ct! (string) are inputs and 
\verb!mk,nk! and \verb!lk! (integers) are outputs of \verb!GetRhsVar!.
This function defines the type (\verb!ct!) of input variable numbered
\verb!k!, i.e. the \verb!k!th input variable in the calling sequence of the 
Scilab function. The pair \verb!mk,nk! gives the dimensions (number of rows
and columns)  of variable numbered \verb!k! if it is a matrix. 
If it is a chain \verb!mk*nk! is its length. \verb!lk! is the adress
of variable numbered \verb!k! in Scilab internal stack.
The type of variable number \verb!k!, \verb!ct!, should be set 
to {\tt "d", "r", "i" ,"z"} or {\tt "c"} which stands for double, float
(real), integer, double complex 
or character respectively. The interface should call function
\verb!GetRhsVar! for each of the rhs variables of the Scilab function
with {\tt k=1, k=2,..., k=Rhs}.
Note that if the Scilab argument doesn't match the requested type then 
Scilab enters an error function and returns from the interface function.
}
\item{
\begin{verbatim}
CreateVar(k,ct,&mk,&nk,&lk)
\end{verbatim}
Here \verb!k,ct,&mk,&nk! are inputs of \verb!CreateVar! and \verb!lk! is an
output of \verb!CreateVar!. The parameters are as above. Variable numbered
\verb!k! is created in Scilab internal stack at adress {\tt lk}. When
calling {\tt CreateVar}, {\tt k} must be greater than {\tt Rhs} i.e.
{\tt k=Rhs+1, k=Rhs+2, ...}.
If due to memory lack, the argument can't be created, then a Scilab error 
function is called and the interface function returns.
}
\item{
\begin{verbatim}
CreateVarFromPtr(k,ct,&mk,&nk,&lk)
\end{verbatim}
Here \verb!k,ct,&mk,&nk,&lk! are all inputs of \verb!CreateVarFromPtr! and
\verb!lk! is pointer created by a call to a C function. This function is used 
when a C object was created inside the interfaced function and a Scilab 
object is to be created using a pointer to this C object. }
\end{itemize}


Once the  variables have been processed by {\tt GetRhsVar} or created
by {\tt CreateVar}, they are given values by calling one or several 
numerical routine. The call to the numerical routine is done
in such a way that each argument of the routine points to the
corresponding Scilab variable. 
Character, integer, real, double and double complex type variables are 
respectively in the {\tt cstk}, {\tt istk}, {\tt sstk}, 
{\tt stk}, {\tt zstk} Scilab internal stack
at the adresses {\tt lk}'s returned by {\tt GetRhsVar} or {\tt CreateVar}. 

Then they are returned to Scilab as lhs variables.
The interface should define how the lhs (output) variables are
numbered. This is done by the global variable {\tt LhsVar}.
For instance
\begin{verbatim}
  LhsVar(1) = 5;
  LhsVar(2) = 3;
  LhsVar(3) = 1;
  LhsVar(4) = 2;
\end{verbatim}
means that the Scilab function has at most 4 output parameters
which are variables numbered \verb!k= 5, k=3, k=1, k=2! respectively.

The functions \verb!sciprint(amessage)! and \verb!Error(k)! are used
for managing messages and errors.

Other useful functions which can be used are the following.
\begin{itemize}
\item{
\begin{verbatim}
GetMatrixptr("Aname", &m, &n, &lp);
\end{verbatim}
This function reads a matrix in Scilab internal stack. \verb!Aname! is
a character string, name of a Scilab matrix. Outputs are integers
\verb!m,n! and \verb!lp!, the entries of the matrix are 
ordered {\em columnwise}.}
\item{
\begin{verbatim}
ReadString("Aname",&n,str)
\end{verbatim}
This function reads a string in Scilab internal stack. \verb!n! is the
length of the string.
}
\end{itemize}


The Fortran functions have the same syntax and return logical values.
\subsection{Examples}
There are many examples of external functions interfaced with Scilab in
the directories \verb!SCIDIR/examples/interface-tour! and \newline
\verb!SCIDIR/examples/interface-tour-so!. 
Examples are given in C and Fortran. 
The best way to build an interface is to copy one of the examples
given there and to adapt the code to particular needs.


\section{Argument functions}
Some built-in nonlinear solvers, such as {\tt ode} or {\tt optim}, require a 
specific function as argument. For instance in the Scilab command
{\tt ode(x0,t0,t,fydot)}, {\tt fydot} is the specific argument function
for the {\tt ode} primitive.
This function can be a either Scilab function or an external
function written in C or Fortran.
In both cases, the argument function must obey a specific
syntax. In the following we will consider, as running example, using 
the {\tt ode} primitive with a rhs function written in Fortran. The
same steps should be followed for all primitives which require
a function as argument.

If the argument function is written in C or Fortran, there
are two ways to call it:
\begin{itemize}
\item -Use dynamic link
\begin{verbatim}
-->link('myfydot.o','myfydot')  
//or -->link('myfydot.o','myfydot','C')
-->ode(x0,t0,t,'myfydot')
\end{verbatim}
\item -Use the {\tt Ex-ode.f} interface in the {\tt routines/default}
directory (and {\tt make all} in Scilab directory).
The call to the {\tt ode} function is as above:
\begin{verbatim}
-->ode(x0,t0,t,'myfydot')
\end{verbatim}
\end{itemize}
In this latter case, to add a new function, two files should be updated:
\begin{itemize}
\item The {\tt Flist} file: Flist is list of entry points. Just add the 
name of your function at in the appropriate list of functions.
\begin{verbatim}
ode_list= ... myfydot
\end{verbatim}
\item The {\tt Ex-ode.f} (or {\tt Ex-ode-more.f}) file: this file contains the 
source code for argument functions. Add your function here.
\end{itemize}

Many exemples are provided in the {\tt default} directory.
More complex examples are also given. For instance it is shown 
how to use Scilab variables as optional parameters of {\tt fydot}.

\section{Mexfiles}
The directories under \verb!SCIDIR/examples/mexfiles! contain 
some examples of Matlab mexfiles which can be used as interfaces
in the Scilab environment. The Scilab \verb!mexlib! library emulates
the most commonly used Matlab \verb!mxfunctions! such as 
\verb!mxGetM!, \verb!mxGetPr!, \verb!mxGetIr! etc. Not all the 
\verb!mxfunctions! are available but standard mexfiles which make use
of matrices (possibly sparse), structs, character strings 
and n-dimensional arrays can be used without any modification 
in the Scilab environment. If the source program is already compiled
and the mexfile given as a dynamic library, it is possible to  link
the library with Scilab (examples are provided for Linux (.glnx extension)
or Windows (.dll extension)).

\section{Complements} 
\subsection{Examining the data, function {\tt GetData}}
The functions {\tt GetRhsVar} and {\tt CreateVar}
described above for building an interface program can be used for
most programs involving matrices. Many other functions can be used 
for handling Scilab more complex data such as lists. See the examples
in the directories examples/interfaces.
It is also possible to define new objects from scratch within an interface.
Let us first describe how to scan the Scilab objects. This can be done by the
function {\tt GetData}.
Consider the following simple interface program:
\begin{verbatim}
#include "stack-c.h"
void intscan() 
{
  int *header; double *data;
  header = GetData(1);
  printf("%i %i %i %i\n", header[0], header[1], header[2], header[3]);
  data = (double *) &header[4];
  printf("%f %f %f\n", data[0]);
}
\end{verbatim}
This interface can be built by the following Scilab script, \verb!scan.sce!:
\begin{verbatim}
ilib_name  = 'libintscan';
files = ['intscan.o'];
libs  = [];
table = ['scan', 'intscan'];
ilib_build(ilib_name,table,files,libs);
\end{verbatim}
After entering \verb!-->exec scan.sce! at Scilab prompt, a file \verb!loader.sce! is made:
\begin{verbatim}
libintscan_path=get_file_path('loader.sce');
functions=['scan';];
addinter(libintscan_path+'/libintscan.so','libintscan',functions);
\end{verbatim}
Entering \verb!-->exec loader.sce! allows to call the new \verb!scan! function.
Now we can see the output of \verb!scan(A)! for, e.g., \verb!A=[4,2,3]!.
We see that the Scilab variable \verb!A! is represented internally by
a set of 4 integers (1,1,3,0) (the ``header'')  followed by 3 
doubles (4,2,3) (the ``data''). The header is made of the following:
type (1 stands for ``numeric matrix''), number of rows (1 since \verb!A! 
is a row vector), number of columns (3 since \verb!A! has three 
columns), complex type (0 since \verb!A! is real). The data contains 
the entries of \verb!A!. All entries are considered (and stored) as double.
Cleary, the function can be used to examine how Scilab variables are stored
internally. For instance if \verb!B=int32(A)! we see that \verb!B! is stored
with the header (8,1,3,4) and the int data (2,3,4). All integer matrix have 
the type 8, and int32 receive the flag 4.

The following program shows how a matrix of strings is represented.
\begin{verbatim}
#include "stack-c.h"
void intscan() 
{
  int *header; 
  int k,length,start,number;
  header = (int *) GetData(1);
  /* header = [10,Mrows,Ncols,0]  ... */
  sciprint("string-type= %i, nrows= %i, ncols=%i, (reserved=) %i \n", 
	   header[0],header[1],header[2],header[3]);
  /* ..[1, 1+length(entry 1),., 1+ .. +length(entry M*N) ].. */
  number=header[1]*header[2];
  start=5+number; 
  /*  codes entry 1,   ...,   codes entry M*N  */
  for (k=5; k<5+number; k++) {
    length=header[k]-header[k-1];
    sciprint("string %i has length %i\n", k-4, length);
    sciprint("Code: first char =%i last char = %i\n",header[start],
	     header[start+length-1]);	
    start=start+length;
  }
}
\end{verbatim}
We see here that string matrices are internally represented by integers. 
When a string matrix is passed to an interface and the
string matrix is processed by \verb!GetRhsVar(n,'c',&M,&N,&l)!
then the strings are transformed into C chars.
They can be obtained by the following piece of interface:
\begin{verbatim}
#include "stack-c.h"
void intscan() 
{
  int M,N,l;  char *str;
  GetRhsVar(1, "c", &M, &N, &l);
  str = (char *) cstk(l);
}
\end{verbatim}

\subsection{Creating new data types, function {\tt CreateData}}

Consider now the interface program:
\begin{verbatim}
#include "stack-c.h"
void intmy133() 
{
  int *header;
  CreateData(1, 5*sizeof(int));
  header = GetData(1);
  header[0]=133; header[1]=1; header[2]=3; header[3]=0;
  header[4]=35;
  LhsVar(1)=1;
}
\end{verbatim}
This interface can be built by the following Scilab script, \verb!my133.sce!:
\begin{verbatim}
ilib_name  = 'lib133';
files = ['intmy133.o'];
libs  = [];
table = ['my133', 'intmy133'];
ilib_build(ilib_name,table,files,libs);
\end{verbatim}
After entering \verb!-->exec my133.sce! at Scilab prompt, 
a file \verb!loader.sce! is made, in the current directory and the new scilab
function \verb!my133! is available after entering \verb!-->exec loader.sce!.
Let us call this function. We get:
\begin{verbatim}
-->X=my133()
 X  =
 
Undefined display for this data type
-->type(X)
 ans  =
 
    133.  
\end{verbatim}
A new variable has been created. Scilab knows its type \verb!133! which is 
the first integer in the header, but Scilab is unable to display this variable.
We can attach a generic name to the type 133, by doing the following:
\begin{verbatim}
-->typename('mytype', 133)
\end{verbatim}
The list of current names and types is obtained by the command 
\verb![names,types]=typname()! . The command \verb!typeof(X)! now returns
\verb!mytype!.
Now we can overload a function to display \verb!X!.
\begin{verbatim}
-->function %mytype_p(X)
-->disp('Cannot display this variable!')
-->endfunction
 
-->X
 X  =
 
Cannot display this variable!   
\end{verbatim}
Indeed, at this stage we have created a new type of variable, \verb!133! with
name {\tt mytype}. To really display the variable, we need to write a new
interface function.
Let us consider the following:
\begin{verbatim}
#include "stack-c.h"
void intdisp133() 
{
  int *header;
  header = GetData(1);
  header[0]=8; 
  LhsVar(1)=1;
}
\end{verbatim}
This function does nothing, except changing \verb!header[0]! from 133 to
8.
We can build a library with the two functions \verb!my133! and \verb!disp133!
with the scilab script:
\begin{verbatim}
ilib_name  = 'lib133';
files = ['intmy133.o', 'intdisp133.o'];
libs  = [];
table = ['my133', 'intmy133';
         'disp133' ,'intdisp133'];
ilib_build(ilib_name,table,files,libs);
\end{verbatim}

We can redefined the display function for variables tagged \verb!"mytype"!
by \verb!typename!.
\begin{verbatim}
-->function %mytype_p(X)
-->disp(disp133(X))
-->endfunction
 
-->X
 X  =
 
35
\end{verbatim}
When \verb!X! is typed at the scilab prompt, the function \verb!%mytype!
is searched to display \verb!X!, since \verb!X! is a variable of type 133
and such variables have the generic name "mytype", set by the command
\verb!typename('mytype',133)!. The function \verb!disp133! transforms the
variable X into a standard 1 x 1 integer matrix containing the constant 35.
(Note that only the type needs to be set).

\subsection{Values or references}
By default, the arguments given to the interface are passed ``by value''.
This means that, in the interface program, one is working with a copy
of the Scilab data. Consider for instance the following gateway function:
\begin{verbatim}
#include "stack-c.h"
void inttstfct() 
{ int m1,n1,l1;
  GetRhsVar(1, "d", &m1, &n1, &l1);
  stk(l1)[0] = 1;
  LhsVar(1) = 1;
}
\end{verbatim}
for the Scilab function {\tt X=tstfct(A)}. We assume that the variable \verb!A!
passed to \verb!tstfct! is a standard real matrix.
Note that we could use the following gateway which performs the same job.
\begin{verbatim}
#include "stack-c.h"
void inttstfct() 
{ int *header; double *data;
  header = (int *) GetData(1);
  data = (double *) &header[4];  
  data[0] = 1;
  LhsVar(1) = 1;
}
\end{verbatim}
This function is installed into Scilab by executing the script
\begin{verbatim}
ilib_name  = 'libinttstfct';
files = ['inttstfct.o'];
libs  = [];
table = ['tstfct', 'inttstfct'];
ilib_build(ilib_name,table,files,libs);
\end{verbatim}
and executing the newly created script \verb!loader.sce!.

Assume also that \verb!A! is the 2 x 2 matrix \verb!A=zeros(2,2)!, 
and consider the Scilab command \verb!-->B=tstfct(A)!. In the interface
program, before its assignment, \verb!stk(l1)[0]! is equal to 0, i.e. the first
entry of \verb!A!, {\tt A(1,1)}. 
The output {\tt B} will be, as expected, the Scilab matrix \verb![1 0;0 0]!.
But the Scilab variable {\tt A} will not be modified. This behavior is similar
with the usual Scilab functions: the input parameters of the function are
not modified when the  function is called.
It is however possible to pass the parameters by reference. This can be useful
if the interfaced program do not alter the input data (the data can be used
in read-only mode).
Let us enter the command \verb!-->funptr tstfct!. We get:
\begin{verbatim}
-->funptr tstfct
 ans  =
 
    50101.  
\end{verbatim}
which means: the function \verb!tstfct! has number \verb!01! in interface
number \verb!501!.
It is possible to convert the gateway function into a gateway in which the 
variables are passed by reference. This is done as follows 
by the function \verb!intppty!.
\begin{verbatim}
-->intppty(501) // adding gateway 501 to the list.
 
-->intppty()   
 ans  =
 
!   6.    13.    16.    19.    21.    23.    41.    42.    501. !
\end{verbatim}
Note that if several Scilab functions are built together in the same
inerface they will all receive input parameters as reference.
The behavior of \verb!tstfct! is changed. Its argument is modified when
\verb!tstfct! is called:
\begin{verbatim}
-->A
 A  =
 
!   0.    0. !
!   0.    0. !
-->tstfct(A)
 ans  =
 
!   1.    0. !
!   0.    0. !
-->A
 A  =
 
!   1.    0. !
!   0.    0. !
\end{verbatim}
Finally, we note that the function {\tt GetRawData} gives the 
internal representation of the reference variable and {\tt GetData}
gives the internal representation of the value variable pointed to
by the reference.
\section{Intersci}
The directory \verb!SCIDIR/examples/intersci-examples-so! contains
several examples for using \verb!intersci! which is a tool for
producing gateway routines from a descriptor file.
Let us describe a simple example, \verb!ex01!.
We want to build an interface for the following C function~:
\begin{verbatim}
int ext1c(n, a, b, c)
     int *n;
     double *a, *b, *c;
{   
  int k;
  for (k = 0; k < *n; ++k) 
      c[k] = a[k] + b[k];
  return(0);
}
\end{verbatim}
This function just adds the two real vectors \verb!a! and \verb!b! 
with \verb!n! entries and returns the result in \verb!c!.
We want to have in Scilab a function \verb!c=ext1c(a,b)! which
performs this operation by calling  \verb!ext1c!.
For that, we provide a \verb!.desc! file, \verb!ex01fi.desc!~:
\begin{verbatim}
ext1c	a b 
a 	vector	m
b 	vector	m
c	vector  m 

ext1c   m a b c 
m	integer 
a	double 
b	double 
c	double 

out	sequence	c
***********************
\end{verbatim}
\noindent
This file in divided into three parts separated by a blank line. 
The upper part (four first lines) describes the Scilab function 
\verb!c=ext1c(a,b)!.
Then (next five lines) the C function is described. The last line of 
\verb!ex01fi.desc! gives the name of output variables. 
To run \verb!intersci! with this file as input we enter the command~:
\begin{verbatim}
SCIDIR/bin/intersci-n ex01fi
\end{verbatim}
Two files are created~: \verb!ex01fi.c! and \verb!ex01fi_builder.sce!.
The file \verb!ex01fi.c! is the C gateway function needed for interfacing
\verb!ext1c! with Scilab. It is a gateway file built as explained above 
(see \ref{interface})~:

\scriptsize
\begin{verbatim}
#include "stack-c.h"
int intsext1c(fname)
   char *fname;
{
 int m1,n1,l1,mn1,m2,n2,l2,mn2,un=1,mn3,l3;
 CheckRhs(2,2);
 CheckLhs(1,1);
 /*  checking variable a */
 GetRhsVar(1,"d",&m1,&n1,&l1);
 CheckVector(1,m1,n1);
 mn1=m1*n1;
 /*  checking variable b */
 GetRhsVar(2,"d",&m2,&n2,&l2);
 CheckVector(2,m2,n2);
 mn2=m2*n2;
 /* cross variable size checking */
 CheckDimProp(1,2,m1*n1 != m2*n2);
 CreateVar(3,"d",(un=1,&un),(mn3=mn1,&mn3),&l3);/* named: c */
 C2F(ext1c)(&mn1,stk(l1),stk(l2),stk(l3));
 LhsVar(1)= 3;
 return 0;
}
\end{verbatim}
\normalsize

The file \verb!ex01fi_builder.sce! is the following~:
\begin{verbatim}
// generated with intersci 
ilib_name = 'libex01fi'		// interface library name

table =["ext1c","intsext1c"];
ilib_build(ilib_name,table,files,libs);
\end{verbatim}

This  builder file is to be executed 
by Scilab after the variables \verb!files! and \verb!libs! have been set~:
\begin{verbatim}
-->files = ['ex01fi.o' , 'ex01c.o'];
-->libs  = [] ;
-->exec ex01fi_builder.sce
\end{verbatim}

\noindent
A dynamic library is then created as well as a file \verb!loader.sce!. 
Executing \verb!loader.sce! loads the library into Scilab and executes the
\verb!addinter! command to link the library and associate the name
of the function \verb!ext1c! to it. We can then call the new function~;
\begin{verbatim}
-->exec loader.sce
-->a=[1,2,3];b=[4,5,6]; c=ext1c(a,b);
\end{verbatim}

\noindent
To use \verb!intersci! one has to construct a \verb!.desc! file.
The keywords which describe the Scilab function and the function
to be called can be found in the examples given.


%\end{document}



