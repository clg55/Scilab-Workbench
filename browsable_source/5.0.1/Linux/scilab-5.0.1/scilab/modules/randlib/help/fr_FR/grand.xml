<?xml version="1.0" encoding="ISO-8859-1"?>
<!--
 * Scilab ( http://www.scilab.org/ ) - This file is part of Scilab
 * Copyright (C) 2008 - INRIA
 * 
 * This file must be used under the terms of the CeCILL.
 * This source file is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at    
 * http://www.cecill.info/licences/Licence_CeCILL_V2-en.txt
 *
 -->
<refentry xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svg="http://www.w3.org/2000/svg" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:db="http://docbook.org/ns/docbook" version="5.0-subset Scilab" xml:lang="fr" xml:id="grand">
  <info>
    <pubdate>$LastChangedDate$</pubdate>
  </info>
  <refnamediv>
    <refname>grand</refname>
    <refpurpose> Générateur(s) de nombres pseudo-aléatoires</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <title>Séquence d'appel</title>
    <synopsis>Y=grand(m, n, dist_type [,p1,...,pk])
Y=grand(X, dist_type [,p1,...,pk])
Y=grand(n, dist_type [,p1,...,pk])
S=grand(action [,q1,....,ql])</synopsis>
  </refsynopsisdiv>
  <refsection>
    <title>Paramètres</title>
    <variablelist>
      <varlistentry>
        <term>m, n</term>
        <listitem>
          <para>entiers, dimensions de la matrice de nombres aléatoires à obtenir <literal>Y</literal>
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>X </term>
        <listitem>
          <para>une matrice (ou un vecteur) dont seules les dimensions (<literal>m x n</literal>) sont utilisées
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>dist_type</term>
        <listitem>
          <para>chaîne de caractères donnant la loi de distribution des nombres aléatoires ('bin', 'nor', 'poi', etc ...)
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>p1, ..., pk</term>
        <listitem>
          <para>les (éventuels) paramètres de la distribution <literal>dist_type</literal>
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Y</term>
        <listitem>
          <para>la matrice de nombres aléatoires <literal>m x n</literal>
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>action</term>
        <listitem>
          <para>chaîne de caractères spécifiant l'action à entreprendre sur le générateur de base ('setgen' pour changer
     le générateur courant, 'getgen' pour obtenir le nom du générateur courant, 'getsd' pour obtenir l'état
     du générateur courant, etc...).
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>q1, ..., ql</term>
        <listitem>
          <para>les paramètres  (éventuels) de l'action à effectuer sur le générateur de base.
</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>S</term>
        <listitem>
          <para>résultat de l'action (en général une chaîne ou un vecteur colonne)
</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>
  <refsection>
    <title>Description</title>
    <para>
     Cette fonction peut être utilisée pour générer des nombres pseudo-aléatoires à partir
     d'une loi de distribution donnée (binomiale, uniforme, normale,...) : ces nombres peuvent
     être considérés comme des réalisations de variables aléatoires indépendantes qui suivent
     la loi donnée. Dans ce cas vous devez appliquer l'une des <emphasis>trois premières séquences 
     d'appel</emphasis> pour obtenir une matrice <literal>m x n</literal> de tels nombres. La deuxième 
     séquence est équivalente à la première si <literal>X</literal> est une matrice <literal>m x n</literal> 
     et la troisième forme s'applique lorsque la loi est vectorielle (comme la loi multinomiale) :
     une réalisation correspond alors à un vecteur colonne (de dimension <literal>m</literal>) et 
     l'on obtient ainsi <literal>n</literal> réalisations sous la forme d'une matrice
      <literal>m x n</literal>. 

  </para>
    <para><emphasis>La dernière forme d'appel</emphasis> s'utilise pour entreprendre diverses actions sur 
     le générateur de base (depuis la version 2.7 vous pouvez choisir parmi plusieurs 
     générateurs comme Mersenne-Twister, KISS, clcg4, ...). Ces générateurs fournissent 
     des entiers selon une loi uniforme sur un intervalle très grand (distribution lgi), 
     les autres types de lois s'obtenant à partir de ces générateurs de base 
     (en général suivant un schéma lgi -&gt; U([0,1)) -&gt; distribution cherchée).
  </para>
  </refsection>
  <refsection>
    <title>Générer des nombres aléatoires selon une loi donnée</title>
    <variablelist>
      <varlistentry>
        <term>beta</term>
        <listitem>
          <para>   : <literal>Y=grand(m,n,'bet',A,B)</literal> génère des nombres aléatoires suivant 
     la loi beta de paramètres <literal>A</literal> and <literal>B</literal>. 
     La densité de cette loi est (<literal>0 &lt; x &lt; 1</literal>) :</para>
          <programlisting><![CDATA[
          A-1    B-1
         x   (1-x)   / beta(A,B)  ( beta(A,B) = gamma(A+B) / (gamma(A) gamma(B)) )
     ]]></programlisting>
          <para><literal>A</literal> et <literal>B</literal> devant être des réels &gt; 10^(-37).
     Fonction(s) associée(s) : <link linkend="cdfbet">cdfbet</link>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>binomiale</term>
        <listitem>
          <para>   : <literal>Y=grand(m,n,'bin',N,p)</literal>  génère des nombres aléatoires suivant la loi
     binomiale de paramètres <literal>N</literal> (entier str. positif) et <literal>p</literal>
     (réel de [0,1]) : nombre de succès au cours de <literal>N</literal> épreuves de Bernouilli
     de probabilité de succès <literal>p</literal>.
     Fonction(s) associée(s) : <link linkend="binomial">binomial</link>, <link linkend="cdfbin">cdfbin</link>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>binomiale négative</term>
        <listitem>
          <para>   : <literal>Y=grand(m,n,'nbn',N,p)</literal> génère des nombres aléatoires suivant la loi binomiale
     négative de paramètres <literal>N</literal> (entier str. positif) et <literal>p</literal> (réel 
     de ]0,1[) : nombre d'échecs avant d'obtenir <literal>N</literal> succès dans des épreuves
     de Bernouilli de probabilité de succès <literal>p</literal>.
     Fonction(s) associée(s) : <link linkend="cdfnbn">cdfnbn</link>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>chi 2</term>
        <listitem>
          <para>   : <literal>Y=grand(m,n,'chi', Df)</literal> génère des nombres aléatoires suivant la loi du chi 2
     à <literal>Df</literal> (réel &gt; 0.0) degrés de liberté. 
     Fonction(s) associée(s) : <link linkend="cdfchi">cdfchi</link>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>chi 2 non centrée</term>
        <listitem>
          <para>   : <literal>Y=grand(m,n,'nch',Df,Xnon)</literal> génère des nombres aléatoires suivant la loi du chi 2
     non centrée à <literal>Df</literal> degrés de liberté (réel &gt;= 1.0) 
     le paramètre de décentrage étant <literal>Xnonc</literal> (réel &gt;= 0.0).
     Fonction(s) associée(s) : <link linkend="cdfchn">cdfchn</link>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>exponentielle</term>
        <listitem>
          <para>   : <literal>Y=grand(m,n,'exp',Av)</literal> génère des nombres aléatoires suivant la loi exponentielle
     de moyenne <literal>Av</literal> (réel &gt;= 0.0).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>F variance ratio</term>
        <listitem>
          <para>   : <literal>Y=grand(m,n,'f',Dfn,Dfd)</literal> génère des nombres aléatoires suivant la loi F 
     (variance ratio) à <literal>Dfn</literal> (réel &gt; 0.0) degrés de liberté au numérateur et
     <literal>Dfd</literal> (réel &gt; 0.0) degrés de liberté au dénominateur.
     Fonction(s) associée(s) : <link linkend="cdff">cdff</link>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>non central F variance ratio</term>
        <listitem>
          <para>   : <literal>Y=grand(m,n,'nf',Dfn,Dfd,Xnon)</literal> génère des nombres aléatoires suivant la loi 
     F (variance ratio) non centrée à <literal>Dfn</literal> (réel &gt;= 1) degrés de liberté 
     au numérateur, et <literal>Dfd</literal> (réel &gt; 0) degrés de liberté au dénominateur, 
     <literal>Xnonc</literal> (réel &gt;= 0) étant le paramètre de décentrage. 
     Fonction(s) associée(s) : <link linkend="cdffnc">cdffnc</link>.  </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>gamma</term>
        <listitem>
          <para>   : <literal>Y=grand(m,n,'gam',shape,scale)</literal> génère des nombres aléatoires suivant la loi
     gamma de paramètres <literal>shape</literal> (réel &gt; 0) et <literal>scale</literal> 
      (réel &gt; 0). La densité est :</para>
          <programlisting><![CDATA[
               shape  (shape-1)   -scale x
          scale       x          e          /  gamma(shape)
     ]]></programlisting>
          <para>Fonction(s) associée(s) : <link linkend="gamma">gamma</link>, <link linkend="cdfgam">cdfgam</link>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Gauss Laplace (normale)</term>
        <listitem>
          <para>   : <literal>Y=grand(m,n,'nor',Av,Sd)</literal> génère des nombres aléatoires suivant la loi normale 
     de moyenne <literal>Av</literal> (réel) et d'écart type <literal>Sd</literal>
     (réel &gt;= 0).
     Fonction(s) associée(s) : <link linkend="cdfnor">cdfnor</link>, <link linkend="erf">erf</link>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>multi normale</term>
        <listitem>
          <para>   : <literal>Y=grand(n,'mn',Mean,Cov)</literal> génère <literal>n</literal> réalisations indépendantes de la
     loi multi-normale ; <literal>Mean</literal> doit être un vecteur <literal>m x 1</literal> et <literal>Cov</literal> 
     une matrice <literal>m x m</literal> symétrique et définie positive, (<literal>Y</literal> est alors une
     matrice <literal>m x n</literal>).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>geometrique</term>
        <listitem>
          <para> : <literal>Y=grand(m,n,'geom', p)</literal>
          génère des nombres aléatoires suivant la loi
          geométrique de paramètre <literal>p</literal> : nombre
          d'épreuves de Bernouilli (de probabilité de succès
          <literal>p</literal>) jusqu'à obtenir un succès
          (<literal>p</literal> doit appartenir à l'intervalle
          <literal>[pmin,1]</literal> (avec <literal>pmin = 1.3
          10^(-307)</literal>).</para>
	  <para><literal>Y</literal> contient des nombres réels
	  positifs à valeur entière qui sont "le nombre de
	  tentatives nécessaire pour obtenir un succès" pour
	  chaque tirage.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>markov</term>
        <listitem>
          <para>   : <literal>Y=grand(n,'markov',P,x0)</literal> génère <literal>n</literal> états successifs d'une chaîne de 
     Markov décrite par la matrice de transition <literal>P</literal>. L'état initial est donné par 
     <literal>x0</literal>. Si <literal>x0</literal> est une matrice de taille 
     <literal>m=size(x0,'*')</literal> 
     alors <literal>Y</literal> est une matrice de taille <literal>m x n</literal>. <literal>Y(i,:)</literal> étant le
     chemin à partir de l'état initial <literal>x0(i)</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>multinomiale</term>
        <listitem>
          <para>   : <literal>Y=grand(n,'mul',nb,P)</literal> génère <literal>n</literal> réalisations indépendantes de la loi
      Multinomiale :  classer <literal>nb</literal> éventualités dans <literal>m</literal> catégories (mettre
     <literal>nb</literal> "boules" dans <literal>m</literal> "boites"). <literal>P(i)</literal> 
     étant la probabilité qu'une éventualité soit de categorie i. <literal>P</literal> le vecteur des
     probabilités est de taille <literal>m-1</literal> (la probabilté de la catégorie <literal>m</literal> 
     étant <literal>1-sum(P)</literal>). <literal>Y</literal> est alors de dimensions <literal>m x n</literal>, 
     chaque colonne <literal>Y(:,j)</literal> étant une réalisation de cette loi : <literal>Y(i,j)</literal> 
     est le nombre d'éventualités classées en catégorie <literal>i</literal> pour la <literal>j</literal> ème
     réalisation (<literal>sum(Y(:,j)) = nb</literal>).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Poisson</term>
        <listitem>
          <para>   : <literal>Y=grand(m,n,'poi',mu)</literal> génère des nombres aléatoires suivant la loi de Poisson 
     de moyenne <literal>mu (réel &gt;= 0.0)</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>permutations aléatoires</term>
        <listitem>
          <para>   : <literal>Y=grand(n,'prm',vect)</literal> génère <literal>n</literal> permutations aléatoire du
     vecteur colonne (<literal>m x 1</literal>) <literal>vect</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>uniforme (def)</term>
        <listitem>
          <para>   : <literal>Y=grand(m,n,'def')</literal> génère des nombres aléatoires suivant la loi uniforme 
     sur <literal>[0,1[</literal> (1 n'est jamais retourné).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>uniforme (unf)</term>
        <listitem>
          <para>   : <literal>Y=grand(m,n,'unf',Low,High)</literal> génère des nombres aléatoires suivant la loi 
   uniforme sur <literal>[Low, High[</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>uniforme (uin)</term>
        <listitem>
          <para>   : <literal>Y=grand(m,n,'uin',Low,High)</literal> génère des entiers aléatoires suivant la loi uniforme
     sur <literal>[Low, High]</literal>. <literal>High</literal>
     et <literal>Low</literal> doivent être des entiers tels que <literal>(High-Low+1)
	    &lt; 2147483561</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>uniforme (lgi)</term>
        <listitem>
          <para> : <literal>Y=grand(m,n,'lgi')</literal> retourne la sortie du générateur de base courant : des entiers
     aléatoires suivant une loi uniforme sur :</para>
          <itemizedlist>
            <listitem>
              <para><literal>[0, 2^32 - 1]</literal> for mt, kiss and fsultra</para>
            </listitem>
            <listitem>
              <para><literal>[0, 2147483561]</literal> for clcg2</para>
            </listitem>
            <listitem>
              <para><literal>[0, 2^31 - 2]</literal> for clcg4 </para>
            </listitem>
            <listitem>
              <para><literal>[0, 2^31 - 1]</literal> for urand.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>
  <refsection>
    <title>Actions sur le(s) générateur(s) de base</title>
    <para> Depuis Scilab-2.7 vous avez la possibilité de choisir parmi plusieurs générateurs de base
      (donnant des entiers aléatoires suivant la loi 'lgi') :
  </para>
    <variablelist>
      <varlistentry>
        <term>mt</term>
        <listitem>
          <para>le Mersenne-Twister de M. Matsumoto and T. Nishimura, période d'environ <literal>2^19937</literal>, 
         état interne donné par <literal>624</literal> entiers (plus un index); c'est le générateur  
         par défaut.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>kiss</term>
        <listitem>
          <para>Le Keep It Simple Stupid de G. Marsaglia,  période d'environ <literal>2^123</literal>,
         état interne donné par <literal>4</literal> entiers.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>clcg2</term>
        <listitem>
          <para>une combinaison de 2 générateurs linéaires congruentiels de P. L'Ecuyer,
         période d'environ <literal>2^61</literal>, état interne donné par <literal>2</literal> entiers ; 
         c'était le seul générateur de base utilisé auparavent par grand (cette
         version est cependant légèrement différente de l'ancienne).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>clcg4</term>
        <listitem>
          <para>une combinaison de 4 générateurs linéaires congruentiels de P. L'Ecuyer,
         période d'environ <literal>2^121</literal>, état interne donné par 4 entiers ; ce générateur
         peut être partagé en <literal>101</literal> générateur virtuels (en fait la suite de 
         longueur <literal>2^121</literal> peut être découpée en <literal>101</literal> sous-suites) ce qui peut
         être utile dans certains cas (voir 'Actions specifiques à clcg4' et
         'Exemple d'utilisation de clcg4').</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>urand</term>
        <listitem>
          <para>le générateur de base (congruentiel affine...) utilisé par la fonction 
         <link linkend="rand">rand</link>, état interne constitué d'un seul entier, période de 
         <literal>2^31</literal> (basé sur le vol 2 du Art of Computer Science de Knuth).
         C'est le plus rapide de cette liste mais il est maintenant dépassé : il est
         préférable de ne pas l'utiliser pour une simulation sérieuse consommant
         beaucoup de nombres aléatoires (en particulier ce générateur ne passe 
         pas certains tests statistiques classiques).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>fsultra</term>
        <listitem>
          <para>un générateur SWB (subtract-with-borrow) mixé avec un générator congruentiel 
             concu par Arif Zaman et George Marsaglia. Sa période est supérieure à <literal>10^356</literal>,
             et son état interne est constitué d'un tableau de 37 entiers, d'un index sur
             ce tableau et d'un drapeau (0 ou 1) ainsi qu'un autre entier donnant l'état interne
             du générateur congruentiel.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>
  <refsection>
    <title>Actions</title>
    <variablelist>
      <varlistentry>
        <term>action= 'getgen'</term>
        <listitem>
          <para>   : <literal>S=grand('getgen')</literal> retourne le nom du générateur de base actuel (<literal>S</literal> est
     l'une des chaînes de caractères 'mt', 'kiss', 'clcg2', 'clcg4', 'urand',
	  'fsultra').</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>action= 'setgen'</term>
        <listitem>
          <para>   : <literal>grand('setgen',gen)</literal> permet de changer le générateur de base : <literal>gen</literal>
     doit être l'une des chaînes de caractères 'mt', 'kiss', 'clcg2', 'clcg4', 'urand', 'fsultra'.
     En cas de succès la fonction retourne cette même chaîne.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>action= 'getsd'</term>
        <listitem>
          <para>   : <literal>S=grand('getsd')</literal> retourne l'état interne actuel (les 'germes' dans l'ancienne 
     appelation quoique ce terme désigne plutôt l'état initial) du générateur de base courant ;
     <literal>S</literal> est un vecteur colonne (d'entiers) de dimension <literal>625</literal> 
     pour mt (la première composante étant un 'index' sur l'état, c-a-d un entier de l'intervalle
      <literal>[1,624]</literal>), <literal>4</literal> 
     pour kiss, <literal>2</literal> pour clcg2 , <literal>40</literal>pour fsultra, <literal>4</literal> pour clcg4 
     (pour ce dernier vous obtenez l'état interne du générateur virtuel courant), et <literal>1</literal> 
     pour urand.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>action= 'setsd'</term>
        <listitem>
          <para>   : <literal>grand('setsd',S), grand('setsd',s1[,s2,s3,s4])</literal> impose l'état interne du générateur de
     base courant : </para>
          <variablelist>
            <varlistentry>
              <term>pour mt</term>
              <listitem>
                <para><literal>S</literal> est un vecteur d'entiers de dimension <literal>625</literal> (la première composante
       étant un index sur <literal>[1,624]</literal>), les <literal>624</literal> dernières composantes doivent 
       être dans <literal>[0,2^32[</literal>) (mais ne doivent pas être toutes nulles) ; une initialisation
       plus simple est possible (et recommandée) en donnant un seul entier <literal>s1</literal> (<literal>s1</literal> appartenant
       à <literal>[0,2^32[</literal>) ;</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>pour kiss</term>
              <listitem>
                <para><literal>4</literal> entiers <literal>s1,s2, s3,s4</literal> dans <literal>[0,2^32[</literal> doivent être
       fournis ;</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>pour clcg2</term>
              <listitem>
                <para><literal>2</literal> entiers <literal>s1</literal> dans <literal>[1,2147483562]</literal> et <literal>s2</literal> 
       dans <literal>[1,2147483398]</literal> doivent être fournis ;</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>pour clcg4</term>
              <listitem>
                <para><literal>4</literal> entiers <literal>s1</literal> dans <literal>[1,2147483646]</literal>, <literal>s2</literal> 
       dans <literal>[1,2147483542]</literal>, <literal>s3</literal> dans <literal>[1,2147483422]</literal>, 
       <literal>s4</literal> dans <literal>[1,2147483322]</literal> sont requis ;
       <literal>ATTENTION</literal> : avec clcg4 vous positionnez l'état interne du générateur virtuel
       courant mais vous perdez alors la synchronisation avec les autres générateurs virtuels.
       (=&gt; si vous utilisez clcg4 avec différents générateurs virtuels, il faut utiliser
       l'option 'setall' qui permet de changer l'état interne (du générateur numéro 0) tout en
       recalculant l'état initial des 100 autres générateurs virtuels).</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>pour urand</term>
              <listitem>
                <para><literal>1</literal> entier <literal>s1</literal> appartenant à
	      <literal>[0,2^31</literal>[ est requis.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>for fsultra</term>
              <listitem>
                <para>:  <literal>S</literal> est un vecteur de <literal>40</literal> entiers (son premier élément doit être dans
       l'intervalle<literal>[0,37]</literal>, son deuxième (drapeau) doit être 0 ou 1, le troisième un
       entier de [1,2^32[ et les 37 composantes suivantes, des entiers de [0,2^32[) ; il est recommandé
       d'utiliser l'autre procédure d'initialisation (plus simple) avec deux entiers <literal>s1</literal> et 
       <literal>s2</literal> de <literal>[0,2^32[</literal>.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>action= 'phr2sd'</term>
        <listitem>
          <para>   : <literal>Sd=grand('phr2sd', phrase)</literal> étant donnée une chaîne de caractères <literal>phrase</literal>
     cet appel retourne un vecteur <literal>1 x 2</literal> qui peut être utilisé comme
     état interne pour un générateur de base (initialement adapté pour clcg2).</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>
  <refsection>
    <title>Options specifiques à clcg4</title>
    <para>
    Le générateur clcg4 peut être utilisé comme les autres mais il offre l'avantage de pouvoir être
    découpé en (<literal>101</literal>) générateurs virtuels différents, c-a-d avec des séquences sans
    intersection (quand vous utilisez un générateur classique vous pouvez changer l'état initial
    de façon à obtenir une autre séquence mais vous n'êtes pas complètement sûr d'obtenir une
    séquence complètement différente). Chaque générateur virtuel correspond à une séquence de 
    longueur <literal>2^72</literal> qui est de plus découpée en <literal>V=2^31</literal> segments de longueur
    <literal>W=2^41</literal>. Pour un générateur virtuel donné vous pouvez retourner au début de la séquence
    ou au début du segment ou bien au début du segment suivant. 
    Vous pouvez aussi changer l'état initial du générateur <literal>0</literal> avec l'option 
    'setall' qui recalcule l'état initial des autres générateurs virtuels de sorte à obtenir 
    la synchronisation entre les générateurs (c-a-d qu'en fonction du nouvel état initial du générateur
    <literal>0</literal> l'état initial des générateurs <literal>1..100</literal> sont recalculés de façon à
    obtenir <literal>101</literal> séquences qui ne s'intersectent pas).
  </para>
    <variablelist>
      <varlistentry>
        <term>action= 'setcgn'</term>
        <listitem>
          <para>   : <literal>grand('setcgn',G)</literal> sélectionne le générateur virtuel numéro <literal>G</literal> :
     lorsque le générateur de base courant est clcg4, c'est le générateur virtuel <literal>G</literal>
     qui sera alors utilisé ; les <literal>101</literal> générateurs virtuels sont numérotés 
     <literal>0,1,..,100</literal> (ainsi <literal>G</literal> doit être un entier de l'intervalle
     <literal>[0,100]</literal>) ; par défaut le générateur virtuel courant est celui de numéro
     <literal>0</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>action= 'getcgn'</term>
        <listitem>
          <para>   : <literal>S=grand('getcgn')</literal> retourne le numéro du générateur
	  virtuel courant.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>action= 'initgn'</term>
        <listitem>
          <para> : <literal>grand('initgn',I)</literal> réinitialise l'état du générateur virtuel courant :</para>
          <variablelist>
            <varlistentry>
              <term>I = -1</term>
              <listitem>
                <para>remet l'état à sa valeur initiale</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>I = 0</term>
              <listitem>
                <para>remet l'état au début du segment courant</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>I = 1</term>
              <listitem>
                <para>positionne l'état au début du segment suivant et met à jour les valeurs définissant
        le segment courant (vous ne pouvez pas revenir au début du segment précédent).</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>action= 'setall'</term>
        <listitem>
          <para>   : <literal>grand('setall',s1,s2,s3,s4)</literal> impose l'état interne du générateur virtuel
     de numéro <literal>0</literal> à <literal>s1,s2,s3,s4</literal>. L'état initial des autres générateurs est
     alors reconstruit (de façon à obtenir 101 séquences qui ne s'intersectent pas). Voir 
     l'action 'setsd' pour les contraintes sur <literal>s1, s2, s3, s4</literal>.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>action= 'advnst'</term>
        <listitem>
          <para>   : <literal>grand('advnst',K)</literal> avance l'état du générateur virtuel courant de <literal>2^K</literal> 
     valeurs et réinitialise l'état initial (du générateur virtuel courant) à
	ce nouvel état.</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>
  <refsection>
    <title>Exemple d'utilisation de clcg4</title>
    <para>
    On cherche à comparer deux techniques statistiques sur des données de tailles différentes.
    La première, utilisant le 'bootstrapping' est supposée a priori aussi précise que
    la deuxième technique (utilisant uniquement la force brute) tout en utilisant moins 
    de données. Pour la première méthode, un ensemble de données de taille n1, uniformément
    distribuée entre 25 et 50 devra être généré puis analysé par la méthode.  Pour la
    seconde méthode, on procède de même avec une taille n2 à choisir entre 100 et 200. Ce processus
    est répété 1000 fois. Pour la réduction de la variance, on veut que les nombres aléatoires
    utilisés dans les deux méthodes soient les mêmes pour chacune des 1000 comparaisons.
    Comme la deuxième méthode utilise plus de nombres aléatoires, la synchronisation
    peut être difficile si l'on utilise un générateur classique. Avec un générateur 
    comme clcg4 c'est par contre très simple : utilisez le générateur 0 pour obtenir
    la taille n1 du jeux de données et le générateur 1 pour obtenir les données.
    Avec le générateur 0 tirer la taille n2 puis resélectionner le générateur 1 et revenez
    au début du segment courant pour obtenir les n2 données pour la deuxième méthode : ainsi
    les données initiales (les n1 premieres) sont les mêmes pour les deux méthodes.
    Pour la comparaison suivante, il suffit d'avancer le générateur 1 au segment suivant,
    etc, etc.
  </para>
  </refsection>
  <refsection>
    <title>Voir Aussi</title>
    <simplelist type="inline">
      <member>
        <link linkend="rand">rand</link>
      </member>
    </simplelist>
  </refsection>
  <refsection>
    <title>Auteurs</title>
    <variablelist>
      <varlistentry>
        <term>randlib</term>
        <listitem>
          <para> Les codes qui permettent de générer les lois autres que def, unf, lgi,  uin et geom 
     proviennent de "Library of Fortran Routines for Random Number  Generation", 
     de Barry W. Brown et James Lovato, Department of Biomathematics, The University of 
     Texas, Houston.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>mt</term>
        <listitem>
          <para> Le code est le mt19937int.c par M. Matsumoto and  T. Nishimura, "Mersenne Twister: 
     A 623-dimensionally equidistributed  uniform pseudorandom number generator", 
     ACM Trans. on Modeling and  Computer Simulation Vol. 8, No. 1, January, pp.3-30 1998.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>kiss</term>
        <listitem>
          <para> Ce code a été donné par G. Marsaglia lors d'une discussion concernant la génération
     de nombres aléatoires en langage C dans plusieurs forums usenet (dont sci.math.num-analysis) 
     "My offer of  RNG's for C was an invitation to dance..." seul kiss a été
     inclus dans Scilab (kiss est construit à partir de plusieurs générateurs mais qui ne
     sont accessibles à l'interpréteur scilab).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>clcg2</term>
        <listitem>
          <para> Cette méthode est de P. L'Ecuyer mais le code C code provient de la page
     personnelle de Luc  Devroye (http://cgm.cs.mcgill.ca/~luc/rng.html).</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>clcg4</term>
        <listitem>
          <para> Ce code est de P. L'Ecuyer et Terry H.Andres et est distribué avec un article
     à partir de la page personnelle de P. L'Ecuyer 
     ( http://www.iro.umontreal.ca/~lecuyer/papers.html). Ce paquetage est le successeur 
     logique d'un plus ancien utilisant le générateur clcg2 (muni d'un mécanisme équivalent
     de générateurs virtuels) : P.  L'Ecuyer and S. Cote. Implementing a Random   
     Number Package with Splitting Facilities.  ACM Transactions on Mathematical Software 
     17:1,pp 98-111.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>fsultra</term>
        <listitem>
          <para> un code d' Arif Zaman (arif@stat.fsu.edu) et de George Marsaglia (geo@stat.fsu.edu)</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>scilab packaging</term>
        <listitem>
          <para> Par Jean-Philippe Chancelier et Bruno Pinçon</para>
        </listitem>
      </varlistentry>
    </variablelist>
  </refsection>
</refentry>
