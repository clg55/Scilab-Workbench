<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?> 
<!DOCTYPE MAN SYSTEM "../../man.dtd">
<MAN>
  <LANGUAGE>eng</LANGUAGE>
  <TITLE>schur  </TITLE>
  <TYPE>Scilab Function  </TYPE>
  <DATE>April 1993  </DATE>
  <SHORT_DESCRIPTION name="schur"> [ordered] Schur decomposition  </SHORT_DESCRIPTION>
  <CALLING_SEQUENCE>
  <CALLING_SEQUENCE_ITEM>[U,T] = schur(A)   </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>[U,dim]=schur(A,flag)  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>[U,dim]=schur(A,myfunction)  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>
  <PARAM>
 <PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>A  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : real or complex square matrix. For ordered forms <VERB>A</VERB> is assumed real.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>flag  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : character string (<VERB>&apos;c&apos;</VERB> or <VERB>&apos;d&apos;</VERB>)
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>myfunction  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : an ``external&apos;&apos; function (this parameter can also be a list or character string)
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>U  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : orthogonal or unitary square matrix
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>T  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : matrix
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>dim  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : integer
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 </PARAM_INDENT>
  </PARAM>
  <DESCRIPTION>
  <P>
    Schur forms, ordered Schur forms
  </P>
  </DESCRIPTION>
  <ITEMIZE label='Usual schur form'>
  <P>
    produces a Schur matrix <VERB>T</VERB> and a unitary matrix <VERB>U</VERB> so that <VERB>A = U*T*U&apos;</VERB> and <VERB>U&apos;*U = eye(U)</VERB>. By itself, schur(<VERB>A</VERB>) returns <VERB>T</VERB>. If <VERB>A</VERB> is complex, the Complex Schur Form is returned in matrix <VERB>T</VERB>. The Complex Schur Form is upper triangular with the eigenvalues of <VERB>A</VERB> on the diagonal. If <VERB>A</VERB> is real, the Real Schur Form is returned.  The Real Schur Form has the real eigenvalues on the diagonal and the complex eigenvalues in 2-by-2 blocks on the diagonal.
  </P>
  </ITEMIZE>
  <ITEMIZE label='Ordered stable form'>
  <P>
    returns an unitary matrix <VERB>U</VERB> which transforms <VERB>A</VERB> into schur form. In addition, the dim first columns of <VERB>U</VERB>  make a basis of the  eigenspace of <VERB>A</VERB> associated with eigenvalues with negative  real parts (stable &quot;continuous time&quot; eigenspace).
  </P>
  <P>
    returns an unitary matrix <VERB>U</VERB> which transforms <VERB>A</VERB> into schur form. In addition, the <VERB>dim</VERB> first columns of <VERB>U</VERB> span a basis of the  eigenspace of <VERB>A</VERB> associated with eigenvalues with magnitude lower than 1 (stable &quot;discrete time&quot; eigenspace).
  </P>
  </ITEMIZE>
  <ITEMIZE label='General eigenspace'>
  <P>
    returns an unitary matrix <VERB>U</VERB> which transforms <VERB>A</VERB> into schur form.  In addition, the <VERB>dim</VERB> first columns of <VERB>U</VERB> span a basis of the  eigenspace of <VERB>A</VERB> associated with the eigenvalues which are  selected by the function <VERB>myfunction</VERB>.
  </P>
  <P>
    This function must be of the following type (here <VERB>myfunction</VERB> is &quot;<VERB>rule</VERB>&quot;):
  </P>
  <VERBATIM><![CDATA[
function [flag]=rule(x)

flag=...
   ]]></VERBATIM>
  <P>
    <VERB>x</VERB> is a vector with three components which characterizes either a real eigenvalue or a pair of complex conjugate eigenvalues.
  </P>
  <P>
    If <VERB>x(1)=1</VERB>, a real eigenvalue is considered and this eigenvalue is <VERB>x(2)/x(3)</VERB>.
  </P>
  <P>
    If <VERB>x(1)=2</VERB>, a pair of complex conjugate eigenvalues is considered. The sum of these two eigenvalues (twice the real part) is <VERB>x(2)</VERB> and the product (squared magnitude) is <VERB>x(3)</VERB>.
  </P>
  <P>
    On return, flag should be 1 if the real eigenvalue is  selected or the pair of eigenvalues is selected and 0 otherwise.
  </P>
  </ITEMIZE>
  <ITEMIZE label='Example of function'>
  <VERBATIM><![CDATA[
        function [flag]=disc(x)
        ls =x(1);flag=0;
        select  ls
           case 1 then if abs(x(2)) < ro*abs(x(3)) then flag=1;end
           case 2 then if x(3) < ro*ro then flag=1;end
        end
   ]]></VERBATIM>
  <P>
    The function <VERB>disc</VERB> selects the eigenvalues with magnitude lower than a given scalar <VERB>ro</VERB>. And for <VERB>ro=1</VERB> the calling sequence <VERB>[U,dim]=schur(A,&apos;d&apos;)</VERB> and <VERB>[U,dim]=schur(A,disc)</VERB> are equivalent.
  </P>
  <P>
    Another useful example is <VERB>%choose</VERB>  (see function code in <VERB>SCIDIR/macros/percent</VERB>)
  </P>
  </ITEMIZE>
  <EXAMPLE><![CDATA[
A=diag([-0.9,-2,2,0.9]);X=rand(A);A=inv(X)*A*X;
[U,d]=schur(A,'c');
A1=U'*A*U;
spec(A1(1:d,1:d))      //stable cont. eigenvalues
[U,d]=schur(A,'d');
A1=U'*A*U;
spec(A1(1:d,1:d))      //stable disc. eigenvalues
 ]]></EXAMPLE>
  <SEE_ALSO>
    <SEE_ALSO_ITEM> <LINK>gschur</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>ricc</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>pbig</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>psmall</LINK> </SEE_ALSO_ITEM>
  </SEE_ALSO>
</MAN>
