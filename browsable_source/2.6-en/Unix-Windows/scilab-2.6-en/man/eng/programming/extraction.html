<html>
  <body bgcolor="FFFFFF">
    <CENTER>Scilab Function  </CENTER>
    <P></P>
    <H3>NAME </H3>
    <p>
      <ul>extraction -  matrix and list entry extraction  </ul>
    </p>
    <H3>CALLING SEQUENCE</H3>
    <dl>
      <dd>x(i,j)  </dd>
      <dd>x(i)  </dd>
      <dd>[...]=l(i)  </dd>
      <dd>[...]=l(k1)...(kn)(i) or [...]=l(list(k1,...,kn,i))  </dd>
      <dd>l(k1)...(kn)(i,j)   or l(list(k1,...,kn,list(i,j))  </dd>
    </dl>
    <H3>PARAMETERS</H3>
    <ul>
      <ul>
  <li>
          <tt>
            <b>x  </b>
          </tt>
    : matrix  of any  possible types
  </li>
  <li>
          <tt>
            <b>l  </b>
          </tt>
    : list variable
  </li>
  <li>
          <tt>
            <b>i,j  </b>
          </tt>
    : indices
  </li>
  <li>
          <tt>
            <b>k1,...kn  </b>
          </tt>
    : indices
  </li>
 </ul>
    </ul>
    <H3>DESCRIPTION</H3>
    <ul>
 

  <li>MATRIX CASE 
       and , can be:
  </li>
 

  <li>- 
    real scalars or vectors or matrices with positive elements. 
  </li>
 

  <li>* 
     builds the matrix  such as  for   from 1 to  and  from 1 to .    () Maximum value must be less or equal to  ().
  </li>

  <li>* 
     with  a 1x1 matrix builds the matrix  such as  for   from 1 to  and  from 1 to .   Note that in this case index  is valid only if  all its entries are equal to one.
  </li>

  <li>* 
     with  a row vector builds the row vector  such as  for  from 1 to     Maximum value must be less or equal to .
  </li>

  <li>* 
     with  a matrix with one or more columns builds the column vector  such as  ( from 1 to ) contains the  entry of the column vector formed by the concatenation of the 's columns.    Maximum value must be less or equal to .
  </li>
 
  <p>
  </p>
  <p>
  </p>

  <li>- 
    the  symbol which stands for "all elements". 
  </li>
 

  <li>* 
     builds the matrix  such as  for   from 1 to  and  from 1 to 
  </li>

  <li>* 
     builds the matrix  such as  for   from 1 to  and  from 1 to  .
  </li>

  <li>* 
     builds the column vector  formed by the column concatenations of columns. It is equivalent to .
  </li>
 
  <p>
  </p>
  <p>
  </p>

  <li>- 
    vector of boolean. If an index (  or  )is a vector of booleans it is interpreted as  or respectively   
  </li>

  <li>- 
    a polynomial.  If an index (  or  )is a vector of polynomials or implicit polynomial vector it is interpreted as  or respectively   where  and  are associated  dimensions.  Even if this feature works for all polynomials, it is recommended to use polynomials in  for readability.  
  </li>
 

  <li>LIST OR TLIST CASE 
     If they are present the  give the path to a sub-list entry of  data structure. They allow a recursive extraction without intermediate copies.  The  and  instructions are interpreted as:          And the   and  instructions are  interpreted as:          and , can be:  When path points on more than one list component the instruction must have as many left hand side arguments as selected components. But if the extraction syntax is used within a function input calling sequence each returned list component is added to the function calling sequence.
  </li>
  <p>
    Note that, <tt>
          <b> l(list()</b>
        </tt> is the same as <tt>
          <b> l</b>
        </tt>.
  </p>
 

  <li>- 
    real scalar or vector or matrix with positive elements.     extracts the  elements from the list l and store them in  variables for   from 1 to  
  </li>

  <li>- 
    the  symbol which stands for "all elements". 
  </li>

  <li>- 
    a vector of booleans. If  is a vector of booleans it is interpreted as .
  </li>

  <li>- 
    a polynomial.  If   is a vector of polynomials or implicit polynomial vector it is interpreted as  where .  Even if this feature works for all polynomials, it is recommended to use polynomials in  for readability.  
  </li>
 

  <li>k1,..kn may be : 
    
  </li>
 

  <li>- 
    real positive scalar.  
  </li>

  <li>- 
    a polynomial,interpreted as  where  is the corresponding sub-list size. 
  </li>

  <li>- a character string associated with a sub-list entry name. 
  </li>
 
 
  </ul>
    <H3>REMARKS</H3>
    <ul>
      <p>
    For soft coded matrix types such as rational functions and state space linear systems, <tt>
          <b>x(i)</b>
        </tt> syntax may not be used for vector element extraction due to confusion with list element extraction. <tt>
          <b>x(1,j)</b>
        </tt> or <tt>
          <b>x(i,1)</b>
        </tt> syntax must be used.
  </p>
    </ul>
    <H3>EXAMPLES</H3>
    <ul>
      <pre>
// MATRIX CASE
a=[1 2 3;4 5 6]
a(1,2)
a([1 1],2)
a(:,1)
a(:,3:-1:1)
a(1)
a(6)
a(:)
a([%t %f %f %t])
a([%t %f],[2 3])
a(1:2,$-1)
a($:-1:1,2)
a($)
//
x='test'
x([1 1;1 1;1 1])
//
b=[1/%s,(%s+1)/(%s-1)]
b(1,1)
b(1,$)
b(2) // the numerator
// LIST OR TLIST CASE
l=list(1,'qwerw',%s)
l(1)
[a,b]=l([3 2])
l($)
x=tlist(l(2:3)) //form a tlist with the last 2 components of l
//
dts=list(1,tlist(['x';'a';'b'],10,[2 3]));
dts(2)('a')
dts(2)('b')(1,2)
[a,b]=dts(2)(['a','b'])

 </pre>
    </ul>
    <H3>SEE ALSO</H3>
    <p>
      <ul>
        <a href="find.html">
          <tt>
            <b>find</b>
          </tt>
        </a>
        <a href="../polynomials/horner.html">
          <tt>
            <b>horner</b>
          </tt>
        </a>
        <a href="parents.html">
          <tt>
            <b>parents</b>
          </tt>
        </a>
      </ul>
    </p>
  </body>
</html>