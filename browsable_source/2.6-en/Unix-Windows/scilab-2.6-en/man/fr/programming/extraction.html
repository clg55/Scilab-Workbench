<html>
  <body bgcolor="FFFFFF">
    <CENTER>Scilab Function  </CENTER>
    <P></P>
    <H3>NOM </H3>
    <p>
      <ul>extraction -  extraction à partir d'une matrice ou d'une liste  </ul>
    </p>
    <H3>SEQUENCE D'APPEL</H3>
    <dl>
      <dd>x(i,j)  </dd>
      <dd>x(i)  </dd>
      <dd>[...]=l(i)  </dd>
      <dd>[...]=l(k1)...(kn)(i) ou [...]=l(list(k1,...,kn,i))  </dd>
      <dd>l(k1)...(kn)(i,j)   ou l(list(k1,...,kn,list(i,j))  </dd>
    </dl>
    <H3>PARAMETRES</H3>
    <ul>
      <ul>
  <li>
          <tt>
            <b>x  </b>
          </tt>
    : matrice de tout type
  </li>
  <li>
          <tt>
            <b>l  </b>
          </tt>
    : liste
  </li>
  <li>
          <tt>
            <b>i,j  </b>
          </tt>
    : indices
  </li>
  <li>
          <tt>
            <b>k1,...kn  </b>
          </tt>
    : indices à valeurs entières
  </li>
 </ul>
    </ul>
    <H3>DESCRIPTION</H3>
    <ul>
 

  <li>CAS DES MATRICES 
       et  peuvent être :
  </li>
 

  <li>- 
    des scalaires, vecteurs ou matrices à éléments positifs. 
  </li>
 

  <li>* 
     construit la matrice  telle que  pour  variant de 1 à  et  variant de 1 à .   La valeur maximale de  (resp. ) doit être inférieure ou égale à  (resp. ).
  </li>

  <li>* 
     où  est une matrice 1 x 1, construit la matrice  telle que  pour  variant de 1 à  et  variant de 1 à .   Noter que dans ce cas l'indice  est valable si toutes ses composantes sont égales à 1.
  </li>

  <li>* 
     avec  un vecteur ligne, construit le vecteur ligne  tel que  pour  entre 1 et   La valeur maximale de  doit être inférieure ou égale à .
  </li>

  <li>* 
     avec  une matrice à une ou plusieurs colonnes, construit la matrice   telle que  ( variant de 1 à ) contient le terme numéro  du vecteur colonne issu de la concaténation des colonnes de .  La valeur maximale de  doit être inférieure ou égale à .
  </li>
 
  <p>
  </p>
  <p>
  </p>

  <li>- 
    Le symbole  signifiant "tous les éléments". 
  </li>
 

  <li>* 
     construit la matrice  telle que  pour  variant de 1 à  et  variant de 1 à 
  </li>

  <li>* 
     construit la matrice  telle que  pour  variant de 1 à  et  variant de 1 à .
  </li>

  <li>* 
     construit le vecteur colonne  obtenu par concaténation des colonnes  de .  Cette commande est équivalente à .
  </li>
 
  <p>
  </p>
  <p>
  </p>

  <li>- 
    vecteur de booléens. Si un indice (  ou  ) est un vecteur de booléen il est interprété comme  ou , respectivement. 
  </li>

  <li>- 
    un polynôme. Si un indice (  ou  ) est un vecteur de polynômes ou de polynômes implicites il est interprété comme  ou , respectivement, où  et  sont les dimensions de  associées.  Même si cette fonctionnalité marche pour tous les polynômes, il est recommandé d'utiliser des polynômes dans   par souci de lisibilité.  
  </li>
 

  <li> 
    CAS DES LISTES (types LIST et TLIST)  S'ils sont présents les  donnent le chemin vers un terme d'une sous-liste de la liste . Ils permettent de faire une extraction récursive directe sans utiliser de variable intermédiaire.  Les instructions  et  sont interprétées comme :          De même, les instructions  et  sont interprétées comme :          et , peuvent valoir :  Quand le chemin désigne plusieurs termes d'une liste l'instruction doit avoir autant de termes dans la liste des arguments du membre de gauche que le nombre de termes sélectionnés. Mais si la syntaxe d'extraction est utilisée dans les arguments d'entrée d'une fonction,  chaque terme renvoyé est ajouté aux arguments d'entrée.
  </li>
  <p>
    Notez que <tt>
          <b> l(list()</b>
        </tt> est identique à <tt>
          <b>l</b>
        </tt>.
  </p>
 

  <li>- 
    scalaire, vecteur ou matrice à termes positifs     extrait les termes  de la liste l et les stocke dans les variables  pour  variant de 1 à  
  </li>

  <li>- 
    le symbole  ("tous les éléments") 
  </li>

  <li>- 
    vecteur de booléens. Si   est un vecteur de booléens, il est interprété comme . 
  </li>

  <li>- 
    un polynôme. Si  est un vecteur de polynômes ou de polynômes implicites il est interprété comme  où .  Même si cette fonctionnalité marche pour tous les polynômes, il est recommandé d'utiliser des polynômes dans   par souci de lisibilité. 
  </li>
 

  <li>k1,..kn peuvent être : 
    
  </li>
 

  <li>- 
    un nombre réel positif  
  </li>

  <li>- 
    un polynôme, interprété comme  ou  est la taille de la sous-liste correspondante. 
  </li>

  <li>- une chaîne de caractères associée à un nom d'entrée de sous-liste 
  </li>
 
 
  </ul>
    <H3>REMARQUES</H3>
    <ul>
      <p>
    Pour les matrices rationnelles et les systèmes dynamiques linéaires stockés sous forme de représentation d'état, la syntaxe <tt>
          <b>x(i)</b>
        </tt> ne doit pas être utilisée pour l'extraction des éléments d'un vecteur, à cause de la confusion possible avec l'extraction des éléments de liste. La syntaxe <tt>
          <b>x(1,j)</b>
        </tt> où <tt>
          <b>x(i,1)</b>
        </tt> doit être utilisée dans ce cas.
  </p>
    </ul>
    <H3>EXEMPLES</H3>
    <ul>
      <pre>
// CAS DES MATRICES
a=[1 2 3;4 5 6]
a(1,2)
a([1 1],2)
a(:,1)
a(:,3:-1:1)
a(1)
a(6)
a(:)
a([%t %f %f %t])
a([%t %f],[2 3])
a(1:2,$-1)
a($:-1:1,2)
a($)
//
x='test'
x([1 1;1 1;1 1])
//
b=[1/%s,(%s+1)/(%s-1)]
b(1,1)
b(1,$)
b(2) // le numérateur
// CAS des LISTES (types LIST et TLIST)
l=list(1,'qwerw',%s)
l(1)
[a,b]=l([3 2])
l($)
x=tlist(l(2:3)) // construction d'une TLIST avec les deux derniers termes de l
//
dts=list(1,tlist(['x';'a';'b'],10,[2 3]));
dts(2)('a')
dts(2)('b')(1,2)
[a,b]=dts(2)(['a','b'])

 </pre>
    </ul>
    <H3>VOIR AUSSI</H3>
    <p>
      <ul>
        <a href="find.html">
          <tt>
            <b>find</b>
          </tt>
        </a>
        <a href="../polynomials/horner.html">
          <tt>
            <b>horner</b>
          </tt>
        </a>
        <a href="parents.html">
          <tt>
            <b>parents</b>
          </tt>
        </a>
      </ul>
    </p>
  </body>
</html>