<html>
  <body bgcolor="FFFFFF">
    <CENTER>Scilab Function  </CENTER>
    <P></P>
    <H3>NOM </H3>
    <p>
      <ul>grand -  générateur de nombres aléatoires  </ul>
    </p>
    <H3>SEQUENCE D'APPEL</H3>
    <dl>
      <dd>Y=grand(m,n,'option' [,arg1,..,argn])  </dd>
      <dd>Y=grand(x,'option' [,arg1,....,argn])  </dd>
      <dd>Y=grand('option')  </dd>
      <dd>Y=grand('option'  [,arg1,....,argn])  </dd>
    </dl>
    <H3>PARAMETRES</H3>
    <ul>
      <ul>
  <li>
          <tt>
            <b>grand('advnst',K)  </b>
          </tt>
    : Avance l'état du générateur de 2^K valeurs et réinitialise la graine à cette valeur. 
  </li>
  <li>
          <tt>
            <b>Y=grand(m,n,'bet',A,B), Y=grand(x,'bet',A,B)  </b>
          </tt>
    : Génère des réalisations suivant une distribution beta de  paramètres A et B. La densité est définie par  <tt>
            <b>x^(a-1) * (1-x)^(b-1) / B(a,b)</b>
          </tt> pour <tt>
            <b>0 &lt; x &lt; 1</b>
          </tt>  Méthode : R. C. H. Cheng  Generating Beta Variables with Nonintegral Shape Parameters  Communications of the ACM, 21:317-322 (1978)  (Algorithmes BB et BC)
  </li>
  <li>
          <tt>
            <b>Y=grand(m,n,'bin',N,P), Y=grand(x,'bin',N,P)  </b>
          </tt>
    : Génère des réalisations suivant une distribution binomiale dont le nombre d'essais est N et dont la probabilité de l'évènement est P (0.0 &lt;= P &lt;= 1.0).  Méthode :  algorithme BTPE de :  Kachitvichyanukul, V. and Schmeiser, B. W. Binomial Random Variate Generation. Communications of the ACM, 31, 2  (February, 1988) 216. 
  </li>
  <li>
          <tt>
            <b>Y=grand(m,n,'chi',Df), Y=grand(x,'chi',Df)  </b>
          </tt>
    : Génère des réalisations suivant une distribution du chi deux  à DF degrés de liberté.  Utilise la relation entre le chi deux et la distribution gamma.
  </li>
  <li>
          <tt>
            <b>Y=grand(m,n,'def'), Y=grand(x,'def')  </b>
          </tt>
    : Renvoie des réalisations d'une variable aléatoire uniforme sur ]0,1[ en utilisant le générateur courant
  </li>
  <li>
          <tt>
            <b>Y=grand(m,n,'exp',Av), Y=grand(x,'exp',Av)  </b>
          </tt>
    : Génère des réalisations suivant une distribution exponentielle  de moyenne AV.  Pour les détails voir :   Ahrens, J.H. and Dieter, U.  Computer Methods for Sampling From the   Exponential and Normal Distributions.  Comm. ACM, 15,10 (Oct. 1972), 873 - 882. 
  </li>
  <li>
          <tt>
            <b>Y=grand(m,n,'f',Dfn,Dfd), Y=grand(x,'f',Dfn,Dfd)  </b>
          </tt>
    : Génère des réalisations suivant la distribution de Fisher (rapport de variances)  à DFN degrés de liberté au numérateur et DFD degrés de liberté au dénominateur. Méthode : génère directement un rapport de variances de chi deux
  </li>
  <li>
          <tt>
            <b>Y=grand(m,n,'gam',Shape,Scale), Y=grand(x,'gam',Shape,Scale)  </b>
          </tt>
    : Génère des réalisations suivant la distribution gamma dont la densité est (Scale**Shape)/Gamma(Shape) * X**(Shape-1) * Exp(-Scale*X) Pour les détails voir :
  </li>
 <ul>
  <li>
            <tt>
              <b>(Cas R &gt;= 1.0)  </b>
            </tt>
    : Ahrens, J.H. and Dieter, U.  Generating Gamma Variates by a   Modified Rejection Technique.   Comm. ACM, 25,1 (Jan. 1982), 47 - 54.  Algorithme GD
  </li>
  <li>
            <tt>
              <b>(Cas 0.0 &lt; R &lt; 1.0)  </b>
            </tt>
    : Ahrens, J.H. and Dieter, U.  Computer Methods for Sampling from Gamma,   Beta, Poisson and Binomial Distributions.   Computing, 12 (1974), 223-246/   Algorithme adapté GS.
  </li>
 </ul>
  <li>
          <tt>
            <b>G=grand('getcgn')  </b>
          </tt>
    : renvoie dans G le numéro du générateur aléatoire courant (1..32) 
  </li>
  <li>
          <tt>
            <b>Sd=grand('getsd')  </b>
          </tt>
    : Renvoie la valeur de deux graines entières du générateur aléatoire courant Sd=[sd1,sd2]
  </li>
  <li>
          <tt>
            <b>grand('initgn',I)  </b>
          </tt>
    : Réinitialise le générateur courant 
  </li>
 <ul>
  <li>
            <tt>
              <b>I = -1  </b>
            </tt>
    : l'état prend la valeur de la graine initiale 
  </li>
  <li>
            <tt>
              <b>I = 0  </b>
            </tt>
    : l'état prend la valeur de la graine précédente
  </li>
  <li>
            <tt>
              <b>I = 1  </b>
            </tt>
    : l'état prend la valeur d'une nouvelle graine distante de 2^w valeurs de la dernière graine 
  </li>
 </ul>
  <li>
          <tt>
            <b>Y=grand(m,n,'lgi'),Y=grand(x,'lgi')  </b>
          </tt>
    : renvoie des entiers aléatoires suivant une distribution uniforme sur  (1, 2147483562) en utilisant le générateur courant.  
  </li>
  <li>
          <tt>
            <b>Y=grand(M,'mn',Mean,Cov)  </b>
          </tt>
    : Génère M réalisations d'une loi multi-normale. Mean est une matrice Nx1 et Cov une matrice NxN définie positive. Y est une matrice NxM. 
  </li>
  <li>
          <tt>
            <b>Y=grand(n,'markov',P,x0)  </b>
          </tt>
    Génère <tt>
            <b>n</b>
          </tt> états successifs d'une chaîne de Markov décrite par  la matrice de transition <tt>
            <b>P</b>
          </tt>. L'état initial est donné par <tt>
            <b>x0</b>
          </tt>. Si <tt>
            <b>x0</b>
          </tt> est une matrice de taille <tt>
            <b>m=size(x0,'*')</b>
          </tt> alors <tt>
            <b>Y</b>
          </tt> est une matrice de taille <tt>
            <b>m*n</b>
          </tt>. <tt>
            <b>Y(i,:)</b>
          </tt> est le chemin  obtenu à partir de l'état initial <tt>
            <b>x0(i)</b>
          </tt>.
  </li>
  <li>
          <tt>
            <b>Y=grand(M,'mul',N,P)  </b>
          </tt>
    Génère M réalisations suivant une distribution Multinomiale.  N est le nombre de catégories, P est le vecteur des probabilités. P(i) est la probabilité que l'évènement soit classé dans la catégorie i. Ainsi, P(i) doit être dans [0,1]. P est de taille N-1, la probabilité de la catégorie N est 1-sum(P). Y(:,i) est une observation de la distribution multinomiale. Les Y(:,i) sont positifs et leur somme vaut N. Y est de taille NxM.  Algorithme page 559 de Devroye, Luc. Non-Uniform Random Variate Generation. Springer-Verlag, New York, 1986.
  </li>
  <li>
          <tt>
            <b>Y=grand(m,n,'nbn',N,P),Y=grand(x,'nbn',N,P)  </b>
          </tt>
    : Génère des réalisations suivant une distribution binomiale négative.  N est le nombre requis d'évènements (N &gt; 0).  P est la probabilité d'un évènement durant un essai de Bernoulli (0.0 &lt; P &lt; 1.0).  Méthode : Algorithme page 480 de Devroye, Luc. Non-Uniform Random Variate Generation. Springer-Verlag, New York, 1986.
  </li>
  <li>
          <tt>
            <b>Y=grand(m,n,'nch',Df,Xnon), Y=grand(x,'nch',Df,Xnon)  </b>
          </tt>
    : Génère des réalisations suivant une distribution du chi deux non centré  à DF (DF &gt;= 1.0) degrés de liberté et un paramètre de décentrage XNONC  (XNONC &gt;= 0.0).   Utilise le fait qu'un chi deux non centré est la somme d'un chi deux  à DF-1 degrés de liberté plus le carré d'une réalisation suivant une loi normale de moyenne XNON et de variance 1. 
  </li>
  <li>
          <tt>
            <b>Y=grand(m,n,'nf',Dfn,Dfd,Xnon), Y=grand(x,'nf',Dfn,Dfd,Xnon)  </b>
          </tt>
    : Génère des réalisations de la distribution de Fisher  (rapport de variances)  à DFN (doit être &gt;= 1.0) degrés de liberté au numérateur, et DFD (doit être &gt; 0)  degrés de liberté au dénominateur, et un paramètre de décentrage XNONC (doit être &gt;= 0).   Méthode : génération directe du rapport d'une réalisation de chi-deux non centré et d'une réalisation  d'un chi-deux centré. 
  </li>
  <li>
          <tt>
            <b>Y=grand(m,n,'nor',Av,Sd), Y=grand(x,'nor',Av,Sd)  </b>
          </tt>
    : Génère des réalisations suivant une loi normale  de moyenne AV et d'écart-type SD. Pour les détails voir :  Ahrens, J.H. and Dieter, U. Extensions of Forsythe's Method for Random Sampling from the Normal Distribution. Math. Comput., 27,124 (Oct. 1973), 927 - 937. 
  </li>
  <li>
          <tt>
            <b>Sd=grand('phr2sd','string')  </b>
          </tt>
    : Utilise une phrase (chaîne de caractères) pour générer deux graines pour le générateur aléatoire RGN. Sd est un vecteur d'entiers de taille 2 <tt>
            <b>Sd=[Sd1,Sd2]</b>
          </tt>
  </li>
  <li>
          <tt>
            <b>Y=grand(m,n,'poi',mu), Y=grand(x,'poi',mu)  </b>
          </tt>
    : Génère des réalisations suivant une distribution de Poisson de moyenne MU (MU &gt;= 0).   Pour les détails voir :  Ahrens, J.H. and Dieter, U.  Computer Generation of Poisson Deviates   From Modified Normal Distributions.   ACM Trans. Math. Software, 8, 2   (June 1982),163-179 
  </li>
  <li>
          <tt>
            <b>Mat=grand(M,'prm',vect)  </b>
          </tt>
    : Génère M permutation aléatoires du vecteur colonne <tt>
            <b>vect</b>
          </tt>. Mat est de taille <tt>
            <b>(size(vect)xM)</b>
          </tt>
  </li>
  <li>
          <tt>
            <b>grand('setall',ISEED1,ISEED2)  </b>
          </tt>
    : Donne à la graine du générateur 1 les valeurs ISEED1 et ISEED2. Les graines des autres générateurs sont affectés également, et les états des générateurs prennent la valeur de cette graine. 
  </li>
  <li>
          <tt>
            <b>grand('setcgn',G)  </b>
          </tt>
    : Choisit le générateur courant de numéro G. Toutes les références à un générateur concernent le générateur courant. 
  </li>
  <li>
          <tt>
            <b>grand('setsd',ISEED1,ISEED2)  </b>
          </tt>
    : Donne à la graine du générateur g les valeurs ISEED1 et ISEED2. Les graines et états des autres générateurs sont inchangées.
  </li>
  <li>
          <tt>
            <b>Y=grand(m,n,'uin',Low,High), Y=grand(x,'uin',Low,High)  </b>
          </tt>
    : Génère des entiers uniformément distribués entre LOW et HIGH.  Low est la borne inférieure (inclusive). High est la borne supérieure (inclusive). Si (HIGH-LOW) &gt; 2,147,483,561 un message d'erreur est affiché. 
  </li>
  <li>
          <tt>
            <b>Y=grand(m,n,'unf',Low,High),Y=grand(x,'unf',Low,High)  </b>
          </tt>
    :  Génère des entiers uniformément distribués entre LOW et HIGH. Ici les deux bornes sont exclusives.
  </li>
 </ul>
    </ul>
    <H3>DESCRIPTION</H3>
    <ul>
  <p>
    Interface vers une librairie Fortran de génération de nombres aléatoires.
    (Barry W. Brown and James Lovato, Department of Biomathematics,
    the University of Texas, Houston) 
  </p>
  <p>
    Cet ensemble de fonctions contient 32 générateurs de nombres aléatoires.
    Chaque générateur peut fournir 1,048,576 blocs de nombres, et chaque bloc
    est de longueur 1,073,741,824.  Chaque générateur peut être positionné au début ou à la fin
    du bloc courant ou à sa valeur de départ. Les méthodes proviennent de l'article cité ci-dessous :
  </p>
  <p>
    P.  L'Ecuyer and S. Cote.   Implementing a Random  Number Package with
    Splitting Facilities.  ACM Transactions on Mathematical Software 17:1,
    pp 98-111.
  </p>
  <p>
    La plupart des utilisateur préfèrera un générateur plus simple (proposé par défaut).
    On a donc ajouté la notion de générateur courant (initialement numéro 1). Il peut être changé avec 'setcgn'
    et le numéro du générateur courant est obtenue avec 'getcgn'.
  </p>
  <p>
    Les deux graines entières peuvent être changées avec 'setall' (valeurs par défaut
    1234567890  et 123456789). Les valeurs des graines sont obtenues avec 'getsd'.  Les nombres aléatoires peuvent être obtenus sous forme d'entiers compris entre 1 et un entier très grand en utilisant l'option 'lgi' ou comme des nombres à virgule flottante entre 0 et 1 (option 'def').
  </p>
  <p>
  </p>
  </ul>
    <H3>CONCEPTS</H3>
    <ul>
      <p>
    Les méthodes utilisées permettent de générer des séquences de très longue période :  2.3 X 10^18. Cette séquence est partitionnée en G (=32) générateurs virtuels. Chaque générateur virtuel contient 2^20 (=1,048,576) blocs de nombres aléatoires. Chaque bloc est de longueur 2^30 (=1,073,741,824).  L'état d'un générateur aléatoire est déterminé par deux entiers appelés graines. Les graines peuvent être initialisées par l'utilisateur. La valeur initiale de la première est comprise entre 1 et 2,147,483,562, celle de la deuxième entre 1 et 2,147,483,398.   À chaque fois qu'un nombre est généré, les valeurs des graines changent. Le générateur "se souvient" de trois valeurs de graines : la valeur d'initialisation, la valeur au début du bloc courant, et la valeur au début du bloc suivant. La graine d'un générateur aléatoire peut être initialisée avec l'une des ces trois valeurs.  Parmi les 32 générateurs virtuels, exactement un sera le générateur courant,  i.e., celui qui sera utilisé pour générer les valeurs 'lgi' et 'def'. Initialement, le générateur courant est choisit comme étant le numéro 1. Le générateur courant peut être changé en appelant 'setcgn', et le numéro du générateur courant est obtenu avec 'getcgn'.
  </p>
    </ul>
  </body>
</html>