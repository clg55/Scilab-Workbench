<html>
  <body bgcolor="FFFFFF">
    <CENTER>Scilab Function  </CENTER>
    <P></P>
    <H3>NOM </H3>
    <p>
      <ul>optim -  routine d'optimisation non-linéaire  </ul>
    </p>
    <H3>SEQUENCE D'APPEL</H3>
    <dl>
      <dd>[f,xopt]=optim(costf,x0)  </dd>
      <dd>[f,[xopt,[gradopt,[work]]]]=optim(costf,[contr],x0,['algo'],[df0,[mem]],  </dd>
      <dd>     [work],[stop],['in'],[imp=iflag])  </dd>
    </dl>
    <H3>PARAMETRES</H3>
    <ul>
      <ul>
  <li>
          <tt>
            <b>costf  </b>
          </tt>
    : fonction externe (fonction Scilab ou chaîne de caractères).
  </li>
  <li>
          <tt>
            <b>x0  </b>
          </tt>
    : vecteur (vecteur initial).
  </li>
  <li>
          <tt>
            <b>f  </b>
          </tt>
    : valeur du coût optimal (<tt>
            <b>f=costf(xopt)</b>
          </tt>)
  </li>
  <li>
          <tt>
            <b>xopt  </b>
          </tt>
    : vecteur optimal <tt>
            <b>x</b>
          </tt> trouvé.
  </li>
  <li>
          <tt>
            <b>contr  </b>
          </tt>
    : <tt>
            <b>'b',binf,bsup</b>
          </tt> avec <tt>
            <b>binf</b>
          </tt> et <tt>
            <b>bsup</b>
          </tt> deux vecteurs réels de même dimension que <tt>
            <b>x0</b>
          </tt>. <tt>
            <b>binf</b>
          </tt> et <tt>
            <b>bsup</b>
          </tt> sont les bornes inf. et sup. sur <tt>
            <b>x</b>
          </tt>.
  </li>
  <li>
          <tt>
            <b>"algo"  </b>
          </tt>
    : <tt>
            <b>'qn'</b>
          </tt> ou <tt>
            <b>'gc'</b>
          </tt> ou <tt>
            <b>'nd'</b>
          </tt> (Quasi-Newton (BFGS), Gradient Conjugué ou  Non Différentiable).  (Noter que <tt>
            <b>'nd'</b>
          </tt> n'accepte pas les bornes sur <tt>
            <b>x</b>
          </tt> ).
  </li>
  <li>
          <tt>
            <b>df0  </b>
          </tt>
    : scalaire. Décroissance estimée de <tt>
            <b>f</b>
          </tt> à la première itération. (<tt>
            <b>df0=1</b>
          </tt> est la valeur par défaut).
  </li>
  <li>
          <tt>
            <b>mem :  </b>
          </tt>
     entier, nombre de variables utilisées pour l'approximation du Hessien, (<tt>
            <b>algo='gc' ou 'nd'</b>
          </tt>) (6 par défaut).
  </li>
  <li>
          <tt>
            <b>stop  </b>
          </tt>
    : paramètres optionnels contrôlant la convergence de l'algorithme  <tt>
            <b>             stop=  'ar',nap, [iter [,epsg [,epsf [,epsx]]]]</b>
          </tt>
  </li>
 <ul>
  <li>
            <tt>
              <b>"ar"  </b>
            </tt>
    : mot-clé réservé ayant la signification suivante
  </li>
  <li>
            <tt>
              <b>nap  </b>
            </tt>
    : nombre d'appels maximum à <tt>
              <b>costf</b>
            </tt>
  </li>
  <li>
            <tt>
              <b>iter  </b>
            </tt>
    : nombre maximum d'itérations
  </li>
  <li>
            <tt>
              <b>epsg  </b>
            </tt>
    : seuil sur la norme du gradient
  </li>
  <li>
            <tt>
              <b>epsf  </b>
            </tt>
    : seuil sur la décroissance de <tt>
              <b>f</b>
            </tt>
  </li>
  <li>
            <tt>
              <b>epsx  </b>
            </tt>
    : seuil sur la variation de <tt>
              <b>x</b>
            </tt>. Ce vecteur (ou matrice) de même taille que <tt>
              <b>x0</b>
            </tt> peut être utilisé pour mettre <tt>
              <b>x</b>
            </tt> à l'échelle.
  </li>
 </ul>
  <li>
          <tt>
            <b>"in"  </b>
          </tt>
    : réservé pour l'initialisation des paramètres quand <tt>
            <b>costf</b>
          </tt> est une routine Fortran ou C (voir ci-dessous)
  </li>
  <li>
          <tt>
            <b>"imp=iflag"  </b>
          </tt>
    : argument nommé pour choisir le mode d'interaction. Avec <tt>
            <b>iflag=0</b>
          </tt> rien (à part les erreurs) n'est affiché, avec <tt>
            <b>iflag=1</b>
          </tt> un rapport initial et final, <tt>
            <b>iflag=2</b>
          </tt> donne un rapport à chaque itération, <tt>
            <b>iflag&gt;2</b>
          </tt> donne en plus un rapport sur la recherche linéaire. Attention : ces rapports s'affichent dans la sortie standard de Scilab.
  </li>
  <li>
          <tt>
            <b>gradopt  </b>
          </tt>
    :  gradient de <tt>
            <b>costf</b>
          </tt> en <tt>
            <b>xopt</b>
          </tt>
  </li>
  <li>
          <tt>
            <b>work  </b>
          </tt>
    : tableau de travail pour le redémarrage à chaud de quasi-Newton. Il peut être utilisé en entrée de optim pour accélérer l'algorithme.
  </li>
 </ul>
    </ul>
    <H3>DESCRIPTION</H3>
    <ul>
  <p>
    Routine d'optimisation non-linéaire pour problèmes non linéaires sans contrainte ou avec contraintes de bornes. 
  </p>
  <pre>
min costf(x) w.r.t x.
   </pre>
  <p>
    <tt>
          <b>costf</b>
        </tt> est une fonction, une liste ou un nom de routine Fortran ou C (voir "external").
    Cette fonction doit renvoyer <tt>
          <b>f</b>
        </tt> (<tt>
          <b>costf(x)</b>
        </tt>) et <tt>
          <b>g</b>
        </tt> (le gradient de <tt>
          <b>costf</b>
        </tt>)
    pour un <tt>
          <b>x</b>
        </tt> donné.
  </p>
  <p>
    Si <tt>
          <b>costf</b>
        </tt> est une fonction Scilab, la séquence d'appel de <tt>
          <b>costf</b>
        </tt> doit être :
  </p>
  <pre>
[f,g,ind]=costf(x,ind).
   </pre>
  <p>
    Ici, <tt>
          <b>costf</b>
        </tt> est une fonction renvoyant <tt>
          <b>f</b>
        </tt>, la valeur (réelle) de
    la fonction coût en <tt>
          <b>x</b>
        </tt>, et <tt>
          <b>g</b>
        </tt>, le gradient de la fonction coût en <tt>
          <b>x</b>
        </tt>.
    La variable <tt>
          <b>ind</b>
        </tt> est utilisée par <tt>
          <b>optim</b>
        </tt> et son usage est décrit ci-dessous :
  </p>
  <p>
    Si <tt>
          <b>ind=2</b>
        </tt> (resp. <tt>
          <b>3, 4</b>
        </tt>), <tt>
          <b>costf</b>
        </tt> doit renvoyer <tt>
          <b>f</b>
        </tt> (resp. <tt>
          <b>g, f</b>
        </tt> et <tt>
          <b>g</b>
        </tt>).
  </p>
  <p>
    Si <tt>
          <b>ind=1</b>
        </tt> rien n'est à calculer (utilisé par l'affichage uniquement).
  </p>
  <p>
    En sortie, <tt>
          <b>ind&lt;0</b>
        </tt>  signifie que <tt>
          <b>f</b>
        </tt> ne peut pas être calculée en <tt>
          <b>x</b>
        </tt> et
    <tt>
          <b>ind=0</b>
        </tt> interrompt l'optimisation.
  </p>
  <p>
    Si <tt>
          <b>f</b>
        </tt> est une chaîne de caractères, elle désigne le nom d'une subroutine Fortran
    ou C qui doit être liée dynamiquement à Scilab (exemples dans les routines <tt>
          <b>foptim.f</b>
        </tt> 
    et <tt>
          <b>genros.f</b>
        </tt> dans le répertoire SCIDIR/default)
  </p>
  <p>
    Dans ce cas, la séquence d'appel est :
    <tt>
          <b>function costf(ind,n,x,f,g,ti,tr,td)</b>
        </tt>
  </p>
  <p>
    <tt>
          <b>ind</b>
        </tt> a la même signification que ci-dessus <tt>
          <b>0,1,2</b>
        </tt> mais les valeurs <tt>
          <b>ind=10</b>
        </tt> et <tt>
          <b>ind=11</b>
        </tt> sont aussi valides. 
    Ces valeurs sont utilisées pour les initialisations (voir ci-dessous).
  </p>
  <p>
    <tt>
          <b>n</b>
        </tt> est la dimension de <tt>
          <b>x</b>
        </tt>, <tt>
          <b>x</b>
        </tt> est un <tt>
          <b>n</b>
        </tt>-vecteur 
    <tt>
          <b>ti,tr,td</b>
        </tt> sont des tableaux de travail.
  </p>
  <p>
    La fonction Fortran <tt>
          <b>costf</b>
        </tt> doit renvoyer <tt>
          <b>f</b>
        </tt> et le vecteur <tt>
          <b>g</b>
        </tt>,
    pour <tt>
          <b>x, ind, n, ti, tr, td</b>
        </tt> donnés.
  </p>
  <p>
    Si <tt>
          <b>costf</b>
        </tt> est une routine Fortran il est possible de lui passer des variables Scilab. 
  </p>
  <p>
    Cette fonctionnalité utilise le paramètre <tt>
          <b>'in'</b>
        </tt>.
  </p>
  <p>
    Si la chaîne de caractères <tt>
          <b>'in'</b>
        </tt> est présente, l'initialisation est faite par la routine Fortran :
    <tt>
          <b>optim</b>
        </tt> fait deux appels à <tt>
          <b>costf</b>
        </tt>, l'un avec
    <tt>
          <b>ind=10</b>
        </tt> et l'autre avec <tt>
          <b>ind=11</b>
        </tt>. Dans ce cas, pour <tt>
          <b>ind=10</b>
        </tt>,
    <tt>
          <b>costf</b>
        </tt> doit donner les dimensions <tt>
          <b>nti, ntr, ntd</b>
        </tt> de <tt>
          <b>ti, tr, td</b>
        </tt> 
    dans le <tt>
          <b>common/nird/nti, ntr, ntd</b>
        </tt> et, pour <tt>
          <b>ind=11</b>
        </tt>, <tt>
          <b>costf</b>
        </tt>
    doit initialiser les vecteurs <tt>
          <b>ti , tr, td</b>
        </tt> (vecteur entier, vecteur réel,
    vecteur double précision, respectivement).
  </p>
  <p>
    Dans la séquence d'appel de <tt>
          <b>optim</b>
        </tt>, la chaîne <tt>
          <b>'in'</b>
        </tt> peut être remplacée par <tt>
          <b>'ti', valti ,'td' , valtd</b>
        </tt>. Dans ce cas la fonction Fortran
    <tt>
          <b>costf(ind, x, f, g, ti, tr, td)</b>
        </tt> est évaluée avec <tt>
          <b>ti=valti</b>
        </tt>
    et <tt>
          <b>td=valtd</b>
        </tt> quelque soit la valeur de <tt>
          <b>ind</b>
        </tt>.
    Ainsi, les variables Scilab  <tt>
          <b>valti</b>
        </tt> et <tt>
          <b>valtd</b>
        </tt> (vecteur entier et
    vecteur réel) sont envoyés à la fonction <tt>
          <b>costf</b>
        </tt>.
  </p>
  <p>
    Il est aussi  possible de sauver le contenu des tableaux de travail
    <tt>
          <b>ti</b>
        </tt> et <tt>
          <b>td</b>
        </tt> en ajoutant les chaînes 'si' et/ou 'sd'
    à la fin de la séquence d'appel de <tt>
          <b>optim</b>
        </tt>.
    Dans ce cas les variables de sortie sont : <tt>
          <b>[f,[x,[g],[to]]],[ti],[td]]</b>
        </tt>.
  </p>
  </ul>
    <H3>EXEMPLES</H3>
    <ul>
      <pre>
xref=[1;2;3];x0=[1;-1;1]
deff('[f,g,ind]=cost(x,ind)','f=0.5*norm(x-xref)^2,g=x-xref');
[f,xopt]=optim(cost,x0)      // appel simple
[f,xopt,gopt]=optim(cost,x0,'gc')  // avec un gradient conjugué
[f,xopt,gopt]=optim(cost,x0,'nd')  // f vue comme fonction non-différentiable
[f,xopt,gopt]=optim(cost,'b',[-1;0;2],[0.5;1;4],x0) //  Bornes sur X
[f,xopt,gopt]=optim(cost,'b',[-1;0;2],[0.5;1;4],x0,'gc') //
[f,xopt,gopt]=optim(cost,'b',[-1;0;2],[0.5;1;4],x0,'gc','ar',3)
// 
// Appel à la subroutine "genros" dans SCIDIR/default/Ex-optim.f
// Voir la fonction "link" pour le lien dynamique
[f,xopt,gopt]=optim('genros',[1;2;3])    // Fonction de Rosenbrock
 </pre>
    </ul>
    <H3>VOIR AUSSI</H3>
    <p>
      <ul>
        <a href="../programming/external.html">
          <tt>
            <b>external</b>
          </tt>
        </a>
        <a href="quapro.html">
          <tt>
            <b>quapro</b>
          </tt>
        </a>
        <a href="../elementary/mps2linpro.html">
          <tt>
            <b>linpro</b>
          </tt>
        </a>
        <a href="datafit.html">
          <tt>
            <b>datafit</b>
          </tt>
        </a>
        <a href="leastsq.html">
          <tt>
            <b>leastsq</b>
          </tt>
        </a>
      </ul>
    </p>
  </body>
</html>