<?xml version="1.0" encoding="ISO-8859-1" standalone="no"?> 
<!DOCTYPE MAN SYSTEM "../../man.dtd">
<MAN>
  <LANGUAGE>fr</LANGUAGE>
  <TITLE>optim  </TITLE>
  <TYPE>Scilab Function  </TYPE>
  <DATE>April 1993  </DATE>
  <SHORT_DESCRIPTION name="optim"> routine d&apos;optimisation non-linéaire  </SHORT_DESCRIPTION>
  <CALLING_SEQUENCE>
  <CALLING_SEQUENCE_ITEM>[f,xopt]=optim(costf,x0)  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>[f,[xopt,[gradopt,[work]]]]=optim(costf,[contr],x0,[&apos;algo&apos;],[df0,[mem]],  </CALLING_SEQUENCE_ITEM>
  <CALLING_SEQUENCE_ITEM>     [work],[stop],[&apos;in&apos;],[imp=iflag])  </CALLING_SEQUENCE_ITEM>
  </CALLING_SEQUENCE>
  <PARAM>
 <PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>costf  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : fonction externe (fonction Scilab ou chaîne de caractères).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>x0  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : vecteur (vecteur initial).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>f  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : valeur du coût optimal (<VERB>f=costf(xopt)</VERB>)
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>xopt  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : vecteur optimal <VERB>x</VERB> trouvé.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>contr  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : <VERB>&apos;b&apos;,binf,bsup</VERB> avec <VERB>binf</VERB> et <VERB>bsup</VERB> deux vecteurs réels de même dimension que <VERB>x0</VERB>. <VERB>binf</VERB> et <VERB>bsup</VERB> sont les bornes inf. et sup. sur <VERB>x</VERB>.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>&quot;algo&quot;  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : <VERB>&apos;qn&apos;</VERB> ou <VERB>&apos;gc&apos;</VERB> ou <VERB>&apos;nd&apos;</VERB> (Quasi-Newton (BFGS), Gradient Conjugué ou  Non Différentiable).  (Noter que <VERB>&apos;nd&apos;</VERB> n&apos;accepte pas les bornes sur <VERB>x</VERB> ).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>df0  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : scalaire. Décroissance estimée de <VERB>f</VERB> à la première itération. (<VERB>df0=1</VERB> est la valeur par défaut).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>mem :  </PARAM_NAME>
  <PARAM_DESCRIPTION>
     entier, nombre de variables utilisées pour l&apos;approximation du Hessien, (<VERB>algo=&apos;gc&apos; ou &apos;nd&apos;</VERB>) (6 par défaut).
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>stop  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : paramètres optionnels contrôlant la convergence de l&apos;algorithme  <VERB>             stop=  &apos;ar&apos;,nap, [iter [,epsg [,epsf [,epsx]]]]</VERB>
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 <PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>&quot;ar&quot;  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : mot-clé réservé ayant la signification suivante
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>nap  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : nombre d&apos;appels maximum à <VERB>costf</VERB>
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>iter  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : nombre maximum d&apos;itérations
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>epsg  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : seuil sur la norme du gradient
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>epsf  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : seuil sur la décroissance de <VERB>f</VERB>
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>epsx  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : seuil sur la variation de <VERB>x</VERB>. Ce vecteur (ou matrice) de même taille que <VERB>x0</VERB> peut être utilisé pour mettre <VERB>x</VERB> à l&apos;échelle.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 </PARAM_INDENT>
  <PARAM_ITEM>
  <PARAM_NAME>&quot;in&quot;  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : réservé pour l&apos;initialisation des paramètres quand <VERB>costf</VERB> est une routine Fortran ou C (voir ci-dessous)
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>&quot;imp=iflag&quot;  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : argument nommé pour choisir le mode d&apos;interaction. Avec <VERB>iflag=0</VERB> rien (à part les erreurs) n&apos;est affiché, avec <VERB>iflag=1</VERB> un rapport initial et final, <VERB>iflag=2</VERB> donne un rapport à chaque itération, <VERB>iflag&gt;2</VERB> donne en plus un rapport sur la recherche linéaire. Attention : ces rapports s&apos;affichent dans la sortie standard de Scilab.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>gradopt  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    :  gradient de <VERB>costf</VERB> en <VERB>xopt</VERB>
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
  <PARAM_ITEM>
  <PARAM_NAME>work  </PARAM_NAME>
  <PARAM_DESCRIPTION>
    : tableau de travail pour le redémarrage à chaud de quasi-Newton. Il peut être utilisé en entrée de optim pour accélérer l&apos;algorithme.
  </PARAM_DESCRIPTION> 
  </PARAM_ITEM>
 </PARAM_INDENT>
  </PARAM>
  <DESCRIPTION>
  <P>
    Routine d&apos;optimisation non-linéaire pour problèmes non linéaires sans contrainte ou avec contraintes de bornes. 
  </P>
  <VERBATIM><![CDATA[
min costf(x) w.r.t x.
   ]]></VERBATIM>
  <P>
    <VERB>costf</VERB> est une fonction, une liste ou un nom de routine Fortran ou C (voir &quot;external&quot;).
    Cette fonction doit renvoyer <VERB>f</VERB> (<VERB>costf(x)</VERB>) et <VERB>g</VERB> (le gradient de <VERB>costf</VERB>)
    pour un <VERB>x</VERB> donné.
  </P>
  <P>
    Si <VERB>costf</VERB> est une fonction Scilab, la séquence d&apos;appel de <VERB>costf</VERB> doit être :
  </P>
  <VERBATIM><![CDATA[
[f,g,ind]=costf(x,ind).
   ]]></VERBATIM>
  <P>
    Ici, <VERB>costf</VERB> est une fonction renvoyant <VERB>f</VERB>, la valeur (réelle) de
    la fonction coût en <VERB>x</VERB>, et <VERB>g</VERB>, le gradient de la fonction coût en <VERB>x</VERB>.
    La variable <VERB>ind</VERB> est utilisée par <VERB>optim</VERB> et son usage est décrit ci-dessous :
  </P>
  <P>
    Si <VERB>ind=2</VERB> (resp. <VERB>3, 4</VERB>), <VERB>costf</VERB> doit renvoyer <VERB>f</VERB> (resp. <VERB>g, f</VERB> et <VERB>g</VERB>).
  </P>
  <P>
    Si <VERB>ind=1</VERB> rien n&apos;est à calculer (utilisé par l&apos;affichage uniquement).
  </P>
  <P>
    En sortie, <VERB>ind&lt;0</VERB>  signifie que <VERB>f</VERB> ne peut pas être calculée en <VERB>x</VERB> et
    <VERB>ind=0</VERB> interrompt l&apos;optimisation.
  </P>
  <P>
    Si <VERB>f</VERB> est une chaîne de caractères, elle désigne le nom d&apos;une subroutine Fortran
    ou C qui doit être liée dynamiquement à Scilab (exemples dans les routines <VERB>foptim.f</VERB> 
    et <VERB>genros.f</VERB> dans le répertoire SCIDIR/default)
  </P>
  <P>
    Dans ce cas, la séquence d&apos;appel est :
    <VERB>function costf(ind,n,x,f,g,ti,tr,td)</VERB>
  </P>
  <P>
    <VERB>ind</VERB> a la même signification que ci-dessus <VERB>0,1,2</VERB> mais les valeurs <VERB>ind=10</VERB> et <VERB>ind=11</VERB> sont aussi valides. 
    Ces valeurs sont utilisées pour les initialisations (voir ci-dessous).
  </P>
  <P>
    <VERB>n</VERB> est la dimension de <VERB>x</VERB>, <VERB>x</VERB> est un <VERB>n</VERB>-vecteur 
    <VERB>ti,tr,td</VERB> sont des tableaux de travail.
  </P>
  <P>
    La fonction Fortran <VERB>costf</VERB> doit renvoyer <VERB>f</VERB> et le vecteur <VERB>g</VERB>,
    pour <VERB>x, ind, n, ti, tr, td</VERB> donnés.
  </P>
  <P>
    Si <VERB>costf</VERB> est une routine Fortran il est possible de lui passer des variables Scilab. 
  </P>
  <P>
    Cette fonctionnalité utilise le paramètre <VERB>&apos;in&apos;</VERB>.
  </P>
  <P>
    Si la chaîne de caractères <VERB>&apos;in&apos;</VERB> est présente, l&apos;initialisation est faite par la routine Fortran :
    <VERB>optim</VERB> fait deux appels à <VERB>costf</VERB>, l&apos;un avec
    <VERB>ind=10</VERB> et l&apos;autre avec <VERB>ind=11</VERB>. Dans ce cas, pour <VERB>ind=10</VERB>,
    <VERB>costf</VERB> doit donner les dimensions <VERB>nti, ntr, ntd</VERB> de <VERB>ti, tr, td</VERB> 
    dans le <VERB>common/nird/nti, ntr, ntd</VERB> et, pour <VERB>ind=11</VERB>, <VERB>costf</VERB>
    doit initialiser les vecteurs <VERB>ti , tr, td</VERB> (vecteur entier, vecteur réel,
    vecteur double précision, respectivement).
  </P>
  <P>
    Dans la séquence d&apos;appel de <VERB>optim</VERB>, la chaîne <VERB>&apos;in&apos;</VERB> peut être remplacée par <VERB>&apos;ti&apos;, valti ,&apos;td&apos; , valtd</VERB>. Dans ce cas la fonction Fortran
    <VERB>costf(ind, x, f, g, ti, tr, td)</VERB> est évaluée avec <VERB>ti=valti</VERB>
    et <VERB>td=valtd</VERB> quelque soit la valeur de <VERB>ind</VERB>.
    Ainsi, les variables Scilab  <VERB>valti</VERB> et <VERB>valtd</VERB> (vecteur entier et
    vecteur réel) sont envoyés à la fonction <VERB>costf</VERB>.
  </P>
  <P>
    Il est aussi  possible de sauver le contenu des tableaux de travail
    <VERB>ti</VERB> et <VERB>td</VERB> en ajoutant les chaînes &apos;si&apos; et/ou &apos;sd&apos;
    à la fin de la séquence d&apos;appel de <VERB>optim</VERB>.
    Dans ce cas les variables de sortie sont : <VERB>[f,[x,[g],[to]]],[ti],[td]]</VERB>.
  </P>
  </DESCRIPTION>
  <EXAMPLE><![CDATA[
xref=[1;2;3];x0=[1;-1;1]
deff('[f,g,ind]=cost(x,ind)','f=0.5*norm(x-xref)^2,g=x-xref');
[f,xopt]=optim(cost,x0)      // appel simple
[f,xopt,gopt]=optim(cost,x0,'gc')  // avec un gradient conjugué
[f,xopt,gopt]=optim(cost,x0,'nd')  // f vue comme fonction non-différentiable
[f,xopt,gopt]=optim(cost,'b',[-1;0;2],[0.5;1;4],x0) //  Bornes sur X
[f,xopt,gopt]=optim(cost,'b',[-1;0;2],[0.5;1;4],x0,'gc') //
[f,xopt,gopt]=optim(cost,'b',[-1;0;2],[0.5;1;4],x0,'gc','ar',3)
// 
// Appel à la subroutine "genros" dans SCIDIR/default/Ex-optim.f
// Voir la fonction "link" pour le lien dynamique
[f,xopt,gopt]=optim('genros',[1;2;3])    // Fonction de Rosenbrock
 ]]></EXAMPLE>
  <SEE_ALSO>
    <SEE_ALSO_ITEM> <LINK>external</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>quapro</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>linpro</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>datafit</LINK> </SEE_ALSO_ITEM>     <SEE_ALSO_ITEM> <LINK>leastsq</LINK> </SEE_ALSO_ITEM>
  </SEE_ALSO>
</MAN>
