<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN">
<!--Converted with LaTeX2HTML 96.1 (Feb 5, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>Control of jump linear systems</TITLE>
<META NAME="description" CONTENT="Control of jump linear systems">
<META NAME="keywords" CONTENT="lmidoc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<LINK REL=STYLESHEET HREF="lmidoc.css">
</HEAD>
<BODY LANG="EN">
 <A NAME="tex2html144" HREF="node8.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="http://www-rocq.inria.fr/scilab/icons/next_motif.gif"></A> <A NAME="tex2html142" HREF="node5.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="http://www-rocq.inria.fr/scilab/icons/up_motif.gif"></A> <A NAME="tex2html136" HREF="node6.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="http://www-rocq.inria.fr/scilab/icons/previous_motif.gif"></A> <A NAME="tex2html146" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="http://www-rocq.inria.fr/scilab/icons/contents_motif.gif"></A>  <BR>
<B> Next:</B> <A NAME="tex2html145" HREF="node8.html">Descriptor Lyapunov inequalities</A>
<B>Up:</B> <A NAME="tex2html143" HREF="node5.html">Examples</A>
<B> Previous:</B> <A NAME="tex2html137" HREF="node6.html">State-feedback with control saturation </A>
<BR> <P>
<H3><A NAME="SECTION00032200000000000000">Control of jump linear systems</A></H3>
<P>
<A NAME="ex2">&#160;</A>
We are given a linear system 
<P> <IMG WIDTH=338 HEIGHT=15 ALIGN=BOTTOM ALT="displaymath666" SRC="img20.gif"  > <P>
where <I>A</I> is  <IMG WIDTH=38 HEIGHT=16 ALIGN=MIDDLE ALT="tex2html_wrap_inline636" SRC="img11.gif"  >  and <I>B</I> is  <IMG WIDTH=47 HEIGHT=18 ALIGN=MIDDLE ALT="tex2html_wrap_inline640" SRC="img12.gif"  > .   The scalar
parameter <I>r</I>(<I>t</I>) is a continuous-time Markov process taking values in
a finite set  <IMG WIDTH=74 HEIGHT=24 ALIGN=MIDDLE ALT="tex2html_wrap_inline678" SRC="img21.gif"  > .
<P>
The transition probabilities of the process <I>r</I> are defined by a
``transition matrix''  <IMG WIDTH=67 HEIGHT=24 ALIGN=MIDDLE ALT="tex2html_wrap_inline682" SRC="img22.gif"  > , where  <IMG WIDTH=20 HEIGHT=14 ALIGN=MIDDLE ALT="tex2html_wrap_inline684" SRC="img23.gif"  > 's are the 
transition probability rates from
the <I>i</I>-th mode to the <I>j</I>-th.  Such systems, referred to as ``jump
linear systems'', can be used to model linear systems subject to
failures.
<P>
We seek a state-feedback control law such that the resulting
closed-loop system is mean-square stable.  That is, for every initial
condition <I>x</I>(0), the resulting trajectory of the closed-loop system
satisfies  <IMG WIDTH=152 HEIGHT=25 ALIGN=MIDDLE ALT="tex2html_wrap_inline692" SRC="img24.gif"  > .
<P>
The control law we look for is a mode-dependent linear state-feedback,
<EM>i.e.</EM> it has the form <I>u</I>(<I>t</I>) = <I>K</I>(<I>r</I>(<I>t</I>))<I>x</I>(<I>t</I>); <I>K</I>(<I>i</I>)'s are  <IMG WIDTH=46 HEIGHT=18 ALIGN=MIDDLE ALT="tex2html_wrap_inline656" SRC="img16.gif"  >  matrices (the
unknowns of our control problem).
<P>
It can be shown that this problem has a solution if and only if
there exist  <IMG WIDTH=38 HEIGHT=16 ALIGN=MIDDLE ALT="tex2html_wrap_inline636" SRC="img11.gif"  >  matrices   <IMG WIDTH=109 HEIGHT=23 ALIGN=MIDDLE ALT="tex2html_wrap_inline702" SRC="img25.gif"  > , and  <IMG WIDTH=46 HEIGHT=18 ALIGN=MIDDLE ALT="tex2html_wrap_inline656" SRC="img16.gif"  > 
matrices  <IMG WIDTH=109 HEIGHT=23 ALIGN=MIDDLE ALT="tex2html_wrap_inline706" SRC="img26.gif"  > , such that  
<P> <IMG WIDTH=500 HEIGHT=42 ALIGN=BOTTOM ALT="eqnarray113" SRC="img27.gif"  > <P>
and
<P> <IMG WIDTH=646 HEIGHT=105 ALIGN=BOTTOM ALT="eqnarray115" SRC="img28.gif"  > <P>
If such matrices exist, a stabilizing
state-feedback is given by  <IMG WIDTH=134 HEIGHT=25 ALIGN=MIDDLE ALT="tex2html_wrap_inline708" SRC="img29.gif"  > ,  <IMG WIDTH=87 HEIGHT=24 ALIGN=MIDDLE ALT="tex2html_wrap_inline710" SRC="img30.gif"  > .
<P>
In the above problem, the data matrices are  <IMG WIDTH=108 HEIGHT=23 ALIGN=MIDDLE ALT="tex2html_wrap_inline712" SRC="img31.gif"  > ,
 <IMG WIDTH=112 HEIGHT=23 ALIGN=MIDDLE ALT="tex2html_wrap_inline714" SRC="img32.gif"  >  and the transition matrix  <IMG WIDTH=11 HEIGHT=11 ALIGN=BOTTOM ALT="tex2html_wrap_inline716" SRC="img33.gif"  > .  The unknown 
matrices are <I>Q</I>(<I>i</I>)'s (which are symmetric  <IMG WIDTH=38 HEIGHT=16 ALIGN=MIDDLE ALT="tex2html_wrap_inline636" SRC="img11.gif"  >  matrices) and
<I>Y</I>(<I>i</I>)'s (which are  <IMG WIDTH=46 HEIGHT=18 ALIGN=MIDDLE ALT="tex2html_wrap_inline656" SRC="img16.gif"  >  matrices). In this case, both
the number of the data matrices and that of the unknown matrices
are a-priori unknown.
<P>
The above problem is obviously a  <IMG WIDTH=9 HEIGHT=11 ALIGN=BOTTOM ALT="tex2html_wrap_inline590" SRC="img7.gif"  >  problem.  In this case,
we can let <TT>XLIST</TT> be a list of two lists: one representing
the <I>Q</I>'s and the other, the <I>Y</I>'s.
<P>
The evaluation function required for invoking <TT>lmisolver</TT> can be constructed as
follows:
<PRE> function [LME,LMI,OBJ]=jump_sf_eval(XLIST)
 [Q,Y]=XLIST(:)
 N=size(A); [n,nu]=size(B(1))
 LME=list(); LMI1=list(); LMI2=list()
 tr=0
 for i=1:N
    tr=tr+trace(Q(i))
    LME(i)=Q(i)-Q(i)'
    LMI1(i)=[Q(i),Y(i)';Y(i),eye(nu,nu)]
    SUM=zeros(n,n)
    for j=1:N
      SUM=SUM+PI(j,i)*Q(j)
    end
    LMI2(i)= A(i)*Q(i)+Q(i)*A(i)'+B(i)*Y(i)+Y(i)'*B(i)'+SUM
 end
 LMI=list(LMI1,LMI2)
 LME(N+1)=tr-1
 OBJ=[]</PRE>
Note that <TT>LMI</TT> is also a list of lists containing the values
of the LMI matrices. This is just a matter of convenience.
<P>
Now, we can solve the problem in
Scilab as follows (assuming lists <TT>A</TT> and <TT>B</TT>, and  matrix
<TT>PI</TT> have already been defined).
<P>
First we should initialize <TT>Q</TT> and <TT>Y</TT>. 
<PRE>--&gt; N=size(A);  [n,nu]=size(B(1)); Q_init=list(); Y_init=list();
--&gt; for i=1:N, Q_init(i)=zeros(n,n);Y_init(i)=zeros(nu,n);end</PRE>
Then, we can use <TT>lmisolver</TT> as follows:
<PRE>--&gt; XLIST0=list(Q_init,Y_init)
--&gt; XLISTF=lmisolver(XLIST0,jump_sf_eval)
--&gt; [Q,Y]=XLISTF(:);</PRE>
<P>
The above commands can be encapsulated in a solver function, say 
<TT>jump_sf</TT>,
in which case we simply need to type:
<PRE>--&gt; [Q,Y]=jump_sf(A,B,PI)</PRE>
to obtain the solution.
<P>
<HR><A NAME="tex2html144" HREF="node8.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="http://www-rocq.inria.fr/scilab/icons/next_motif.gif"></A> <A NAME="tex2html142" HREF="node5.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="http://www-rocq.inria.fr/scilab/icons/up_motif.gif"></A> <A NAME="tex2html136" HREF="node6.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="http://www-rocq.inria.fr/scilab/icons/previous_motif.gif"></A> <A NAME="tex2html146" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="http://www-rocq.inria.fr/scilab/icons/contents_motif.gif"></A>  <BR>
<B> Next:</B> <A NAME="tex2html145" HREF="node8.html">Descriptor Lyapunov inequalities</A>
<B>Up:</B> <A NAME="tex2html143" HREF="node5.html">Examples</A>
<B> Previous:</B> <A NAME="tex2html137" HREF="node6.html">State-feedback with control saturation </A>
<P><ADDRESS>
Scilab Group
</ADDRESS>
</BODY>
</HTML>
