%2345678901234567890123456789012345678901234567890123456789012345678901234567890
\chapter{Incremental link and {\tt intersci}}
\label{intersci}
\index{intersci@{\tt intersci}}

\newcommand{\version}{Version 2.1}
\newcommand{\T}[1]{{\tt #1}}
\newcommand{\M}[1]{$<${\em #1}$>$}
\newcommand{\ie}{\mbox{i.e.}}

%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%
We present here the two ``automatic''  ways for a user to add his programs to 
Scilab. The first one 
is the incremental link : it is very easy but it is not adapted to a large
number of routines and there are some limitations depending on the machine
and the compilation options. The second one called {\tt intersci} give to the
user the tool of a Scilab developper.

{\tt intersci} is a program which permits to interface automatically Fortran 
subroutines or C functions to Scilab.

With {\tt intersci} a user can group all the calls to his Fortran or C code into a same set,
called an interface, and use them in {\tt intersci} as {\tt intersci} 
functions. The  interfacing
is made by creating a Fortran subroutine which has to be linked to Scilab 
together with the user code. This complex Fortran subroutine is automatically 
generated by {\tt intersci} from a description file of the interface.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Linking a routine to Scilab}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The command {\tt link} links a compiled C or Fortran routine to Scilab.
This command is available with some options for the compilation of Scilab
and is restricted on some machines (see the corresponding on-line help).
With no arguments {\tt link()} returns the vector of linked routines.
If {\tt foo.o} is the file of the object code and {\tt foo}  the name of the 
fortran or C routine, a possible command is :

{\tt link('foo.o -lfor -lm -lc','foo')}

it means that the entry point {\tt foo} defined by the object file
{\tt foo.o} and the libraries {\tt libfor, libm, libc} is added (linked)
to Scilab.

Then you can call the new-linked routine by using the command {\tt fort}. This
command needs the name of the routine, the input-output variables together
with the types and the positions of these variables. We recall here the simple
example of the on-line help :
for the fortran routine 

\begin{verbatim}
	subroutine foo(a,b,c)
	c=2*a+b
	end
\end{verbatim}

the unix command make -c foo gives foo.o and then with Scilab :

\begin{verbatim}
-->link("foo.o","foo")

linking foo_ defined in foo.o  with Scilab 

 
-->a=13;b=10;
 
-->c=fort("foo",a,1,"r",b,2,"r","out",[1,1],3,"r")
 c  =
 
    36.  
\end{verbatim}

In the calling sequence of {\tt fort} : {\tt foo} is the name of the called
routine, {\tt a} is a calling parameter at the position {\tt 1} and its type is
real {\tt r}, {\tt b} is the second calling parameter. The input variables
and the output variables are separated by the keyword {\tt out} and then the
(Scilab) types of the different output are defined : we have here one 
output which is a {\tt [1,1]} matrix in the position {\tt 3} in the calling
sequence of the routine and its type is real {\tt r}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Adding a new interface in Scilab}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%
\section{Using {\tt intersci}}
%%%%%%%%%%%%%%%%%%%%%
In the following, we will only speak of Fortran subroutine interfacing. The
process is nearly the same for C functions (see \ref{C}).

\smallskip

To use {\tt intersci} execute the Unix command:\\
\T{intercsi }\M{interface name}\T{\ }\M{interface number}\\
where \M{interface name}\T{.desc} is the file describing the interface.

Then the files \M{interface name}\T{.f} and \T{fundef.}\M{interface name}
are created.

\smallskip

The file \M{interface name}\T{.desc} is a sequence of descriptions of 
pairs formed by the Scilab function and the corresponding Fortran subroutine
(see table \ref{t-pair}).

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|}
\hline
\M{Scilab function name} \M{function arguments}\\
\M{Scilab variable} \M{Scilab type} \M{possible arguments}\\
\quad$\vdots$\qquad\qquad$\vdots$\qquad\qquad$\vdots$\qquad\qquad$\vdots$
  \qquad\qquad$\vdots$\\
\M{Fortran subroutine name} \M{subroutine arguments}\\
\M{Fortran argument} \M{Fortran type}\\
\quad$\vdots$\qquad\qquad$\vdots$\qquad\qquad$\vdots$\qquad\qquad$\vdots$\\
out \M{type} \M{formal output names}\\
\M{formal output name} \M{variable}\\
\quad$\vdots$\qquad\qquad$\vdots$\qquad\qquad$\vdots$\qquad\qquad$\vdots$\\
*******************************\\
\hline
\end{tabular}
\end{center}
\caption{Description of a pair of Scilab function and Fortran subroutine}
\label{t-pair}
\end{table}

Each description is made of three parts: description of Scilab function and its
arguments, description of Fortran subroutine and its arguments, and finally
description of the output of Scilab function with possible type conversions.
Different illustrating examples are presented in the sequel.

\subsection{Description of Scilab function}
%%%%%%%%%%%
\label{scilab}

The first line of the description is composed by the name of the Scilab
function followed by its input arguments in calling order.

The next lines describe Scilab variables: the input arguments and the
outputs of the Scilab function, together with the arguments of the Fortran
subprogram with type \T{work} (for which memory must be allocated).
It is an error not to describe such arguments.

The description of a Scilab variable begins by its name, then its type followed
by possible informations depending on the type.

Types of Scilab variables are:
\begin{description}
  \item[any] any type: only used for an input argument of Scilab function.
  \item[column] column vector: must be followed by its dimension.
  \item[list] list: must be followed by the name of the list,
\M{list name}. This name must correspond to a file \M{list name}\T{.list}
which describes the structure of the list (see \ref{list}).
  \item[matrix] matrix: must be followed by its two dimensions.
  \item[polynom] polynomial: must be followed by its dimension (size) and the
name of the unknown.
  \item[row] row vector: must be followed by its dimension (length).
  \item[scalar] scalar.
  \item[string] character string: must be followed by its dimension (length).
  \item[vector] row or column vector: must be followed by its dimension.
  \item[work] working array: must be followed by its dimension. It must not
correspond to an input argument or to the output of the Scilab function.
\end{description}

The way dimensions are specified is described in 
\ref{dimensions}.
\smallskip

A blank line and only one ends this description.

\subsubsection{Optional input arguments}

\subsection{Description of Fortran subroutine}
%%%%%%%%%%%
\label{fortran}

The first line of the description is composed by the name of the 
Fortran subroutine
followed by its arguments in calling order.

The next lines describe Fortran variables: the arguments of the Fortran
subroutine. 
It is an error not to describe such arguments.

The description of a Fortran variable is made of its name and its type.
Most Fortran variables correspond to Scilab variables (except for
dimensions, see \ref{dimensions}) and must have the same name as the
corresponding Scilab variable. It is the reason why possible Fortran variable
dimensions are not given here because defined with the Scilab variable
dimension.

\smallskip

Types of Fortran variables are:
\begin{description}
  \item[char] character array.
  \item[double] double precision variable.
  \item[int] integer variable.
  \item[real] real variable.
\end{description}

External types also exist, see \ref{external}.

\smallskip

A blank line and only one ends this description.

\subsection{Description of the output of Scilab function}
%%%%%%%%%%%
\label{output}

The first line of this description must begin by the word \T{out} followed
by the type of Scilab output.

\smallskip

Types of output are:
\begin{description}
  \item[empty] the Scilab function returns nothing.
  \item[list] a Scilab list: must be followed by the names of Scilab variables
elements of the list.
  \item[sequence] a Scilab sequence: must be followed by the names of Scilab
variables elements of the sequence.
\end{description}

This first line must be followed by other lines corresponding to output type
conversion. This is the case when an output variable is also an input variable
with different Scilab type: for instance an input column vector becomes an
output row vector. The line which describes this conversion begins by the name
of Scilab output variable followed by the name of the corresponding Scilab input
variable. See \ref{ex3} as an example.
\medskip

A line beginning with a star ``\T{*}'' ends the description of a pair of
Scilab function and Fortran subroutine. This line is compulsory even if it is
the end of the file. Do not forget to end the file by a carriage return.

\subsection{Dimensions of non scalar variables}
%%%%%%%%%%%
\label{dimensions}

When defining non scalar Scilab variables (vectors, matrices, polynomials and
character strings) dimensions must be given. There are a few ways to do that:

\begin{itemize}
  \item It is possible to give the dimension as an integer (see \ref{ex1}).
  \item The dimension can be the dimension of an input argument of Scilab
function. This dimension is then denoted by a formal name which is not the
name of a Scilab variable (see \ref{ex2}). This is an usual case.
  \item The dimension can be defined as an output of the Fortran subroutine.
This means that the memory for the corresponding variable is allocated by the
Fortran subroutine. The corresponding Fortran variable must necessary have an
external type (see \ref{external} and \ref{ex3}).
\end{itemize}

{\tt intersci} is not able to treat the case where the dimension is an algebraic
expression of other dimensions. A Scilab variable corresponding to this value
must defined.

The dimension must not be an input of Scilab function.

\subsection{Fortran variables with external type}
%%%%%%%%%%%
\label{external}

When describing the Fortran subroutine, a Fortran variable can have a type
different than the ones described in \ref{fortran}.

External types are used when the dimension of the Fortran variable is
unknown when calling the Fortran subroutine and when its memory size is
allocated in this subroutine. This dimension must be an output of the Fortran
subroutine. In fact, this will typically happen when we want to interface a C
function in which memory is dynamically allocated.

\smallskip

Existing external types:
\begin{description}
 \item[cchar] character string allocated by a C function to be copied into the
corresponding Scilab variable.
 \item[ccharf] the same as \T{cchar} but the C character string is freed after
the copy.
 \item[cdouble] C double array allocated by a C function to be copied into the
corresponding Scilab variable.
 \item[cdoublef] the same as \T{cdouble} but the C double array is freed after
the copy.
 \item[cint] C integer array allocated by a C function to be copied into the
corresponding Scilab variable.
 \item[cintf] the same as \T{cint} but the C integer array is freed after
the copy.
\end{description}

\medskip

In fact, the name of an external type corresponds to the name of a C function.
This C function has three arguments: the dimension of the variable, an input
pointer and an output pointer.

For instance, below is the code for external type \T{cintf}:
\begin{verbatim}
#include "../machine.h"   

/* ip is a pointer to a Fortran variable coming from Scilab
which is itself a pointer to an array of n integers typically
coming from a C function
   cintf converts this integer array into a double array in op 
   moreover, pointer ip is freed */

void C2F(cintf)(n,ip,op)
int *n;
int *ip[];
double *op;
{
  int i;
  for (i = 0; i < *n; i++)
    op[i]=(double)(*ip)[i];
  free((char *)(*ip));
}
\end{verbatim}

For the meaning of \verb|#include "../machine.h"| and \T{C2F} see \ref{C}.

\smallskip

Then, the user can create its own external types by creating its own C
functions with the same arguments. {\tt intersci} will generate the good call of the
function. 

\subsection{Using lists as input Scilab variables}
%%%%%%%%%%%
\label{list}

An input argument of the Scilab function can be a Scilab list.
If \M{list name} is the name of this variable, a file called 
\M{list name}\T{.graph}
must describe the structure of the list. This file permits to associate
a Scilab variable to each element of the list by defining
its name and its Scilab type. The variables are described in order into the
file as described by table \ref{t-list}.

Then, such a variable element of the list is referred in the file 
\M{interface name}\T{.desc} by its
name followed by the name of the corresponding list in parenthesis. For
instance, \T{la1(g)} denotes the variable named \T{la1} element of the list
named \T{g}.

\begin{table}
\begin{center}
\begin{tabular}{|l|}
\hline
\M{comment on the variable element of the list}\\
\M{name of the variable element of list} \M{type} \M{possible arguments}\\
*******************************\\
\hline
\end{tabular}
\end{center}
\caption{Description of a variable element of a list}
\label{t-list}
\end{table}

An example is shown in \ref{ex4}.

\subsection{Limitations}
%%%%%%%%%%%
\label{limit}

{\tt intersci} does not permit to interface Fortran functions.

The Fortran subroutines we want to interface must not use \T{COMMON} to pass
arguments. All the arguments must be in the calling list of the subroutine.

{\tt intersci} is not able to deal with complexes, matrices of strings and
matrices of polynomials as Scilab variables.

See also \ref{dimensions} for limitations on dimensions.

\subsection{C functions interfacing}
%%%%%%%%%%%
\label{C}

To interface C functions instead of Fortran subroutines is easy.

The C function must be considered as a procedure \ie\
its type must be \T{void} or the value returned must not be used.

The arguments of the C function must be considered as Fortran arguments \ie\
they must be only pointers.

Moreover, the name of the C function must be recognized by Fortran. This
depends upon the machines. For instance, on SUN and DEC machines the name of C
functions must end by a \T{\_} to be recognized by Fortran, but on RS6000
(IBM) machines the name must be the same. So, the include file \T{machine.h}
situated in the
directory \M{Scilab directory}\T{/routines} can be included in C functions and
the macros \T{C2F} and \T{F2C} can be used. This include file defines
a trailing underscore variable WTU and a leading underscore variable WLU
depending on the machine and/or system and compiler types. The functions
 \T{C2F} and \T{F2C} correct the name of a routine in C to be
recognized by Fortran (and conversely).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Writing compatible code to Scilab}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{compat}

\subsection{Input and output}
%%%%%%%%%%%
If the user routines need to write text in the Scilab window, one must use 
the Scilab routine {\tt basout}. If the new routine uses the fortran 
function {\tt write} or the C function {\tt fprintf} the output will
occur in the shell window.

It is also possible to read text in the Scilab window with the use of the routine {\tt basin} and to read numerical data with the routine {\tt dbasin}.

These input/output routines are in the directory 
{\tt <scilab dir>/routines/sun}.

\subsection{Error exit}
%%%%%%%%%%%
If the user routine needs to interrupt the evaluation of the corresponding 
Scilab function the routine to be called is {\tt erro} with the error message
as argument and then return.

%%%%%%%%%%%%%%%%%%
\section{Examples}
%%%%%%%%%%%%%%%%%%

\subsection{Example 1}
%%%%%%%%%%%
\label{ex1}

The name of the Scilab function is \T{calc}. Its input is a string and its
output is a scalar.

The name of the corresponding Fortran subroutine is \T{calc} and its arguments
are a string (used as input) and an integer (used as output).

We reserve a fixed dimension of 10 for the string.

The description file is the following:
\begin{verbatim}
calc    str
str     string  10
a       scalar

fcalc   str     a
str     char
a       integer

out     a
***********************
\end{verbatim}

\subsection{Example 2}
%%%%%%%%%%%
\label{ex2}

The name of the Scilab function is \T{som}. Its inputs are two row vectors and
its  output is a column vector.

The name of the corresponding Fortran subroutine is \T{fsom} and its arguments
are a real array and its dimension (used as input), another 
real array and its dimension (used as input) and a real array (used as output).
These dimensions \T{m} and \T{n} are determined at the calling of the Scilab
function and do not need to appear as Scilab variables.

{\tt intersci} will do the job to make the necessary conversions to transform the
double precision (default in Scilab) row vector \T{a} into a real array and to
transform the real array \T{c} into a double precision row vector.

The description file is the following:
\begin{verbatim}
som     a       b
a       row     m
b       row     n
c       column  n

fsom    a       n       b       m       c
str     char
a       real
n       integer
b       real
m       integer
c       real

out     sequence        c
***********************
\end{verbatim}

\subsection{Example 3}
%%%%%%%%%%%
\label{ex3}

The name of the Scilab function is \T{ext}. Its input is a matrix and its
outputs are a matrix and a column vector.

The name of the corresponding Fortran subroutine is \T{fext} and its arguments
are an integer array (used as input and output), its dimensions (used as
input) and another integer array and its dimension (used as outputs).

The dimension \T{p} of the output \T{b} is computed by the Fortran subroutine
and the memory for this variable is also allocated by the Fortran subroutine
(perhaps by to a call to another C function). So the type of the variable is
external and we choose \T{cintf}.

Moreover, the output \T{a} of the Scilab function is the same as the input
but its type changes from a $m \times n$ matrix to a $n \times m$ matrix. This
conversion is made my introducing the Scilab variable \T{o}

The description file is the following:
\begin{verbatim}
ext     a
a       matrix  m       n
b       column  p
o       matrix  n       m

fext    a       m       n       b       p
a       integer
m       integer
n       integer
b       cintf
p       integer

out     sequence        o       b
o       a
***************************
\end{verbatim}

\subsection{Example 4}
%%%%%%%%%%%
\label{ex4}

The name of the Scilab function is \T{contr}. Its input is a list representing
a linear system given by its state representation and a tolerance. Its return
is a scalar (for instance the dimension of the controllable subspace).

The name of the corresponding Fortran subroutine is \T{contr} and its
arguments are the dimension of the state of the system (used as input), the
number of inputs of the system (used as input), 
the state matrix of the system (used as input),
the input matrix of the system (used as input),
an integer giving the dimension of the controllable subspace (used as output),
and the tolerance (used as input).

The description file is the following:
\begin{verbatim}
contr   sys     tol
tol     scalar
sys     list    lss
icontr  scalar

contr   nstate(sys)	nin(sys)     a(sys)  b(sys)  icontr  tol
a(sys)  double
b(sys)  double
tol     double
nstate(sys)     integer
nin(sys)        integer
icontr  integer

out     sequence        icontr
******************************
\end{verbatim}

The type of the list is \T{lss} and a file describing the list \T{lss.list} is
needed. It is shown below:

\begin{verbatim}
1 type
type    string  3
******************************
2 state matrix
a       matrix  nstate  nstate
******************************
3 input matrix
b       matrix  nstate  nin
******************************
4 output matrix
c       matrix  nout    nstate
******************************
5 direct tranfer matrix
d       matrix  nout    nin
******************************
6 initial state
x0      column  nstate
******************************
7 time domain
t       any
******************************
\end{verbatim}

The number of the elements is not compulsory in the comment describing the
elements of the list but is useful.

