%\documentstyle[11pt]{article}
%\textwidth=6in
%\textheight=8.5in 
%\oddsidemargin=.30in%.25in
%\evensidemargin=.30in%.25in
%\topmargin=-.25in
%\parskip.3cm

%\begin{document}
\chapter{Maple to Scilab Interface}
\index{Maple}
To combine symbolic computation of the computer algebra system Maple with the 
numerical facilities
of Scilab, Maple objects can be transformed into Scilab functions. To assure 
efficient numerical evaluation this is done through numerical evaluation in 
Fortran. The whole process is done by a Maple procedure called 
\verb/maple2scilab/.
\section{Maple2scilab}
\index{maple2scilab@{\tt maple2scilab}}
The procedure \verb!maple2scilab! converts a Maple object, 
either a scalar function or a matrix into a Fortran subroutine 
and writes the associated Scilab function. The code of \verb!maple2scilab!
is in the directory \verb!SCIDIR/maple!.

The calling sequence of \verb!maple2scilab! is as follows:\\
\verb!maple2scilab(function-name,object,args)!
\begin{itemize}
\item
The first argument, \verb!function-name! is a name indicating the 
function-name in Scilab.
\item
The second argument \verb!object! is the Maple name of the expression 
to be transferred to Scilab.
\item
The third argument is a list of arguments containing the formal parameters of
the Maple-object \verb!object!.
\end{itemize}
When \verb!maple2scilab! is invoked in Maple, two files are generated,
one which contains the Fortran code and another which contains the 
associated Scilab function. Aside their existence, the user has not to
know about their contents.

The Fortran routine which is generated has the following calling sequence:\\
{\tt <Scilab-name>(x1,x2,\ldots,xn,matrix)} \\
and this subroutine computes matrix(i,j) as a function of
the arguments {\tt x1,x2,\ldots,xn}.
Each argument can be a Maple scalar or array which should be
in the argument list. 
The Fortran subroutine is put into a file named {\tt <Scilab-name>.f}, the
Scilab-function into a file named {\tt <Scilab-name>.sci}.
For numerical evaluation in Scilab the user has to compile the Fortran 
subroutine, to link it with Scilab (e.g. Menu-bar option '\verb!link!')
and to load the associated function (Menu-bar option '\verb!getfc!').
Information about \verb!link! operation is given in Scilab's manual: 
Fortran routines can be incorporated into Scilab by dynamic
link or through the \verb!interf.f! file in the \verb!default! directory.
 Of course, this two-step procedure can be automatized using a shell-script 
(or using \verb!unix! in Scilab).
Maple2scilab uses the ``Macrofort'' library which is in the share 
library of Maple.
\subsection{Simple Scalar Example}
\paragraph{Maple-Session}
\begin{verbatim}
> read(`maple2scilab.maple`):
> f:=b+a*sin(x);

                               f := b + a sin(x)

> maple2scilab('f_m',f,[x,a,b]);
\end{verbatim}
Here the Maple variable \verb!f! is a scalar expression but it could be also
a Maple vector or matrix.
\verb/ 'f_m'/ will be the name of \verb!f! in Scilab 
(note that the Scilab name is restricted to contain at most 6 characters).
The procedure \verb/maple2scilab/ creates two files: \verb/f_m.f/ 
and  \verb/f_m.sci/ in the directory where Maple is started.
To specify another directory just define in Maple the path : 
\verb/rpath:=`//\verb/work//` ; then all files are written in 
the sub-directory \verb/work/.
The file \verb!f_m.f! contains the source code of a stand alone Fortran
routine which is dynamically linked to Scilab by the function \verb!f_m! in
defined in the file \verb!f_m.sci!.

\paragraph{Scilab Session}
\begin{verbatim}
-->unix('make f_m.o');
 
-->link('f_m.o','f_m');

linking  _f_m_ defined in f_m.o  
 
-->getf('f_m.sci','c')
 
-->f_m(%pi,1,2)
 ans       =
 
    2.  
\end{verbatim}

\subsection{Matrix Example}
This is an example of transferring a Maple matrix into Scilab.
\paragraph{Maple Session}
\begin{verbatim}
> with(linalg):read(`maple2scilab.maple`):

> x:=vector(2):par:=vector(2):

> mat:=matrix(2,2,[x[1]^2+par[1],x[1]*x[2],par[2],x[2]]);

                            [     2                     ]
                            [ x[1]  + par[1]  x[1] x[2] ]
                    mat :=  [                           ]
                            [     par[2]         x[2]   ]

> maple2scilab('mat',mat,[x,par]);

\end{verbatim}

\paragraph{Scilab Session}
\begin{verbatim}
-->unix('make mat.o');

-->link('mat.o','mat') 

linking  _mat_ defined in mat.o  
 
-->getf('mat.sci','c')

-->par=[50;60];x=[1;2];
 
-->mat(x,par)
 ans       =
 
!   51.    2. !
!   60.    2. !
 
\end{verbatim}

{\small
\paragraph{Generated code}
Below is the code (Fortran subroutines and Scilab functions) which is 
automatically generated by {\tt maple2scilab} in the two preceding  examples.
\paragraph{Fortran routines}
\begin{verbatim}
c      
c     SUBROUTINE f_m
c      
      subroutine f_m(x,a,b,fmat)
      doubleprecision x,a,b
      implicit doubleprecision (t)
      doubleprecision fmat(1,1)
         fmat(1,1) = b+a*sin(x)
      end
\end{verbatim}
\begin{verbatim}
c      
c     SUBROUTINE mat
c      
      subroutine mat(x,par,fmat)
      doubleprecision x,par(2)
      implicit doubleprecision (t)
      doubleprecision fmat(2,2)
         t2 = x(1)**2
         fmat(2,2) = x(2)
         fmat(2,1) = par(2)
         fmat(1,2) = x(1)*x(2)
         fmat(1,1) = t2+par(1)
      end
\end{verbatim}
\paragraph{Scilab functions}
\begin{verbatim}
function [var]=f_m(x,a,b)
var=fort('f_m',x,1,'d',a,2,'d',b,3,'d','out',[1,1],4,'d')
//end
\end{verbatim}
\begin{verbatim}
function [var]=fmat(x,par)
var=fort('fmat',x,1,'d',par,2,'d','out',[2,2],3,'d')
//end
\end{verbatim}
}
%\end{document}



