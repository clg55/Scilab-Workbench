
\documentclass{article}
\usepackage{epsfig,times,amsmath,amssymb}


\def\Figdir{}

\def\Scilab{{\sc Scilab}}

\newcommand{\computational}{{\em Computational }}
\newcommand{\interfacing}{{\em Interfacing }}


%\makeatletter

\title{SCICOS - A Dynamic System Builder and Simulator\\ User's Guide \thanks{Scicos is a Scilab
toolbox. This version of Scicos is included in Scilab-2.4. For more information on Scilab see:
{\tt http://www-rocq.inria.fr/scilab/}}}
\author{R. Nikoukhah \and S. Steer}
\date{}

\begin{document}
\maketitle
\input demo22.tex
\dessin{A typical Scicos diagram}{}
\section{Introduction}
\label{scicos}
Scicos (Scilab Connected Object Simulator) is a Scilab package for
modeling and simulation of dynamical systems including
both continuous and discrete sub-systems.
Scicos includes a graphical editor for constructing 
models by interconnecting blocks (representing predefined basic
functions or user defined functions). 

Associated with each signal, in Scicos, is a set of time indices, called activation times,
on which the signal can evolve. Outside their activation times, Scicos signals remain constant (see
Figure~\ref{ghuio}). The activation time set is a union of time intervals and isolated
points called events.
\begin{figure}
\begin{center}
\input jadid20.pstex_t
\end{center}
\caption{A signal in Scicos  and its activation time set.}
\label{ghuio}
\end{figure}

Signals in Scicos are generated by blocks driven by activation signals. An activation
signal causes the block to evaluate its output as a function of its input and internal state. 
The output signal, which inherits its activation time set from the generating block, can be
used to drive other blocks. 

Blocks are activated by activation signals which are received on activation input
ports placed on top of blocks. A block with no input activation port is 
permanently active (called time dependent) otherwise it inherits its activation
times from the union of activations times of its input signals.

Ports placed at the bottom of blocks are output activation ports. The outgoing
signals are activation signals generated by the block. For example,
the {\tt Clock} block generates an activation signal composed of a train of
regularly spaced events in time. If this output is connected to the input
activation port of a scope block (such as the {\tt MScope} block), it specifies
at what times the value of the inputs of the scope must be displayed.

\section{Scicos editor}
\label{scasm}
\label{ch2}
In Scicos, systems are modeled by interconnecting blocks and subsystems (Super blocks);
blocks can be found in various palettes or be defined by user. Scicos has an easy to use
graphical user interface for editing diagrams. To start the editor, in Scilab, type {\tt scicos();}.
This opens up Scicos' main window.

Construction of Scicos model typically consists of
\begin{itemize}
\item opening one or more palettes (using {\tt Palettes} button in the {\tt Edit} menu),
\item copying blocks from palettes into Scicos' main window; this can be done by
selecting the {\tt copy} button in the {\tt Edit} menu, then clicking on the block to
be copied, and finally in the Scicos' main window, where the block is to be placed. 
\item connecting the input and output ports of the blocks
by selecting first the {\tt link} button in the {\tt Edit} menu, then clicking  on the 
output port and then on the input port (or intermediary points
before that).
\end{itemize}
Note that to make a
link originate  from another link (to split a link), user should first click
on the {\tt Link} button and then on an existing link, where split is
to be placed, and finally on an input port (or intermediary points
before that). The process of link creation can be stopped and current link deleted
by clicking on the right mouse button.

Note also that at least one  scope or a ``write to file'' block should be placed in any Scicos 
diagram to visualize or save the result of the simulation. See Scicos demos for
examples. 

\subsection{Parameter adaptation}
Block parameters can be modified by opening the block dialogs. This can be
done using the {\tt Open/set} button. Most blocks have dialog menus which can be
used to set or modify block parameters. These parameters can be defined using
valid Scilab expressions. Scilab variables can be used in the definition of these
expressions if they are already defined in the context of diagram. These
expressions are memorized symbolically, and
then evaluated. 

The context of the diagram can be edited by selecting the {\tt Context} button.
The context is evaluated by the {\tt Eval} button. This is necessary only if the
context modification includes a change in the value of a variable previously used in the
definition of a block parameter.

\subsection{Simulation}
A completed diagram can be simulated using {\tt Run} in the
{\tt Simulate} menu. Selecting this button results in a compilation
of the diagram (if not already compiled) and simulation.
The simulation can be stopped by clicking on the {\tt stop} button on
top of the Scicos main window. 


A compiled Scicos diagram, saved as a {\tt *.cos} file, 
does not need compilation the next time it is loaded; the saved file contains, the
result of the compilation. It is also possible to 
extract just the data needed to do simulation, and do the simulation
without having to enter the Scicos environment. This can be done
using the {\tt scicosim} function.


\subsection{Other functionalities}
The editor provides many other functionalities such as
\begin{itemize}
\item saving and loading diagrams in various formats
\item zooming and changing the point of view
\item changing block aspects and colors
\item changing diagram's background and forground colors
\item placing text in the diagram
\item printing and exporting Scicos diagrams
\item and many other standard GUI functions.
\end{itemize}
The {\tt Help} button can be used to obtain help on various aspects of Scicos.
Selecting {\tt Help} and then clicking on a block displays the manual page of the block.
Selecting {\tt Help} and then selecting another button, displays the manual page of the button.


Finally, an important feature in Scicos is the possibility of creating sub-systems (Super Blocks).
Clearly, it would not be desirable to fit a complex system with hundreds of
components in one Scicos diagram. For that, Scicos provides the possibility
of grouping blocks together and defining sub-diagrams called Super Blocks.
These blocks behave like any other block but can contain
an unlimited number of blocks, and even other Super Blocks. 




\section{Basic Blocks}
There are three types of Basic Blocks in Scicos: Regular Basic Blocks,
Zero Crossing Basic Blocks and Synchro Basic Blocks. These blocks have can have two types of
inputs and two types of outputs ports: regular inputs, activation inputs,
regular 
outputs and activation outputs ports. Regular inputs and outputs are
interconnected by regular links, and activation inputs and outputs, by
activation links. Note that activation input ports are placed on top and activation output
ports at the bottom of the blocks. 

\subsection{Regular Basic Block}
Regular Basic Blocks (RBB) can have a {\em continuous state} $x$ and a 
{\em discrete state} $z$. If it does have an $x$ and if $u$ denotes its regular input, then,
when the block is active over an interval of time, $x$ evolves continuously according to
\begin{equation}
\dot{x} = f(t,x,z,u,p,n_{e}) \label{e1}
\end{equation}
where $f$ is a vector function, $p$ is a vector of
constant parameters and $n_{e}$ is the {\em activation
code} which is an integer designating the port(s)  through which the block is
activated. In particular, if activating input ports are
$i_1,i_2,\dots,i_n$, then
\[
n_{e}=\sum_{j=1}^n 2^{i_j-1}.
\]

On the other hand, activated by an event, the states $x$ and $z$ jump
instantaneously according to the following equations:
\begin{eqnarray}
x(t_e) &=& g_c(t_e,x(t_e^-),z(t_e^-),u(t_e),p,n_{e}) \label{e11}\\
z(t_e) &=& g_d(t_e,x(t_e^-),z(t_e^-),u(t_e),p,n_{e}) \label{e12}
\end{eqnarray}
where $t_e$ denotes the event time. The discrete state $z$ remains constant 
between any two successive events so $z(t_e^-)$ can be interpreted as the previous value of $z$.

During activation times, the regular output of the block is defined by
\begin{equation}
y(t)=h(t,x(t^-),z(t^-),u(t),p,n_{e}) \label{e2}
\end{equation}
and is constant when the block is not active.

Finally, RBB's can generate activation signals of event type.
If it is activated by an event at time $t_e$, the time 
of each output event is given by
\begin{equation}
t_{evo} = k(t_e,z(t_e),u(t_e),p,n_{e})  \label{e20}
\end{equation}
where $t_{evo}$ is a vector of time, each entry of which corresponds to one activation output port. 
The absence of event corresponds to a time smaller than the current time. 
Event generations can also be pre-scheduled. Pre-scheduling of events
can  be done by setting the "initial  firing variables of blocks 
with event output ports.  


\subsection{Zero Crossing Basic Block} 
Zero Crossing Basic Block (ZBB)  can generate event outputs only if at least
one of the regular inputs crosses zero (changes sign). In such a case, the
generation of the event, and its timing, can depend on the combination of
the inputs which have crossed zero and the signs of the inputs just
before the crossing occurs. 

A few examples of ZBB's can be found in the {\tt Threshold} palette. 


\subsection{Synchro Basic Block}
\label{syn}
Synchro Basic Blocks (SBB) generate output activation signals that are
synchronized with their input activation signals. These blocks have a
unique activation input port; they route their input activation signals
to one of their activation outputs. The choice of this output depends
on the value of the regular input. Examples are
the {\tt event select} block and
the {\tt If-then-else} block in the {\tt Branching} palette.



\section{Time dependence and inheritance}
To avoid explicitly drawing all the activation
signals in a Scicos diagram, a feature called inheritance is
provided in Scicos. In particular, if a block has no activation input port, it inherits its
activation signal from its regular input signals. And for blocks which are active 
permanently, they can be declared as such (``time dependent'') and they do not
need input activation ports. Note that time dependent blocks do not inherit.



\section{Block construction}
A new block can be constructed as a Super Block (by interconnection of basic
blocks) and compiled. As for a new basic block, it can be 
defined by a pair of functions: 
\begin{itemize}
\item an \interfacing function for handling the user-interface
\item a \computational function for specifying its dynamic behavior.
\end{itemize}
The \interfacing function is always written as a  Scilab function. See 
Scilab functions in {\tt <SCIDIR>/macros/scicos\_blocks}
for examples. The \computational function can be written in 
C or Fortran. See {\tt <SCIDIR>/routines/scicos} for examples.
But it can also be written in Scilab language. C and Fortran routines dynamically linked or
permanently interfaced with Scilab give the better results as far as  
simulation performance is concerned. 

The {\tt Scifunc}, {\tt GENERIC}, {\tt C\_block} and {\tt Fortran\_block} blocks provide
generic \interfacing functions, very useful for rapid prototyping and testing user-developed
\computational functions.


\subsection{\interfacing function}
The \interfacing function determines the geometry, color, number
of ports and their sizes, icon, etc..., in addition to the initial states,
parameters. This function also handles the block's user dialog.

What the interfacing function should do and should
return depends on an input flag {\tt job}. The syntax is as follows:

\subsubsection{Syntax}
\begin{verbatim}
 [x,y,typ]=block(job,arg1,arg2)
\end{verbatim}

\paragraph{Parameters}
\begin{itemize}
\item job=='plot': the function draws the block. 
  \begin{itemize}
  \item {\tt arg1} is the data structure of the block.
  \item {\tt arg2} is not used.
  \item {\tt x,y,typ} are not used.
  \end{itemize}
In general, we can use {\tt standard\_draw} \label{stdd} function
which  draws a rectangular block, and the input and output ports. It
also handles the size, icon, and color aspects of the block.

\item job=='getinputs': the function returns position and type of
  input ports (regular or activation). 
  \begin{itemize}
  \item  {\tt arg1} is the data structure of the block.
  \item  {\tt arg2} is not used.
  \item {\tt x} is the vector of x coordinates of input ports.
  \item {\tt y} is the vector of y coordinates of input ports.
  \item {\tt typ} is the vector of input ports types (1 for regular
and 2 for activation). 
  \end{itemize}
  In general, we can use the {\tt standard\_input} function.
\item job=='getoutputs': returns position and type of output ports
(regular and activation). 
  \begin{itemize}
  \item  {\tt arg1} is the data structure of the block. 
  \item  {\tt arg2} is not used.
  \item {\tt x} is the vector of x coordinates of output ports.
  \item {\tt y} is the vector of y coordinates of output ports.
  \item {\tt typ} is the vector of output ports types .
  \end{itemize}
In general, we can use the {\tt standard\_output} function.
\item job=='getorigin': returns coordinates of the lower
  left point of the rectangle containing the block's silhouette.
  \begin{itemize}
  \item  {\tt arg1} is the data structure of the block. 
  \item  {\tt arg2} is not used.
  \item {\tt x} is the x coordinate of the lower left point of the block.
  \item {\tt y} is the y coordinate of the lower left point of the block.
  \item {\tt typ} is not used.
  \end{itemize}
In general, we can use the {\tt standard\_origin} function.
\item job=='set': opens up a dialogue for block parameter acquisition
(if any).
  \begin{itemize}
  \item  {\tt arg1} is the data structure of the block. 
  \item  {\tt arg2} is not used.
  \item {\tt x} is the new data structure of the block.
  \item {\tt y} is not used.
  \item {\tt typ} is not used.
  \end{itemize}
\item  job=='define': initialization of block's data
  structure (name of corresponding \computational function, type, 
  number and sizes of inputs and outputs, etc...).
  \begin{itemize}
  \item  {\tt arg1, arg2} are not used.
  \item {\tt x} is the data structure of the block.
  \item {\tt y} is not used.
  \item {\tt typ} is not used.
  \end{itemize}
\end{itemize}

\subsubsection{Block data-structure definition}
\label{bds}
Each Scicos block is defined by a Scilab data structure as
follows:

\begin{verbatim}
 list('Block',graphics,model,unused,GUI_function)
\end{verbatim}
where {\tt GUI\_function} is a string containing the name of the
corresponding \interfacing function and
{\tt graphics} is the structure containing the graphical data:
\begin{verbatim}
graphics=..
  list([xo,yo],[l,h],orient,dlg,pin,pout,pcin,pcout,gr_i)
\end{verbatim}
\begin{itemize}
\item \textbf{xo}: x coordinate of block origin
\item \textbf{yo}: y coordinate of block origin
\item \textbf{l}: block's width
\item \textbf{h}: block's height
\item \textbf{orient}:  boolean, specifies if block is flipped or not (regular
inputs are on the left or right).
\item \textbf{dlg}: \label{dlg2} vector of character strings, contains block's
symbolic parameters.
\item \textbf{pin}: vector, {\tt pin(i)} is  the number  of the link
connected to {\tt i}th regular input port, or 0 if this port is not
connected. 
\item \textbf{pout}: vector, {\tt pout(i)} is  the number  of the link
  connected to {\tt i}th regular output port, or 0 if this port is not
  connected.
\item \textbf{pcin}: vector, {\tt pcin(i)} is  the number  of the link
  connected to {\tt i}th activation input port, or 0 if this port is not
  connected.
\item \textbf{pcout}: vector, {\tt pcout(i)} is  the number  of the link
  connected to {\tt i}th activation output port, or 0 if this port is not
  connected.
\item \textbf{gr\_i}: character string vector, Scilab instructions used to draw
  the icon.
\end{itemize}
The data structure containing simulation information is {\tt model}:
\label{model}
\begin{verbatim}
model=list(eqns,#input,#output,#clk_input,#clk_output,..
      state,dstate,rpar,ipar,typ,firing,deps,label,unused)
\end{verbatim}
\begin{itemize}
\item \textbf{eqns}: \label{eqns} list containing two elements. First element
is a string containing 
the name of the \computational function (fortran, C, or Scilab
function). Second element 
is an integer specifying the type of the \computational function. The
type of a \computational function specifies essentially its calling
sequence; more on that later. 
\item \textbf{\#input}: vector of size equal to the number of block's regular
input ports. Each entry specifies the size of the corresponding input
port. A negative integer stands for  ``to be determined by the
compiler''. Specifying the same negative integer on 
more than one input or output port tells the compiler that these ports have
equal sizes. 
\item \textbf{\#output}: vector of size equal to the number of block's regular
output ports. Each entry specifies the size of the corresponding
output port. Specifying the same negative integer on 
more than one input or output port tells the compiler that these ports have
equal sizes. 
\item \textbf{\#clk\_input}: vector of size equal to the number 
of activation input ports. All entries
must be equal to $1$. Scicos does not support vectorized activation links.

\item \textbf{\#clk\_output}: vector of size equal to the 
number of activation output ports. All entries
must be equal to $1$. Scicos does not support vectorized activation links.

\item \textbf{state}: column vector of initial continuous state.
\item \textbf{dstate}: column vector of initial discrete state.
\item \textbf{rpar}: column vector of real parameters passed on to the corresponding
\computational function.
\item \textbf{ipar}: column vector of integer parameters passed on to the
corresponding \computational function.
\item \textbf{typ}: string. Basic block type: {\tt 'z'} if ZBB, 
{\tt 'l'} if
SBB and anything else for except {\tt 's'} for RBB.
\item \textbf{firing}: column vector of initial firing times of size  equal to
the number of activation output ports of the block. It includes
preprogrammed event firing times ($<$0 if no firing). 

\item \textbf{deps}: [{\tt udep} {\tt timedep}] 
  \begin{itemize}
  \item \textbf{udep}: boolean. True if system has direct feed-through, i.e., at least
one of the outputs depends explicitly on one of the inputs.
  \item \textbf{timedep}: boolean. True if block is time dependent.
  \end{itemize}
\item \textbf{label}: character string, used as block identifier. This field
  may be set by the {\tt label} button in {\tt Block} menu.
\end{itemize}


\subsection{\computational function}
The \computational function  evaluates outputs, new states,
continuous state derivative and the output events timing vector
depending on the type of the block and the way it is called by the
simulator. 

\subsubsection{Behavior}
\label{tasks}
Simulator calls the \computational function for performing 
different tasks:

\begin{itemize}
\item \textbf{Initialization} The simulator calls the \computational function once
at the start for state and output initialization (inputs
are not available then).  Other tasks such as file opening, graphical window
initialization, etc..., can also be performed at this point.

\item \textbf{Re-initialization} The simulator can call the block a number of times for 
re-initialization. This is another opportunity to initialize
states and outputs. But this time, the inputs are
available. 

\item \textbf{Outputs update} The simulator calls for the value of
the outputs. Thus the \computational function should evaluate
(\ref{e2}).

\item \textbf{States update} One or more events have arrived and  the
simulator calls the \computational function to update the
states $x$ and $z$  according to (\ref{e11}) and
(\ref{e12}). 

\item \textbf{State derivative computation}
The simulator is in a continuous phase; the
solver requires $\dot{x}$. This means that the \computational function 
must evaluate (\ref{e1}).

\item \textbf{Output events timing} The simulator calls the \computational
function  about the timing of its output events. The
\computational function should evaluate (\ref{e20}).

\item \textbf{Ending} The simulator calls
the \computational function once at the end (useful for closing files, free allocated 
memory, etc...).

\end{itemize}

The simulator uses a flag to specify which task should be performed
(see Table~\ref{tab2}).

\begin{table}[ht]
\begin{center}
\begin{tabular}{|c|l|}
\hline
Flag & Task \\
\hline
0 & State derivative computation \\
1 & Outputs update \\
2 & States update \\
3 & Output events timing \\
4 & Initialization \\
5 & Ending \\
6 & Re-initialization \\
\hline
\end{tabular}
\caption{Tasks of \computational function and their corresponding flags}
\label{tab2}
\end{center}
\end{table}



\subsubsection{Types of \computational functions}
In Scicos, \computational functions can be of different types
and co-exist in the same diagram. Currently defined types are
listed in Table~\ref{tab1}. The type of the \computational function
is stored in the second field of {\tt eqns} (see Section~\ref{eqns}). 

\begin{table}[ht]
\begin{center}
\begin{tabular}{|c|c|c|c|l|} \hline
Function type& Scilab & Fortran & C & Comments \\ \hline
0 & yes & yes & yes & Fixed calling sequence \\
1 & no &  yes & yes & Varying calling sequence   \\
2 & no &  no  & yes & Fixed calling sequence  \\
3 & yes& no  &  no  & Inputs/outputs are Scilab lists\\ \hline
\end{tabular}
\caption{Different types of the \computational functions. 
Type $0$ is obsolete.}
\label{tab1}
\end{center}
\end{table}

\paragraph{\computational function: type 0}
In blocks of type 0, the simulator constructs a unique input vector by
stacking up all the input vectors, and expects the outputs, stacked up
in a unique vector as well. This type is supported for backward only.

The calling sequence is identical to that of \computational functions of type 1
with one regular input and one regular output.

\paragraph{\computational function: type 1}
The simplest way of illustrating this type is by considering
an example:
for a block with two regular input vectors and four regular output
vectors, the \computational function has the following synopsis.

\paragraph{Fortran case}
\begin{verbatim}
      subroutine myfun(flag,nevprt,t,xd,x,nx,z,nz,tvec,
     &   ntvec,rpar,nrpar,ipar,nipar,u1,nu1,u2,nu2,
     &   y1,ny1,y2,ny2,y3,ny3,y4,ny4)
c
      double precision t,xd(*),x(*),z(*),tvec(*),rpar(*)
      double precision u1(*),u2(*),y1(*),y2(*),y3(*),y4(*)
      integer flag,nevprt,nx,nz,ntvec,nrpar,ipar(*)
      integer nipar,nu1,nu2,ny1,ny2,ny3,ny4
\end{verbatim}


See Tables~\ref{tab11} for a description of the arguments.
\begin{table}[ht]
\begin{center}
\begin{tabular}{|c|c|l|} \hline
I/O&Args.&Description \\ \hline
I&  {\tt flag}& 0,1,2,3,4,5 or 6,  (see Table~\ref{tab2})\\
I& {\tt nevprt}& activation code  \\
I& {\tt t}& time\\
O& {\tt xdot}& derivative of the continuous state \\
I/O& {\tt x}& continuous state\\
I& {\tt nx}& size of {\tt x}\\
I/O& {\tt z}& discrete state\\
I& {\tt nz}& size of {\tt z}\\
O& {\tt tvec}& times of output events (for {\tt flag}$=$3) \\
I& {\tt ntvec}& number of activation output ports\\
I& {\tt rpar}& parameter\\
I& {\tt nrpar}& size of {\tt rpar}\\
I& {\tt ipar}& parameter\\
I& {\tt nipar}& size of {\tt ipar}\\
I& {\tt ui}& {\tt i}th input (regular), {\tt i}=1,2,\ldots\\
I& {\tt nui} & size of {\tt i}th input \\
O& {\tt yj}& {\tt j}th output (regular), {\tt j}=1,2,\ldots\\
I& {\tt nyj}& size of {\tt j}th output \\ \hline
\end{tabular}
\caption{Arguments of \computational functions of type 1. I: input, O:
output.}
\label{tab11}
\end{center}
\end{table}

\paragraph{C case}
Type 1 \computational functions can also be written in C language,
the same way. Note that, arguments must be passed as pointers.


The best way to learn how to write these functions is to examine the
routines in the Scilab directory 
{\tt SCIDIR/routines/scicos} where \computational functions of all Scicos blocks are available.
Most of them are fortran type~0 and~1.

\paragraph{\computational function type 2}
This \computational function type is specific to programming in C. The
synopsis is:

\begin{verbatim}
#include "<SCIDIR>/routines/machine.h"
void selector(flag,nevprt,t,xd,x,nx,z,nz,tvec,ntvec,
   rpar,nrpar,ipar,nipar,inptr,insz,nin,outptr,outsz,nout)

integer *flag,*nevprt,*nx,*nz,*ntvec,*nrpar;
integer ipar[],*nipar,insz[],*nin,outsz[],*nout;

double x[],xd[],z[],tvec[],rpar[];
double *inptr[],*outptr[],*t;
\end{verbatim}

See Table~\ref{tab20} for a description of arguments.
\begin{table}[ht]
\begin{center}
\begin{tabular}{|c|c|l|} \hline
I/O&Args.&description \\ \hline
I& {\tt  *flag}& 0,1,2,3,4,5 or 6,  (see Table~\ref{tab2})\\
I& {\tt  *nevprt}& activation code \\
I& {\tt  *t}& time\\
O& {\tt  xd}& derivative of the continuous
       state ({\tt flag}$=0$) \\
I/O& {\tt  x}& continuous state\\
I& {\tt  *nx}& size of {\tt x}\\
I/O& {\tt  z}& discrete state\\
I& {\tt  *nz}& size of {\tt z}\\
O& {\tt  tvec} & times of output events ({\tt flag}$=$3)\\
I& {\tt  *ntvec}& number of activation output ports\\
I& {\tt  rpar}& parameter\\
I& {\tt  *nrpar}& size of {\tt rpar}\\
I& {\tt  ipar}& parameter\\
I& {\tt  *nipar}& size of {\tt ipar}\\
I& {\tt  inptr}& {\tt inptr[i]} is  pointer to
         beginning of  {\tt i}th  input\\
I& {\tt  insz}& {\tt insz[i]} is the size of the
        {\tt i}th   input \\
I& {\tt  *nin}& number of  input ports\\
I& {\tt  outptr}& {\tt outptr[j]} is pointer to 
       beginning of {\tt j}th  output \\
I& {\tt  outsz}& {\tt outsz[j]} is the size of the
          {\tt j}th   output \\
I& {\tt  *nout}& number of  output ports \\ \hline
\end{tabular}
\caption{Arguments of \computational functions of type 2. I: input, O: output.}
\label{tab20}
\end{center}
\end{table}


\paragraph{\computational function type 3}
This \computational function type is specific to programming in
Scilab. The calling sequence is as follow:
\begin{verbatim}
[y,x,z,tvec,xd]=test(flag,nevprt,t,x,z,rpar,ipar,u)
\end{verbatim}  
See table~\ref{tab30} for a description of arguments.
\begin{table}[ht]
\begin{center}
\begin{tabular}{|c|c|l|} \hline
I/O&Args.&description \\ \hline
I &  {\tt flag} & 0,1,2,3,4,5 or 6  (see Table~\ref{tab2}) \\
I &  {\tt nevprt} & activation code (scalar)\\
I &  {\tt t} & time (scalar)\\
I &  {\tt x} & continuous state (vector)\\
I &  {\tt z} & discrete state (vector)\\
I &  {\tt rpar}  &parameter (any type of scilabtt variable)\\
I &  {\tt ipar} & parameter (vector)\\
I &  {\tt u} & {\tt u(i)} is the vector of {\tt i} th regular input (list) \\
O &  {\tt y}& {\tt y(j)} is the vector of {\tt j} th regular output (list)\\
O &  {\tt x} & new x if {\tt flag}$=$2, 4, 5 or 6 \\
O &  {\tt z} & new z if {\tt flag}$=$2, 4, 5 or 6 \\
O &  {\tt xd} & derivative of x if {\tt flag}$=0$ (vector), [ ] otherwise\\
O &  {\tt tvec} & times of output events if {\tt flag}$=$3 (vector), [ ] otherwise \\ \hline
\end{tabular}
\caption{Arguments of \computational functions of type 3. I: input, O: output.}
\label{tab30}
\end{center}
\end{table}
 


\paragraph{Example}
The following is the \computational function associated with a block
that displays in a Scilab window, every time it receives an event, the
number of events it has received up to the current time, and the values
of its two inputs.
\begin{verbatim}
function [y,x,z,tvec,xd]=test(flag,nevprt,t,x,z,rpar,ipar,u)
y=list();tvec=[];xd=[]
if flag==4 then
    z=0
elseif flag==2 then
    z=z+1
    write(%io(2),'Number of calls:'+string(z))
    [u1,u2]=u(1:2)
    write(%io(2),'first input');disp(u1)
    write(%io(2),'second input');disp(u2)
end
\end{verbatim}

\paragraph{Example}
The advantage of coding inputs and outputs as lists is that
the number of inputs and outputs need not be specified
explicitly. In this example, the output is the element-wise
product of all the input vectors, regardless of the number
of inputs.

\begin{verbatim}
function [y,x,z,tvec,xd]=elemprod(flag,nevprt,t,x,z,rpar,ipar,u)
tvec=[];xd=[]
y=u(1)
for i=2:length(u)
   y=y.*u(i)
end
y=list(y)
\end{verbatim}

\section{Conclusion}
This document gives only a brief description of Scicos and its
usage. More information can be found in the manual pages of Scicos
functions (Scilab help under Scicos library). Scicos demos provided with
Scilab constitute also an interesting source of information. Often,
it is advantageous to start off from and edit a Scicos demo rather than
starting with an empty diagram. 

\end{document}
